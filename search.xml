<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>文章介绍</title>
    <url>/2020/07/05/article_record/</url>
    <content><![CDATA[<h4 id="题记"><a href="#题记" class="headerlink" title="题记"></a>题记</h4><p>​        这是针对目前已有的文章进行记录说明.   往后希望每周或者自己有空的时候,就多写一些文章或者个人记录。这其中肯定也是有一定的错误的,如果是有错误的的地方,还是希望各位有心人帮我指出来,然后我能够更正.</p>
<p>​       邮箱地址 :  <a href="mailto:1411091515@qq.com">1411091515@qq.com</a></p>
<p>​       QQ : 1411091515</p>
<p>可以通过以上方式联系, 欢迎指出有错误的地方.</p>
<h4 id="Spring-系列"><a href="#Spring-系列" class="headerlink" title="Spring 系列"></a>Spring 系列</h4><p>​       阅读 Spring 其内部代码实现的记录</p>
<table>
<thead>
<tr>
<th>Project</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>Spring</td>
<td>Spring<a href="http://www.lwfby.cn/2020/06/27/spring/Spring_Construction/">构造函数阅读</a>                      Spring的refresh<a href="http://www.lwfby.cn/2020/06/28/spring/Spring_Refresh/">方法阅读</a>                     Spring<a href="http://www.lwfby.cn/2020/07/02/spring/Spring_Custom/">小扩展一下</a></td>
</tr>
</tbody></table>
<h4 id="Java源码系列"><a href="#Java源码系列" class="headerlink" title="Java源码系列"></a>Java源码系列</h4><p>​     Java的阅读是必不可少的,阅读是非常有必要的.</p>
<table>
<thead>
<tr>
<th>Project</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>Java集合篇</td>
<td>Vector<a href="http://www.lwfby.cn/2020/04/29/java_list/Vector/">阅读记录</a>                                                                           LinkedList<a href="http://www.lwfby.cn/2020/04/29/java_list/LinkedList_Source/">阅读记录</a>                             <a href="http://www.lwfby.cn/2020/04/30/java_list/ArrayDeque_Source/">ArrayDeque</a>                                                                                 <a href="http://www.lwfby.cn/2020/05/06/java_list/ArrayList_Source/">ArrayList</a>                                                <a href="http://www.lwfby.cn/2020/05/12/java_list/PriorityQueue_source/">PriorityQueue</a>                                                                             <a href="http://www.lwfby.cn/2020/05/22/java_list/HashMap_Source/">HashMap</a></td>
</tr>
<tr>
<td>Java 线程篇</td>
<td><a href="http://www.lwfby.cn/2020/06/20/ThreadLocal_source/">ThreadLocal</a>                       <a href="http://www.lwfby.cn/2020/06/20/ReentrantLock_source/">ReentrantLock</a></td>
</tr>
<tr>
<td>Java 反射篇</td>
<td><a href="http://www.lwfby.cn/2020/07/01/java_reflect_1/">反射学习</a></td>
</tr>
</tbody></table>
<p>​      </p>
<h4 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h4><p>​     对于技术人来说, 一个发展方向的技术栈是很重要的。  你总要沿着某个方法走才行.   不管怎么说,不辜负自己想做什么的这段时间就可以了啦.</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​       期待每天的成长都不一样.</p>
]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>文章</tag>
      </tags>
  </entry>
  <entry>
    <title>关于我BaoYang</title>
    <url>/2019/10/07/%E5%85%B3%E4%BA%8E%E6%88%91/</url>
    <content><![CDATA[<p>这里用于记录个人学习和生活的博客;使用的是Github + Hexo 来搭建的，由于是第一次使用,在很多方面都不是很懂，后续会慢慢的来更新这些信息。</p>
<p>最近犯了一个很严重的错误,让我严重的意识到一些态度的问题对于个人来说还是很重要的。如果不是这些事,也许我还是无法很快速的成长，也许给我现在的感触最深的几个地方就是.我为什么会有这种错误的出现?当出现这种错误后,又是因为我个人不能很好的处理掉乱七八糟的.</p>
<p>2019-10-17  已经有好几天没有提交代码上github，提心吊胆的感觉也是让我觉得很难受。有些错误,我相信我自己以后是不会再出现的了.</p>
<p>2019-10-22 坚持使用csdn来记录技术或者博客等,这里的博客希望更多的总结或者文章的汇总等.加油,给自己.</p>
<p>个人 : BaoYang , Java爱好者,虽然平时也会捣鼓一些其他的东西,毕竟刚刚工作对一些新的东西有时候或者说是居多的时候,总是会充满一些好奇感忍不住去研究下它的好处或者使用啥的啊。</p>
<p><a href="https://blog.csdn.net/by_yangge" target="_blank" rel="noopener">https://blog.csdn.net/by_yangge</a> csdn博客地址也是用于记录一些个人的学习东西或者遇见的错误记录等问题。关于写博客或者记录一下个人的状态等信息,我个人虽然也是刚刚开始,更多的时候,我也是希望我可以长期的坚持下来记录学习和博客的记载等. 也是看个人和 贵在坚持这点吧.</p>
]]></content>
      <categories>
        <category>关于个人的</category>
      </categories>
      <tags>
        <tag>关于我</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis缓存知识学习</title>
    <url>/2020/04/19/cache/redis%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h3 id="Redis-缓存知识的学习"><a href="#Redis-缓存知识的学习" class="headerlink" title="Redis 缓存知识的学习"></a>Redis 缓存知识的学习</h3><blockquote>
<p>现在缓存,消息队列,集群(集群就涉及到很多中间件)的使用或者说是学习都是必须的,也是必备的. 所以就这周就打算学习下Redis缓存方面的知识来记录。</p>
</blockquote>
<h3 id="Redis-安装-基于Linux"><a href="#Redis-安装-基于Linux" class="headerlink" title="Redis 安装(基于Linux)"></a>Redis 安装(基于Linux)</h3><blockquote>
<p>这里说下我使用的电脑环境是 Ubuntu , 所以在执行make的时候,很多gcc之类的东西是不需要安装的.</p>
</blockquote>
<p>  这里我们使用Redis 官方给出来的案例来进行安装</p>
<ol>
<li><p>wget <a href="http://download.redis.io/releases/redis-5.0.8.tar.gz" target="_blank" rel="noopener">http://download.redis.io/releases/redis-5.0.8.tar.gz</a> (<a href="https://redis.io/download" target="_blank" rel="noopener">https://redis.io/download</a>) 使用wget 或者去官网上下载都是可以的。</p>
</li>
<li><p>tar zxvf redis-5.0.8.tar.gz   这里使用官方目前提供的来进来下载。</p>
</li>
<li><p>cd redis-5.0.8   目录下面  然后执行 make (看你的权限是不是要执行 sudo make) </p>
</li>
<li><p>cd src 下面  sudo ./redis-server</p>
</li>
</ol>
<hr>
<p>启动成功界面</p>
<p>13827:C 19 Apr 2020 14:48:09.023 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo<br>13827:C 19 Apr 2020 14:48:09.023 # Redis version=5.0.8, bits=64, commit=00000000, modified=0, pid=13827, just started<br>13827:C 19 Apr 2020 14:48:09.023 # Warning: no config file specified, using the default config. In order to specify a config file use ./redis-server /path/to/redis.conf<br>13827:M 19 Apr 2020 14:48:09.024 * Increased maximum number of open files to 10032 (it was originally set to 1024).<br>           <em>.</em><br>      <em>.-``__ ‘’-.</em><br> <em>.-``    <code>.</code></em>.  ‘’-._           Redis 5.0.8 (00000000/0) 64 bit<br>.-<code>.-```.  ```\/    _.,_ &#39;&#39;-._                                   
(    &#39;      ,       .-`  | `,    )     Running in standalone mode
|`-._`-...-` __...-.</code>-.<em>|’<code>_.-&#39;|     Port: 6379
|</code>-.</em>   <code>._    /     _.-&#39;    |     PID: 13827</code>-._    <code>-._</code>-./  <em>.-‘    _.-‘<br>|<code>-._</code>-.</em>    <code>-.__.-&#39;    _.-&#39;_.-&#39;|                                  
|</code>-.<em>`-.</em>        <em>.-‘</em>.-‘    |           <a href="http://redis.io" target="_blank" rel="noopener">http://redis.io</a><br><code>-._</code>-.<em>`-.__.-‘</em>.-‘    <em>.-‘<br>|<code>-._</code>-.</em>    <code>-.__.-&#39;    _.-&#39;_.-&#39;|                                  
|</code>-.<em>`-.</em>        <em>.-‘</em>.-‘    |<br><code>-._</code>-.<em>`-.__.-‘</em>.-‘    <em>.-‘<br> `-.</em>    <code>-.__.-&#39;    _.-&#39;</code>-._        <em>.-‘<br>         `-._</em>.-‘                                      </p>
<hr>
<p>13827:M 19 Apr 2020 14:48:09.024 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.<br>13827:M 19 Apr 2020 14:48:09.024 # Server initialized<br>13827:M 19 Apr 2020 14:48:09.024 # WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add ‘vm.overcommit_memory = 1’ to /etc/sysctl.conf and then reboot or run the command ‘sysctl vm.overcommit_memory=1’ for this to take effect.<br>13827:M 19 Apr 2020 14:48:09.024 # WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command ‘echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled’ as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.<br>13827:M 19 Apr 2020 14:48:09.024 * Ready to accept connections</p>
<hr>
<p>   然后就可以看到 redis的启动界面, 然后再开一个黑窗口,也同样是在src下面, sudo ./redis-cli  就可以连上(这里我都是在同一台server上,ip,port什么都是默认的, 如果你启动有修改的话,那么连接的时候,这些配置也是需要进行修改的)</p>
<p><strong>对于 Redis的安装,熟悉Linux的朋友还是很快的。</strong></p>
<hr>
<h3 id="Redis-数据结构"><a href="#Redis-数据结构" class="headerlink" title="Redis 数据结构"></a>Redis 数据结构</h3><ol>
<li><p>字符串 String</p>
<blockquote>
<p>127.0.0.1:6379[1]&gt; set name yang<br>OK<br>127.0.0.1:6379[1]&gt; get name<br>“yang”</p>
<p>可以看到对于 String 存储还是常规的</p>
</blockquote>
</li>
<li><p>字典 Hash</p>
<blockquote>
<p>127.0.0.1:6379[1]&gt; HSET json1 name gavin age 18<br>(integer) 2</p>
<p>127.0.0.1:6379[1]&gt; hget json1 name<br>“gavin”<br>127.0.0.1:6379[1]&gt; hget json1 age<br>“18”</p>
<p> 对于Hash 存储的基本操作,基于还是看你个人想怎么存储. </p>
<p> 127.0.0.1:6379[1]&gt; HEXISTS json1 json<br>(integer) 0<br>127.0.0.1:6379[1]&gt; HEXISTS json1 name<br>(integer) 1</p>
<p> 这是判断这个key是否存在</p>
</blockquote>
</li>
<li><p>列表List</p>
<blockquote>
<p>127.0.0.1:6379[1]&gt; lpush list1 1,2,3,4,5,6,7<br>(integer) 1<br>127.0.0.1:6379[1]&gt; lpush list1 8 9 10 11 12 13 14<br>(integer) 8<br>127.0.0.1:6379[1]&gt; LRANGE list1 0 11<br>1) “14”<br>2) “13”<br>3) “12”<br>4) “11”<br>5) “10”<br>6) “9”<br>7) “8”<br>8) “1,2,3,4,5,6,7”</p>
<p>可以看出lpush 对于添加的顺序，最先添加的值是在最后面的。</p>
<p>127.0.0.1:6379[1]&gt; RPUSH list1 latsone<br>(integer) 9</p>
<p>127.0.0.1:6379[1]&gt; LRANGE list1 0 13<br>1) “14”<br>2) “13”<br>3) “12”<br>4) “11”<br>5) “10”<br>6) “9”<br>7) “8”<br>8) “1,2,3,4,5,6,7”<br>9) “latsone”</p>
<p>rpush 就是直接在最尾部进行追加.</p>
<p>lpop key(lits1 对应自己的key) : 返回并删除指定 Key 的链表中的第一个元素</p>
<p>rpop key: 返回并删除指定 Key 的链表中的最后一个元素,即尾元素 </p>
</blockquote>
</li>
<li><p>集合Set</p>
<blockquote>
<p>127.0.0.1:6379[1]&gt; sadd set1 a b c<br>(integer) 3<br>127.0.0.1:6379[1]&gt; sadd set z<br>(integer) 1<br>127.0.0.1:6379[1]&gt; SMEMBERS set1<br>1) “b”<br>2) “a”<br>3) “c”<br>127.0.0.1:6379[1]&gt; SISMEMBER set1 c<br>(integer) 1<br>127.0.0.1:6379[1]&gt; SISMEMBER set1 x<br>(integer) 0<br>127.0.0.1:6379[1]&gt; SMEMBERS set1<br>1) “b”<br>2) “a”<br>3) “c”<br>127.0.0.1:6379[1]&gt; SREM set1 a<br>(integer) 1<br>127.0.0.1:6379[1]&gt; SMEMBERS set1<br>1) “b”<br>2) “c”</p>
<p>sadd  是进行添加</p>
<p>smembers  进行查看该集合中数据</p>
<p>sismember 判断集合中是否有该值,如果是有的话,就会返回1,如果是没有的话,就会返回0</p>
<p>srem 是删除集合中某个元素. 如果存在删除就返回1,如果不存在删除就会返回0 </p>
</blockquote>
</li>
<li><p>有序集合 ZSet</p>
<blockquote>
<p>127.0.0.1:6379[1]&gt; SREM set1 add<br>(integer) 0<br>127.0.0.1:6379[1]&gt; zadd scores 90 ‘Chinese’<br>(integer) 1<br>127.0.0.1:6379[1]&gt; zadd scores 94 ‘math’<br>(integer) 1<br>127.0.0.1:6379[1]&gt; zadd scores 96 ‘english’<br>(integer) 1<br>127.0.0.1:6379[1]&gt; ZRANGE scores 0 -1<br>1) “Chinese”<br>2) “math”<br>3) “english”<br>127.0.0.1:6379[1]&gt; ZRANGE scores 0 -1 withscores<br>1) “Chinese”<br>2) “90”<br>3) “math”<br>4) “94”<br>5) “english”<br>6) “96”<br>127.0.0.1:6379[1]&gt; zadd scores 88 ‘matha’<br>(integer) 1<br>127.0.0.1:6379[1]&gt; ZRANGE scores 0 -1 withscores<br>1) “matha”<br>2) “88”<br>3) “Chinese”<br>4) “90”<br>5) “math”<br>6) “94”<br>7) “english”<br>8) “96”</p>
<p>zset 的基本操作.等到你工作需要使用的时候,可以在权衡来具体使用</p>
</blockquote>
<hr>
</li>
</ol>
<p>   还有一些数据结果，对于平常的项目或者需求是很少使用到的.这里也列举出来,做一个大概的说明.</p>
<ol>
<li><p>HyperLogLog</p>
<blockquote>
<p>HyperLogLog 是用来做 <strong>基数统计</strong> 的算法. 优点 : 再输入元素的数量或者体积非常非常大的时候时候,计算基数所需要的空间总是固定的,并且很小.</p>
<p>Redis 中 HyperLogLog 键只需花费12KB内存,就可以计算接近 2^64 个不同的元素的基数.</p>
<p>127.0.0.1:6379[1]&gt; PFADD pf1 1 2 3 4 1 2 3 2 2 2 2<br>(integer) 1<br>127.0.0.1:6379[1]&gt; PFCOUNT pf1<br>(integer) 4<br>127.0.0.1:6379[1]&gt; pfadd m2 3 3 3 4 4 4 5 5 5 6 6 6 1<br>(integer) 1<br>127.0.0.1:6379[1]&gt; PFMERGE mergeN pf1 m2<br>OK<br>127.0.0.1:6379[1]&gt; PFCOUNT mergeN<br>(integer) 6</p>
<p>从结果可以看出, HyperLogLog 就是对进行统计.</p>
<p>实用场景 :  统计注册Ip个数,统计每日访问IP数 等数有关</p>
</blockquote>
</li>
<li><p>Geo</p>
<blockquote>
<p>127.0.0.1:6379[1]&gt; GEOADD cities:locations 117.12 39.08 tianjin 114.29 38.02 shijiazhuang 118.01 39.08 tangshan 115.29 38.51 baoding<br>(integer) 4</p>
<p>127.0.0.1:6379[1]&gt; GEOPOS cities:locations tianjin<br>1) 1) “117.12000042200088501”<br>  2) “39.0800000535766543”<br>127.0.0.1:6379[1]&gt; GEOPOS cities:locations tianjin baoding<br>1) 1) “117.12000042200088501”<br>  2) “39.0800000535766543”<br>2) 1) “115.28999894857406616”<br>  2) “38.50999956342798924”</p>
<p>geoadd 是存储</p>
<p>geopos 是根据地名来进行存储数据</p>
<p>127.0.0.1:6379[1]&gt; geodist cities:locations tianjin tangshan km<br>“76.8434”<br>127.0.0.1:6379[1]&gt; geodist cities:locations tianjin tangshans km<br>(nil)</p>
<p>km 是计算具体的单位 : m(米),km(千米),mi(英里),ft(英尺)</p>
<p>参考连接(<a href="https://blog.csdn.net/qq_34206560/article/details/91049218" target="_blank" rel="noopener">https://blog.csdn.net/qq_34206560/article/details/91049218</a>)</p>
</blockquote>
</li>
<li><p>Pub/Sub</p>
<blockquote>
<p>开启二个 黑窗口 来连接 redis</p>
<p>窗口一 : 对CCTV 进行订阅</p>
<p>127.0.0.1:6379&gt; subscribe CCTV<br>Reading messages… (press Ctrl-C to quit)<br>1) “subscribe”<br>2) “CCTV”<br>3) (integer) 1</p>
<p>1) “message”<br>2) “CCTV”<br>3) “\xe6\x88\x91\xe6\x98\xafGavin”</p>
<p>1) “message”<br>2) “CCTV”<br>3) “Hello Gavin”</p>
<p>窗口二 :  对CCTV 进行写</p>
<p>127.0.0.1:6379[1]&gt; publish CCTV “我是Gavin”<br>(integer) 1<br>127.0.0.1:6379[1]&gt; publish CCTV “Hello Gavin”<br>(integer) 1</p>
<p>要先开启 订阅，不然发送的消息会丢失。</p>
</blockquote>
</li>
</ol>
<hr>
<p>还有一个更需要了解的知识,是更加必不可少的.</p>
<ul>
<li>Redis Module </li>
<li>BloomFilter</li>
<li>RedisSearch</li>
<li>Redis-ML</li>
</ul>
<p>等等</p>
<hr>
<h3 id="Redis-实现分布式锁"><a href="#Redis-实现分布式锁" class="headerlink" title="Redis 实现分布式锁"></a>Redis 实现分布式锁</h3><ul>
<li><p>获取锁的时候,如果先用 setnx 来争取到锁,再给expire 的锁来设置过期时间 防止锁忘记释放. 如果在expire之前,程序出现异常的话,那么这个setnx获取到的锁就无法被释放掉.</p>
<p>如果是正常获获取锁并且设置过期时间</p>
<hr>
<p>/**</p>
<ul>
<li><p>尝试获取 分布式锁</p>
</li>
<li><p>我们使用key来当锁，因为key是唯一的。</p>
</li>
<li><p>原因就是我们在上面讲到可靠性时，分布式锁要满足第四个条件解铃还须系铃人，通过给value赋值为requestId，</p>
</li>
<li><p>我们就知道这把锁是哪个请求加的了，在解锁的时候就可以有依据。requestId可以使用UUID.randomUUID().toString()方法生成<br>*</p>
</li>
<li><p>这个参数我们填的是NX，意思是SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作</p>
</li>
<li><p>这个参数我们传的是PX，意思是我们要给这个key加一个过期的设置，具体时间由第五个参数决定</p>
</li>
<li><p>设置超时时期</p>
</li>
<li><p>@param jedis</p>
</li>
<li><p>@param localKey</p>
</li>
<li><p>@param requestId  请求表示</p>
</li>
<li><p>@param expireTime 超时时间</p>
</li>
<li><p>@return<br>*/<br>public static boolean tryGetDistributedLock(Jedis jedis,String localKey,String requestId,int expireTime){<br> return LOCK_SUCCESS.equalsIgnoreCase(jedis.set(localKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime));<br>}</p>
<hr>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>释放锁 </p>
<hr>
<p> /**</p>
<ul>
<li><p>释放锁</p>
</li>
<li><p>requestId : 请求标识</p>
</li>
<li><p>@param jedis</p>
</li>
<li><p>@param localKey</p>
</li>
<li><p>@param requestId</p>
</li>
<li><p>@return<br>*</p>
</li>
<li><p>不能直接使用 jedis.del(lockKey) 来删除锁,可能当前进来的锁并不是 先前判断出锁的拥有者<br>*<br>*/<br>public static boolean releaseDistributedLock(Jedis jedis,String localKey,String requestId){<br> String script = “if redis.call(‘get’, KEYS[1]) == ARGV[1] then return redis.call(‘del’, KEYS[1]) else return 0 end”;<br> Object result = jedis.eval(script, Collections.singletonList(localKey), Collections.singletonList(requestId));<br> return RELEASE_SUCCESS.equals(result);</p>
<p>}</p>
<hr>
</li>
</ul>
</li>
</ul>
<ul>
<li>如果Redis的Key需要设置同一时期过去,key是很多的话,redis可能会出现短暂的卡顿现象.</li>
</ul>
<hr>
<h3 id="Redis-获取-Key-技巧"><a href="#Redis-获取-Key-技巧" class="headerlink" title="Redis 获取 Key 技巧"></a>Redis 获取 Key 技巧</h3><p>抛出问题 :   <strong>加入Redis 里面有 一亿个Key,其中有10w个key是以某个固定的的已知前缀开头,如何将它们全部找出来?</strong></p>
<p>使用keys指令可以扫出指定模式的key列表。 X </p>
<p>使用scan指令来获取key列表。  Y</p>
<p>这个时候你要回答redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。</p>
<hr>
<h3 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h3><p>​         默认情况下, Redis 将内存数据库快照保存到dump.rdb二进制文件中. </p>
<ul>
<li><p>RDB :  配置文件 save 60 1000 . 除了在配置文件中使用save,还可以手动执行save来生成RDB快照文件.save 是同步命令,bgsave是异步命令, bgsave 会从 redis 主进程fork出一个子进程来专门生成rdb二进制文件</p>
<blockquote>
<p>127.0.0.1:6379[1]&gt; save<br>OK        </p>
</blockquote>
</li>
<li><p>AOF : 配置文件中 appendonly : yes 修改为yes.</p>
<blockquote>
<p>appendfsync  always: 每次有新命令追加到aof文件中就执行一个持久化指令,非常慢但是安全</p>
<p>appendfsync  everysec : 每次执行一次持久化,足够快(和使用rdb持久化差不多) 并且故障时只丢失1s的数据</p>
<p>appendfsync no : 从不持久化</p>
</blockquote>
</li>
</ul>
<hr>
<h3 id="Pipeline-学习"><a href="#Pipeline-学习" class="headerlink" title="Pipeline 学习"></a>Pipeline 学习</h3><p>​      pipeline 可以将多次 IO 往返的时间缩减为一次,前提是pipeline执行的指令之间没有因果关系.</p>
<hr>
<p>package com.yang.basicjavacache.redis.test;</p>
<p>import redis.clients.jedis.Jedis;<br>import redis.clients.jedis.Pipeline;</p>
<p>import java.util.HashMap;<br>import java.util.Map;</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>*<PRE><br>*</p>
<ul>
<li>File Name       : </li>
<li></li>
<li>Creation Date   : 20-4-19</li>
<li></li>
<li>Author          : Gavin</li>
<li></li>
<li>Purpose         : </li>
<li></li>
<li>History         : </li>
<li></li>
<li></PRE></li>
<li><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</li>
</ul>
<p>public class PipelineTestMain {</p>
<pre><code>public static void main(String[] args) {

    Jedis redis = new Jedis(&quot;192.168.18.141&quot;, 6379);
    redis.auth(&quot;123456&quot;);
    Map&lt;String, String&gt; data = new HashMap&lt;String, String&gt;();
    redis.select(8);
    redis.flushDB();
    long start = System.currentTimeMillis();
    for (int i = 0; i &lt; 1000000; i++) {
        data.clear();
        data.put(&quot;k_&quot; + i, &quot;v_&quot; + i);
        redis.hmset(&quot;key_&quot; + i, data);
    }
    long end = System.currentTimeMillis();
    System.out.println(&quot;    共插入:[&quot; + redis.dbSize() + &quot;]条 .. &quot;);
    System.out.println(&quot;1,未使用PIPE批量设值耗时&quot; + (end - start) / 1000 + &quot;秒..&quot;);

    redis.select(8);
    redis.flushDB();
    Pipeline pipe = redis.pipelined();
    start = System.currentTimeMillis();
    for (int i = 0; i &lt; 1000000; i++) {
        data.clear();
        data.put(&quot;k_&quot; + i, &quot;v_&quot; + i);
        pipe.hmset(&quot;key_&quot; + i, data); //将值封装到PIPE对象，此时并未执行，还停留在客户端
    }
    pipe.sync();
    end = System.currentTimeMillis();
    System.out.println(&quot;    PIPE共插入:[&quot; + redis.dbSize() + &quot;]条 .. &quot;);
    System.out.println(&quot;2,使用PIPE批量设值耗时&quot; + (end - start) / 1000 + &quot;秒 ..&quot;);
}</code></pre><p>}</p>
<blockquote>
<p>   共插入:[1000000]条 ..<br>1,未使用PIPE批量设值耗时14秒..<br>   PIPE共插入:[1000000]条 ..<br>2,使用PIPE批量设值耗时1秒 ..</p>
<p>从执行的结果来看的，这中间的时间差别还是很大的.</p>
</blockquote>
<p>Pipeline 管道技术,指的是客户端可以发送多个请求到服务端,过程中不需要等待请求的回复,在最后一次并读结果即可.</p>
<hr>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>ReentrantLock源码阅读</title>
    <url>/2020/06/20/java_juc/ReentrantLock_source/</url>
    <content><![CDATA[<h2 id="ReentrantLock-源码阅读"><a href="#ReentrantLock-源码阅读" class="headerlink" title="ReentrantLock 源码阅读"></a>ReentrantLock 源码阅读</h2><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>​        ReetrantLock 效果是和 synchronized 是一样的,只不过 synchronized 是内置锁,ReetrantLock是语法级别的锁, 相对于而言是比synchronized灵活性高些. 不过从我目前公司写代码角度来看,都是直接使用 synchronized . 但是不妨碍我们来看 ReetrantLock 里面的代码实现.</p>
<p>​    使用代码 : 有lock方法就一定要有 unlock方法来释放锁.  一般代码中这样写即可.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockCaseMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockUseCase</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"执行业务代码逻辑"</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h4><p>​      ReetrantLock 中是没有什么全局参数,相比于集合,就没有那么多全局参数.但是我们要看其里面的内,这里有三个类,  Sync , NonfairSync , FairSync.     NonfairSync和FairSync 都是有继承 Sync. 可以看到NonfairSync 是非公平锁 , FairSync是公平锁.</p>
<p>​      Sync 又集成 AQS, 使用独占锁,  重写了 tryRelease 方法. </p>
<ul>
<li><p>构造函数:  默认是使用的非公平锁,如果传入进来的是true就会使用公平锁,否则就会使用非公平锁.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125;.</span></span><br><span class="line"><span class="comment"> * This is equivalent to using &#123;<span class="doctag">@code</span> ReentrantLock(false)&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125; with the</span></span><br><span class="line"><span class="comment"> * given fairness policy.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fair &#123;<span class="doctag">@code</span> true&#125; if this lock should use a fair ordering policy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>lock 方法:  lock方法是加锁的方法</p>
<p>lock方法是调用的 Sync 的lock方法, 然后我们可以看到上锁的时候,走的Sync,然后根据FairSync/NonfairSync取走各自的加锁方法,所以说公平锁和非公平锁是加锁的方式是不一样的.</p>
</li>
</ul>
<p>  非公平锁获取锁的时候,会获取state这个状态标识,然后再去走对应的逻辑,这里多了比非公平锁多了一个从队列中获取信息和不能获取锁的线程就会被挂起进入队列中排队.</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;    sync.lock();&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sync </span></span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 公平锁</span></span><br><span class="line"><span class="comment">     * Sync object for fair locks</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">tatic <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">/* </span></span><br><span class="line"><span class="comment">    	acquire(1) 调用到AQS中,最后还是调用到下面的tryAcquire方法.</span></span><br><span class="line"><span class="comment">    	那些没有获取到锁的线程,就会按照队列的方式排队,满足先进先出的效果的,也就是先来的线程先执行,</span></span><br><span class="line"><span class="comment">    	果然这就很公平</span></span><br><span class="line"><span class="comment">    	**/</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Fair version of tryAcquire.  Don't grant access unless</span></span><br><span class="line"><span class="comment">         * recursive call or no waiters or is first.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                	hasQueuedPredecessors() 方法,先判断头结点和尾结点是不相等的,因为相等的话,就重复了,就是同一个. 然后在判断头结点的 thread是不是当前线程,如果不是当前的前程的话,那么就是在这个线程钱面还有一个等待获取锁时间更久的线程,于是就先抛弃这个线程,去执行那个等待更久的线程.</span></span><br><span class="line"><span class="comment">                	</span></span><br><span class="line"><span class="comment">                	compareAndSetState 就是用cas来获取锁的代码,如果获取成功的话,就会走setExclusiveOwnerThread方法,这里set进去的值是在释放锁的时候会用到.</span></span><br><span class="line"><span class="comment">                	最后返回true,说明获取锁成功了.</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            	获取从setExclusiveOwnerThread里面的thread,来判断是否与当前线程相等,如果相等的话,就说明重入了.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;之前</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">        <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">        <span class="comment">// thread is first in queue.</span></span><br><span class="line">        Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        Node s;</span><br><span class="line">        <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">            ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	非公平锁:</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class="line"><span class="comment">         * acquire on failure.</span></span><br><span class="line"><span class="comment">         可以看到非公平锁是没有从队列中获取说明结点信息,而是直接获取锁的.</span></span><br><span class="line"><span class="comment">         获取成功了就会走 setExclusiveOwnerThread 方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	Sync类中</span></span><br><span class="line"><span class="comment">	这段代码的逻辑也是和 公平锁后来的处理一样的了. c如果是0的话,就会走获取锁的代码,如果不是0的话,就说明重入了,所以就++</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>  unlock方法:   unlock是释放锁的方法. 可以看到释放锁是走的 Sync的release方法,所以不管公平锁还是非公平锁起走的释放锁方法是不一样的.</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;    sync.release(<span class="number">1</span>);&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	Sync 中方法. </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// tryRelease()方法返回true的话,就说明锁都释放完了.</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="comment">// 恢复线程</span></span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">            <span class="comment">// 如果当前线程不是自己的话,就会抛出异常.这里可以理解为,独占锁,肯定是自己.</span></span><br><span class="line">            <span class="comment">// 也就是说,如果不是独占锁的话,就会抛出异常.</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 如果你调用了一次lock的话,那么会加一,所以这个地方要等这个lock方法全部被释放掉.</span></span><br><span class="line">    		<span class="comment">// 也就是由于重入锁的原因.</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                free = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 释放完了,就设置了null.  </span></span><br><span class="line">                <span class="comment">// 然后AbstractOwnableSynchronizer中的thread标记也就是null,</span></span><br><span class="line">                <span class="comment">// 所以下个线程判断是null的话,就可以获取到执行权,也就是获取到锁.</span></span><br><span class="line">                setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            setState(c);</span><br><span class="line">            <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​         </p>
<ul>
<li><p>​    isLocked () 方法, 判断这个线程是不是被锁了:</p>
<p>​    调用Sync中isLock方法,如果不是0的话,就说明是被锁了,如果是0的话,就说明没有被锁.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Queries if this lock is held by any thread. This method is</span></span><br><span class="line"><span class="comment">     * designed for use in monitoring of the system state,</span></span><br><span class="line"><span class="comment">     * not for synchronization control.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if any thread holds this lock and</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> false&#125; otherwise</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.isLocked();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"> <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>  hasQueuedThreads()  :  是否有线程在等待队列中</p>
<p>  hasQueuedThread(Thread thread) :  线程是否在等待队列中</p>
<p>  getQueueLength() :  获取队列中线程个数</p>
<p>  等这些方法都是比较好理解的,可以自行点进去仔细看下.  </p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><pre><code> Sync  /  NonfairSync  /  FairSync  这个三个类就是 ReetrantLock中的三个类,都是围绕这这三个类在做文章.

公平锁和非公平锁的获取锁方式不一样,但是释放方式是一样的. 公平锁获取锁的时候,如果有线程持有了的话,那么其他的会被挂起并且进入等待队列. 而非公平锁,直接获取锁,就是抢占式.</code></pre>]]></content>
      <categories>
        <category>ReentrantLock</category>
      </categories>
      <tags>
        <tag>java源码</tag>
        <tag>Java锁</tag>
      </tags>
  </entry>
  <entry>
    <title>ArrayDeque 源码阅读记录</title>
    <url>/2020/04/30/java_list/ArrayDeque_Source/</url>
    <content><![CDATA[<p>ArrayDeque 在我目前做的项目中,使用是比较少的,基本都没有地方用到。可能是我太low了,也可能是业务没有一定要用到队列的情况. 但是这不影响我们对其进行源码阅读。</p>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p> 结构还是可以看到, 使用一个Object的数组, 二个int类型的变量来记录头和尾(从单词的意思)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">transient Object[] elements; &#x2F;&#x2F; non-private to simplify nested class access</span><br><span class="line"></span><br><span class="line">transient int head;</span><br><span class="line"></span><br><span class="line">transient int tail;</span><br></pre></td></tr></table></figure>



<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li><p>构造函数</p>
<p>无参构造函数. 可以看到无参构造函数,默认是对数据进行初始化大小为16的操作.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ArrayDeque() &#123;</span><br><span class="line">    elements &#x3D; new Object[16];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    </p>
<p>有参构造函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**传递int类型的构造函数,最后是调用到了calculateSize方法返回值来初始化数组大小 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayDeque</span><span class="params">(<span class="keyword">int</span> numElements)</span> </span>&#123;</span><br><span class="line">    allocateElements(numElements);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">allocateElements</span><span class="params">(<span class="keyword">int</span> numElements)</span> </span>&#123;</span><br><span class="line">        elements = <span class="keyword">new</span> Object[calculateSize(numElements)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 获取变量MIN_INITIAL_CAPACITY的值,如果传入进来的值是大于这个值,就会进行下面的运算操作,然后返回这个值出去.   */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateSize</span><span class="params">(<span class="keyword">int</span> numElements)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> initialCapacity = MIN_INITIAL_CAPACITY;</span><br><span class="line">        <span class="comment">// Find the best power of two to hold elements.</span></span><br><span class="line">        <span class="comment">// Tests "&lt;=" because arrays aren't kept full.</span></span><br><span class="line">        <span class="keyword">if</span> (numElements &gt;= initialCapacity) &#123;</span><br><span class="line">            initialCapacity = numElements;</span><br><span class="line">            initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">1</span>);</span><br><span class="line">            initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">2</span>);</span><br><span class="line">            initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">4</span>);</span><br><span class="line">            initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">8</span>);</span><br><span class="line">            initialCapacity |= (initialCapacity &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">            initialCapacity++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)   <span class="comment">// Too many elements, must back off</span></span><br><span class="line">                initialCapacity &gt;&gt;&gt;= <span class="number">1</span>;<span class="comment">// Good luck allocating 2 ^ 30 elements</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> initialCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   传递集合的构造函数</span></span><br><span class="line"><span class="comment">   使用传递进来的集合的长度来初始化数组的长度.</span></span><br><span class="line"><span class="comment">   然后调用addAll方法,这里说明下 addAll 是在其 AbstractCollection 里面,也就是子类调用父类的方法.然后add方法是在ArrayDeque里面调用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayDeque</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        allocateElements(c.size());</span><br><span class="line">        addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">allocateElements</span><span class="params">(<span class="keyword">int</span> numElements)</span> </span>&#123;</span><br><span class="line">        elements = <span class="keyword">new</span> Object[calculateSize(numElements)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 这里可以看到,定义给变量,迭代集合c,依次调用add方法,如果add方法返回的是true,变量modified就会变为true.最后addAll就会返回变量modified回去. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (E e : c)</span><br><span class="line">            <span class="keyword">if</span> (add(e))</span><br><span class="line">                modified = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 往下调用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        addLast(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	这里的值是不能传入null进来的,否则的话就会报NPE的异常.</span></span><br><span class="line"><span class="comment">	然后使用下标tail直接插入到最后,if 里面是对 tail 的值进行新赋值操作,如果满足条件就会调用doubleCapacity方法,目测这个方法就是进行扩容的方法.</span></span><br><span class="line"><span class="comment">	这里就是看下  (tail = (tail + 1) &amp; (elements.length - 1)) 这个赋值操作,就是给tail进行新的赋值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        elements[tail] = e;</span><br><span class="line">        <span class="keyword">if</span> ( (tail = (tail + <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)) == head)</span><br><span class="line">            doubleCapacity();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加方法</p>
<p>add(E e)  这里添加调用的方法,我们主要看下 doubleCapacity 这个方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    addLast(e);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void addLast(E e) &#123;</span><br><span class="line">        if (e &#x3D;&#x3D; null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        elements[tail] &#x3D; e;</span><br><span class="line">        if ( (tail &#x3D; (tail + 1) &amp; (elements.length - 1)) &#x3D;&#x3D; head)</span><br><span class="line">            doubleCapacity();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">	这里对 head &#x2F; elements的长度都进行值存储操作, 一 是便于后面使用System.arraycopy 来进行copy数组的值,好从对应下标开始复制值. 二是 head &#x2F;  tail 等赋值.</span><br><span class="line">	可以看到扩容后的的大小,来new了一个新的数组,后面调用System.arraycopy来进行复制.</span><br><span class="line">*&#x2F;</span><br><span class="line">private void doubleCapacity() &#123;</span><br><span class="line">        assert head &#x3D;&#x3D; tail;</span><br><span class="line">        int p &#x3D; head;</span><br><span class="line">        int n &#x3D; elements.length;</span><br><span class="line">        int r &#x3D; n - p; &#x2F;&#x2F; number of elements to the right of p</span><br><span class="line">        int newCapacity &#x3D; n &lt;&lt; 1;</span><br><span class="line">        if (newCapacity &lt; 0)</span><br><span class="line">            throw new IllegalStateException(&quot;Sorry, deque too big&quot;);</span><br><span class="line">        Object[] a &#x3D; new Object[newCapacity];</span><br><span class="line">        System.arraycopy(elements, p, a, 0, r);</span><br><span class="line">        System.arraycopy(elements, 0, a, r, p);</span><br><span class="line">        elements &#x3D; a;</span><br><span class="line">        head &#x3D; 0;</span><br><span class="line">        tail &#x3D; n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​      </p>
<p>addFirst 从头部插入 , 可以看到 使用  head = (head - 1) &amp; (elements.length - 1) 是计算出头部下标的位置,并且对值进行覆盖. 如果 head 与 tail 是相等的话,就会调用 doubleCapacity来进行扩容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    elements[head = (head - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)] = e;</span><br><span class="line">    <span class="keyword">if</span> (head == tail)</span><br><span class="line">        doubleCapacity();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>  addLast 尾部插入, 这个方法上面都是有提到的。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void addLast(E e) &#123;</span><br><span class="line">    if (e &#x3D;&#x3D; null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    elements[tail] &#x3D; e;</span><br><span class="line">    if ( (tail &#x3D; (tail + 1) &amp; (elements.length - 1)) &#x3D;&#x3D; head)</span><br><span class="line">        doubleCapacity();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​      </p>
<pre><code>offerLast / offerFirst  内部都是分别调用到了 addLast / addFirst 方法</code></pre><p>​          push 方法也是调用的 addFirst 方法</p>
<ul>
<li><p>get 获取值方法</p>
<p>​    getFirst / getLast 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 从head对应的数组中直接获取出值,如果值是null的话,就会抛出一个异常,否则就会返回*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    E result = (E) elements[head];</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	(tail - 1) &amp; (elements.length - 1) 得出尾部元素的下标位置,然后用数组下标返回对应的值.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        E result = (E) elements[(tail - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)];</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>  peekFirst / peekLast 中的操作,是与 getFirst / getLast 是一样的    </p>
<p>  peek 方法里面是走的 peekFirst 方法  </p>
<ul>
<li><p>remove 方法</p>
<p>removeFirst 方法, 走的是 pollFirst 方法</p>
<p>removeLast 方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public E removeFirst() &#123;</span><br><span class="line">    E x &#x3D; pollFirst();</span><br><span class="line">    if (x &#x3D;&#x3D; null)</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 头节点 head 使用变量 h 来记录, 直接elements[h]下标来获取值,如果值是null的话,就执行返回(这里直接返回的逻辑处理是,初始化一个集合,但是没任何值,就调用removeFirst方法,这个时候数组里面是没有值的,于是就直接返回即可).</span><br><span class="line"> 如果不是null的话,就会走下面的,将h的下标值设置为null,也就是进行删除,然后重新计算出 head 的值.</span><br><span class="line">*&#x2F;</span><br><span class="line">public E pollFirst() &#123;</span><br><span class="line">        int h &#x3D; head;</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        E result &#x3D; (E) elements[h];</span><br><span class="line">        &#x2F;&#x2F; Element is null if deque empty</span><br><span class="line">        if (result &#x3D;&#x3D; null)</span><br><span class="line">            return null;</span><br><span class="line">        elements[h] &#x3D; null;     &#x2F;&#x2F; Must null out slot</span><br><span class="line">        head &#x3D; (h + 1) &amp; (elements.length - 1);</span><br><span class="line">        return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public E removeLast() &#123;</span><br><span class="line">        E x &#x3D; pollLast();</span><br><span class="line">        if (x &#x3D;&#x3D; null)</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">        return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">	先计算出尾节点的下标,然后用值result来进行记录.如果是null的话,就直接方法(这里想法和上面一样).将t的下标的值重置为null进行删除,然后tail的值就是等t的值.</span><br><span class="line">*&#x2F;</span><br><span class="line">public E pollLast() &#123;</span><br><span class="line">        int t &#x3D; (tail - 1) &amp; (elements.length - 1);</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        E result &#x3D; (E) elements[t];</span><br><span class="line">        if (result &#x3D;&#x3D; null)</span><br><span class="line">            return null;</span><br><span class="line">        elements[t] &#x3D; null;</span><br><span class="line">        tail &#x3D; t;</span><br><span class="line">        return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>   remove 方法是直接调用的 removeFirst 方法.</p>
<ul>
<li>removeFirstOccurrence   /   removeLastOccurrence  TODO 后续更新</li>
</ul>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>  ArrayDeque 队列， 队列的特性就是对数据是先进先出。 而栈的特性是先进后出(比如枪打出去的子弹).</p>
<p>  这里的理解就是, 使用二个变量，然后每次进行 add / get / remove  都是利用这二个变量来进行 添加 / 删除 / 获取等操作.    </p>
]]></content>
      <categories>
        <category>Java集合源码</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>ArrayDeque</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap 源码阅读记录</title>
    <url>/2020/05/22/java_list/HashMap_Source/</url>
    <content><![CDATA[<p>HashMap 这种Key,Value 的存储结构,是我们在写代码中经常使用到的.可以说使用是非常频繁的,不过现在使用JSONObject也是非常多的,二者都是实现了Map接口。</p>
<p>所以看下HashMap源码是非常有必要的.</p>
<hr>
<h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p> 这里我们要看下 HashMap的内部类.</p>
<p> 这里的 Node 节点就是 HashMap存放数据的结构. hash 计算出来的哈希值,key就是HashMap中的key,value就是key对应的value的值.  这个 next 就是 key 不一样,计算出来的hash却是一样的,这样就有了hash冲突,所以就将节点存放在next里面了,从尾部插入进去. java8 后,如果next的长度是大于8的话,就会转化了红黑树来存储,那样获取值的速度变快了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>TreeNode 这个内部类就是表示红黑树的. TODO 后续进行更新.</p>
<p>参数, 可以看到 HashMap 是使用了一个数组来进行存储 Node节点.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>​    构造函数</p>
<p>​    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity</span></span><br><span class="line"><span class="comment"> * (16) and the default load factor (0.75).</span></span><br><span class="line"><span class="comment"> 	当使用无参构造函数的时候,只是对 loadFactor 进行了赋值操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传递一个int类型的参数时候,就会计息往下调用构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	对值进行判断,怕你可能传入进来一个负数来测试玩玩哈哈哈。</span></span><br><span class="line"><span class="comment">	最后调用到了tableSizeFor方法,可以看到这个方法是对传入进来的参数,进行一连串的位运算.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">        <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入 Map 的实现类的话,就是往下继续调用 putMapEntries方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">        putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	传入 m.size()的长度,长度大于0就会走逻辑代码.最后可以看到 迭代了m,然后调用putVal来将值放入Map中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = m.size();</span><br><span class="line">        <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">                <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">                <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                         (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">                <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                    threshold = tableSizeFor(t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">                resize();</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">                K key = e.getKey();</span><br><span class="line">                V value = e.getValue();</span><br><span class="line">                putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>put 添加方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据传入进来的key来计算对应的hash值</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	putVal 就是 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义一些变量</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    	<span class="comment">// table 赋值给 tab 并判断是否等于null 或者 tab的长度是否等于0,如果是的话，就会调用resize来进行扩容</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	扩容方法</span></span><br><span class="line"><span class="comment">	table使用 oldTab来进行存储,拿出oldTab的长度(如果oldTab是null的话,对应的长度就是为0).</span></span><br><span class="line"><span class="comment">	oldThr 是 记录 threshold 之前的值, newCap / newThr就是需要扩容使用到的变量命名.</span></span><br><span class="line"><span class="comment">	这里分为 </span></span><br><span class="line"><span class="comment">	1 : oldCap 是大于0的。 如果比 MAXIMUM_CAPACITY 还是要大的话,就说明里面存储的元素是太多了,就直接返回oldTab.  还有一种就是 newCap等于oldCap的1.5倍并且小于MAXIMUM_CAPACITY和oldCap是大于默认16的,就会进行1.5倍的扩容</span></span><br><span class="line"><span class="comment">	2 : oldThr 大于 0, newCap(扩容新长度) 就是等于 oldThe的值.</span></span><br><span class="line"><span class="comment">	3 : 否则就是都使用默认的值大小</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr;</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">/**</span></span><br><span class="line"><span class="comment">    	使用扩容后的newCap来创建一个数组,oldTab不是null,然后就需要将老的值赋值到新的newTab里面来.</span></span><br><span class="line"><span class="comment">        使用下标来进行迭代,获取每个下标的Node节点的值,然oldTab[j]赋值给e后,然后将oldTab[j]重置为null.</span></span><br><span class="line"><span class="comment">        这里面的进行Node复制是有分为下面几种, Node的next节点是没有值得,next下面是由值,e节点转化为了红黑树.</span></span><br><span class="line"><span class="comment">        1 : 如果e.next是null,也就是没有值,newTab[e.hash &amp; (newCap - 1)] = e来赋值.</span></span><br><span class="line"><span class="comment">        2 : 如果e是TreeNode的话,就会调用((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap)方法.</span></span><br><span class="line"><span class="comment">        3 : 然后可以看到 do while 循环里面, while 里面的条件是 e.next != null 才会进去,也就是next是由值得情况下才会进入到这里面来.然后可以看到一些系取节点啊,赋值给变量啊,然后赋值给新创建的Node数组下标然后将之前的node节点重置为null。 这里就需要读者对这些代码来慢慢消化了.仔细想看,就是对node节点的取值,赋值,重置等操作.</span></span><br><span class="line"><span class="comment">    	*/</span></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>get 方法,是通过key来获取出对应的value.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入key来计算出哈希值</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	如果 table不是Null,并且长度是大于0的,能够根据 (n-1) &amp; hash 得出来的下标是在tab里面能获取到值得,才会进入逻辑代码,否则就是返回null.</span></span><br><span class="line"><span class="comment">	如果first的hash是于传入进来的hash相同,斌且给key的值也是相同的话,就会返回first节点.</span></span><br><span class="line"><span class="comment">	拿node的next节点,如果是TreeNode的类,就会走TreeNode对应的getTreeNode方法(链表的长度大于8就会转化为红黑树). 否则的话就就迭代这个Node,退出的条件就是 e.next == null,就说说明下面没有对应的节点了。</span></span><br><span class="line"><span class="comment">	这里拿值得逻辑,还是比较容易理解得。 先根据计算出来得hash值,去数组中是否可以获取到对应得值,如果有就先会对first进行判断,是否满足条件.如果不满足的话,就说明这个key的hash是由冲突的,也就是由二个不同的值,计算出来相同的hash值,这个时候就会用链表(Node)来进行存储,如果长度是大于8的话,就会转化为TreeNode的红黑树.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">                ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">return</span> first;</span><br><span class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">return</span> e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>isEmpty 方法,这里就直接使用 size == 0 来进行判断,如果你的map是null的话,直接调用这个方法就会出现空指针.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​    这里只是选用了 put  和 get方法来进行讲解,因为这二个是经常调用的,所以得明白是一个怎么样得大体流程走向才行.</p>
]]></content>
      <categories>
        <category>Java集合源码</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>ArrayList 源码阅读记录</title>
    <url>/2020/05/06/java_list/ArrayList_Source/</url>
    <content><![CDATA[<p>ArrayList 是代码中使用非常频繁的,所以看底层的代码时非常有必须的.</p>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>​     ArrayList  是一个由 Object []  的数组来实现的</p>
<p>​     transient Object[] elementData ,这个变量就是存放数据的.</p>
<p>​     长度是用 int size 这个变量来记录的,而不是直接调用的 数组的长度获取的.</p>
<p>​     </p>
<p>​     如果ArrayList list = new ArrayList();   只是仅仅new一个集合的话,数组的大小是没有初始化为10的,而是在add()中,进行判断。 如果数组的是为空的数组的话,就会使用 <strong>DEFAULT_CAPACITY</strong> 来进行初始化。也就是要调用add方法才行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">    <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li><p>先来介绍add()方法 , 上代码</p>
<p>add  里面是走了三个方法, size 没有赋值的情况下,就是0.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确认容量 , 打个比方我们没有对size进行赋值,那么size + 1 传入到这个里面的值也就是1,那么 elementData 对应的也就是一个空数组</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">     ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  满足是空数组的话,就会使用默认的值 10 于 minCapcacity 来进行对比,这里返回的10</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  如果 minCapacity  减去 数组的长度是大于0的,就会调用grow来进行扩容</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            grow(minCapacity);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里可以看到先对数组的值进行,然后对保存出来的值进行1.5倍扩容,与传入进来的值进行对比,满足条件赋值.这里就要看到 Arrays.copyOf(elementDate,newCapacity); 这才是真正的对数组进行扩容的方法,也就是直接调用Arrays的API. Arrays.copyOf() 里面最后也是调用了 System.arraycopy()的方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">到这里 ensureCapacityInternal 方法也就是走完了</span><br><span class="line">---------------------------------------------</span><br><span class="line">后面就是使用 数组下标来进行赋值并且返回<span class="keyword">true</span>。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>​        </p>
<p>​               </p>
<ul>
<li><p>根据下标来添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + 1);  &#x2F;&#x2F; Increments modCount!!</span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + 1,</span><br><span class="line">                     size - index);</span><br><span class="line">    elementData[index] &#x3D; element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 检查下标是否越界 , ensureCapacityInternal 方法和上面一样</span><br><span class="line">private void rangeCheckForAdd(int index) &#123;</span><br><span class="line">        if (index &gt; size || index &lt; 0)</span><br><span class="line">            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;  System.arraycopy() 从 elementDate 的 index处开始复制, 复制给后面的elementDate数组的值,从index + 1 开始复制,也就是说 index 相当于修改了 index + 1, 然后index位置就是没有值了,所以elementDate[index] &#x3D; element的值,size ++.</span><br></pre></td></tr></table></figure>
</li>
<li><p>set方法 : 也就是根据下标来对久的值进行一种替换,取出对应下标的值,然后下标对应的位置赋值给新值,最后返回旧值回去即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 先检查下标是否越界,如果越界就会抛出异常</span><br><span class="line">public E set(int index, E element) &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    E oldValue &#x3D; elementData(index);</span><br><span class="line">    elementData[index] &#x3D; element;</span><br><span class="line">    return oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 取出对应下标的值</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    E elementData(int index) &#123;</span><br><span class="line">        return (E) elementData[index];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>remove </p>
<p>根据传入进来的值进行删除,</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分为 null 和 不是 null 的情况来进行删除.满足条件的话,最后都会调用到 fastRemove方法中来</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  根据传入进来的 下标来删除数据,System.arraycopy 这个方法并不默认,根据下标的位置来进行复制数组。</span></span><br><span class="line"><span class="comment">//  可以看到最后有一个 将值设置为null的操作,从注释上看是help GC, 帮助GC</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据下标删除</p>
<p>  可以看到根据下标删除的话，会先判断传入进来的下标是否满足条件,就是没有出现越界的情况.</p>
<p>  然后取出旧值,接下来的代码就是非常的熟悉了,就是fastRemove() 里面的代码了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public E remove(int index) &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">  </span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue &#x3D; elementData(index);</span><br><span class="line">  </span><br><span class="line">    int numMoved &#x3D; size - index - 1;</span><br><span class="line">    if (numMoved &gt; 0)</span><br><span class="line">        System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] &#x3D; null; &#x2F;&#x2F; clear to let GC do its work</span><br><span class="line">  </span><br><span class="line">    return oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>   大致就是看 ArrayList 是如何添加数据的,对数据是怎么保存的,是如何删除数据的,是怎么样进行扩容的,大致弄明白这些就是对ArrayList有一个大致的了解</p>
]]></content>
      <categories>
        <category>Java集合源码</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title>Vector 源码阅读记录</title>
    <url>/2020/04/29/java_list/Vector/</url>
    <content><![CDATA[<p>Vector 的结构和对数据的添加和删除 与 <a href="https://github.com/baoyang23/source-notes/blob/master/java/jvm_aggregate/ArrayList_Source.md" target="_blank" rel="noopener">ArrayList</a> 是非常相似的. 可以点进去看看.</p>
<p>具体的执行逻辑代码还是非常相似的. </p>
<p>Vector 比起 ArrayList 是线程安全的原因是, Vector 在一些方法上是使用了 synchronized 来进行加锁,从而保证了线程安全问题。</p>
]]></content>
      <categories>
        <category>Java集合源码</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Vector</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadLocal源码阅读</title>
    <url>/2020/06/20/java_juc/ThreadLocal_source/</url>
    <content><![CDATA[<h2 id="ThreadLocal源码阅读"><a href="#ThreadLocal源码阅读" class="headerlink" title="ThreadLocal源码阅读"></a>ThreadLocal源码阅读</h2><p>ThreadLocal 是来这个公司有过使用一次的感受,所以就学习阅读下源码。  其实Thread 这个里面,就有一个 Map(这里是用ThreadLocal内部类中实现的) , 里面的key就是 ThreadLocal, value 就是存储的值,所以一个Thread是有多个 ThreadLocal。 </p>
<hr>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>  参数部分</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The next hash code to be given out. Updated atomically. Starts at</span></span><br><span class="line"><span class="comment"> * zero.</span></span><br><span class="line"><span class="comment">   AtomicInteger 是一个线程安全的,实现原理是采用了cas.	</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode =</span><br><span class="line">    <span class="keyword">new</span> AtomicInteger();</span><br></pre></td></tr></table></figure>



<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p> set 赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*	首先获取当前线程.</span></span><br><span class="line"><span class="comment">	调用 getMap 方法, 直接调用 t.trheadLocals来获取 ThreadLocalMap。(ThreadLocalMap这里是ThreadLocal内部自己实现的类)</span></span><br><span class="line"><span class="comment">	如果map不是null的话,就进行set值,这里可以看到 set 的key是this,也就是ThreadLocal它自己.</span></span><br><span class="line"><span class="comment">	否则就是调用createMap方法,走这个方法是可以确认 currentThread中的threadLocals的值是null,所以直接new了一个进行赋值即可.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Get-方法"><a href="#Get-方法" class="headerlink" title="Get 方法"></a>Get 方法</h4><p> get 方法,获取值.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	这里可以看到,获取ThreadLocalMap,如果ThreadLocalMap的是null的话,就会走setInitialValue方法。</span></span><br><span class="line"><span class="comment">	如果有值的话,就会进行获取值并且返回.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	如果获取出来的ThreadLocalMap 不是null的话,就会进行set,这个时候set进去的值,value就是null了.</span></span><br><span class="line"><span class="comment">	如果获取出来是nulld</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T value = initialValue();</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="remove-方法"><a href="#remove-方法" class="headerlink" title="remove 方法"></a>remove 方法</h4><p>remove 方法就是获取map,如果map不是null的话,就调用m.remove(this)，根据当前this来删除.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">        m.remove(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p> ThreadLocal里面的方法也比较少,还是比较好理解的。只要弄清楚ThreadLocal和Thread是怎么在存储的,就很好的理解了。</p>
<p>注意 : 使用ThreadLocal一定要进行remove,否则容易出现内存泄漏，从而导致内存溢出。</p>
]]></content>
      <categories>
        <category>ThreadLocal</category>
      </categories>
      <tags>
        <tag>java源码</tag>
        <tag>Java锁</tag>
      </tags>
  </entry>
  <entry>
    <title>PriorityQueue源码阅读记录</title>
    <url>/2020/05/12/java_list/PriorityQueue_source/</url>
    <content><![CDATA[<p>​      PriorityQueue :  中文是优先队列 , 队列的特点就是数据 先进先出,   但是这个优先队列的特别是什么呢？ 首先肯定是有队列的基本特点，也就是有先进先出。  如果是先进先出的话,那么就和普通的有什么区别？优先二字又是体现在什么地方呢？  优先级队列的元素按照其自然顺序进行排序, 或者根据 构造队列时提供的 Comparator 进行排序.</p>
<hr>
<h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p>​    结构就是 PriorityQueue这个类的 全局变量参数, 因为这些参数是存储数据的, 所以只要理解了这些参数,就明白了这个 PriorityQueue这个是对数据是怎么样进行存储的, 还是比较好理解的. </p>
<p> 这里可以看到 priorityQueue的数据结构还是很简单的, 一眼扫过去没什么需要特别的理解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 存储数据的数组</span></span><br><span class="line"><span class="keyword">transient</span> Object[] queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录 priorityQueue的长度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个就是之前说提到的  可以根据 Comparator 进行排序</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>​    priorityQueue的构造方法相对于其他的集合的构造方法可能是比较多的.</p>
<p>​     </p>
<p>​    这里列举出来, 可以看到构造方法还是比较多的.</p>
<p>​    对构造函数的初始化赋值等操作还是很好理解的,并没有什么特别难理解的。  主要还是对数组/长度/或者传入进来的数组进行赋值操作.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 1   </span></span><br><span class="line"><span class="comment">// 这里是走到 4 的构造方法去了</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 这里是走到 4 的构造方法去了</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 这里是走到 4 的构造方法去了</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, comparator);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4 </span></span><br><span class="line"><span class="comment">/**  可以看到前面的三个都是走到了这里来了,</span></span><br><span class="line"><span class="comment">	 长度如果是小于1的话,就会报错.  </span></span><br><span class="line"><span class="comment">     this.queue 的数组长度就是 initialCapacity</span></span><br><span class="line"><span class="comment">     comparator 排序方法就是传入进来的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                         Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Note: This restriction of at least one is not actually needed,</span></span><br><span class="line">        <span class="comment">// but continues for 1.5 compatibility</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">this</span>.queue = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">        <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">/**  对传入进来的集合进行判断. 分为   SortedSet  或者  PriorityQueue  或者其他</span></span><br><span class="line"><span class="comment">     如果是 SortedSet 的话, 对 comparator 的值赋值为 传入进来集合的排序方式,然后走 initElementsFromCollection() 方法, 这里应该是对集合进行赋值操作.</span></span><br><span class="line"><span class="comment">     如果是 PriorityQueue , comparator 处理方式是和 SortedSet一样,然后走 initFromPriorityQueue 方法. </span></span><br><span class="line"><span class="comment">     否则就不上面的二种, comparator 复置为 null ,走 initFromCollection 方法.</span></span><br><span class="line"><span class="comment">     这里总结的话,就是传入进来不同的集合,走的方法也是不一样的,这个还是很好理解的.</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (c <span class="keyword">instanceof</span> SortedSet&lt;?&gt;) &#123;</span><br><span class="line">            SortedSet&lt;? extends E&gt; ss = (SortedSet&lt;? extends E&gt;) c;</span><br><span class="line">            <span class="keyword">this</span>.comparator = (Comparator&lt;? <span class="keyword">super</span> E&gt;) ss.comparator();</span><br><span class="line">            initElementsFromCollection(ss);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c <span class="keyword">instanceof</span> PriorityQueue&lt;?&gt;) &#123;</span><br><span class="line">            PriorityQueue&lt;? extends E&gt; pq = (PriorityQueue&lt;? extends E&gt;) c;</span><br><span class="line">            <span class="keyword">this</span>.comparator = (Comparator&lt;? <span class="keyword">super</span> E&gt;) pq.comparator();</span><br><span class="line">            initFromPriorityQueue(pq);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.comparator = <span class="keyword">null</span>;</span><br><span class="line">            initFromCollection(c);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6  这个对应上面的, 如果是传入进来 PriorityQueue 的处理方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(PriorityQueue&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.comparator = (Comparator&lt;? <span class="keyword">super</span> E&gt;) c.comparator();</span><br><span class="line">        initFromPriorityQueue(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7  这个也是对应上面的 SortedSet 处理方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(SortedSet&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.comparator = (Comparator&lt;? <span class="keyword">super</span> E&gt;) c.comparator();</span><br><span class="line">        initElementsFromCollection(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">----------------------   华丽分割线   --------------------</span><br><span class="line">上面的<span class="keyword">if</span> <span class="keyword">else</span> 里面提到的走不同的方法,还是有必要取看看的. </span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  对传入进来是  PriorityQueue  进行处理, 先判断确认 class是PriorityQueue ,是的话,调用toArray() 将数组赋值给 queue , 并且长度也进行复置给size.</span></span><br><span class="line"><span class="comment">  否则就走  initFromCollection 方法, 这个 if else 还是比较严谨的.进行多次判断处理</span></span><br><span class="line"><span class="comment">*/</span>    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initFromPriorityQueue</span><span class="params">(PriorityQueue&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (c.getClass() == PriorityQueue<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.queue = c.toArray();</span><br><span class="line">            <span class="keyword">this</span>.size = c.size();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            initFromCollection(c);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   这个对传入进来的集合, 将值转化为 数组a (Object []), 如果 comparator不是null的话,就会根据comparator来进行排序. 也就是对a进行排序,并且这个的值不可以为null的,如果出现了null的话,就会有空指针的异常出现.</span></span><br><span class="line"><span class="comment">   然后将数组a赋值给queue,长度也是调用 a.length 复置给size</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initElementsFromCollection</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="comment">// If c.toArray incorrectly doesn't return Object[], copy it.</span></span><br><span class="line">        <span class="keyword">if</span> (a.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            <span class="title">a</span> </span>= Arrays.copyOf(a, a.length, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">int</span> len = a.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span> || <span class="keyword">this</span>.comparator != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">                <span class="keyword">if</span> (a[i] == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.queue = a;</span><br><span class="line">        <span class="keyword">this</span>.size = a.length;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 可以看到这个方法是走了  initElementsFromCollection 这个方法, 然后再走 headify 方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initFromCollection</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        initElementsFromCollection(c);</span><br><span class="line">        heapify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>​     添加元素方法 ： </p>
<p>​      </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> offer(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	这里可以看到,如果值是null的话,就会抛出NPE的异常.</span></span><br><span class="line"><span class="comment">	如果size的大小比 queue数组的长度还大的话,就会进行扩容.</span></span><br><span class="line"><span class="comment">	然后size长度+1,如何i是0的话,就说明是第一个元素,不需要任何拍寻处理,直接赋值给第一个即可.</span></span><br><span class="line"><span class="comment">	如果不是第一个的话,就会走siftUp方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">int</span> i = size;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= queue.length)</span><br><span class="line">            grow(i + <span class="number">1</span>);</span><br><span class="line">        size = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">            queue[<span class="number">0</span>] = e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            siftUp(i, e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	如果 comparator是null的话,就走  siftUpUsingComparator 方法.</span></span><br><span class="line"><span class="comment">	否则就会走 siftUpComparable 方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">            siftUpUsingComparator(k, x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            siftUpComparable(k, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	这里先判断k是大于0的,也就是不是第一个的意思.</span></span><br><span class="line"><span class="comment">	然后通过 (k - 1) &gt;&gt;&gt; 1 计算出来下标位置,下标是parent的值,调用 comparator.compare(x,e)来进行比较,如果是大于0的话,就不需要做任何处理。</span></span><br><span class="line"><span class="comment">	否则的话,就会 queue[k] = e ; k = parent; 来进行下标数值的替换处理.</span></span><br><span class="line"><span class="comment">	最后queue[k] = x 的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUpUsingComparator</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            Object e = queue[parent];</span><br><span class="line">            <span class="keyword">if</span> (comparator.compare(x, (E) e) &gt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            queue[k] = e;</span><br><span class="line">            k = parent;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[k] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	这个方法其实也是和上面的处理方式是类似的,通过比较值来进行处理.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUpComparable</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">        Comparable&lt;? <span class="keyword">super</span> E&gt; key = (Comparable&lt;? <span class="keyword">super</span> E&gt;) x;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            Object e = queue[parent];</span><br><span class="line">            <span class="keyword">if</span> (key.compareTo((E) e) &gt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            queue[k] = e;</span><br><span class="line">            k = parent;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[k] = key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	这里顺路看下 grow 扩容方法吧。 </span></span><br><span class="line"><span class="comment">	肯定是根据 queue的长度来进行扩容,如果值太小了的话,就会进行 二倍扩容.  否则的话,就是1.5倍扩容.</span></span><br><span class="line"><span class="comment">	最后调用 Arrays.copyOf() 来进行扩容数组操作</span></span><br><span class="line"><span class="comment">	这个扩容还是想对比较简单的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> oldCapacity = queue.length;</span><br><span class="line">        <span class="comment">// Double size if small; else grow by 50%</span></span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + ((oldCapacity &lt; <span class="number">64</span>) ?</span><br><span class="line">                                         (oldCapacity + <span class="number">2</span>) :</span><br><span class="line">                                         (oldCapacity &gt;&gt; <span class="number">1</span>));</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        queue = Arrays.copyOf(queue, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>peek 方法</p>
<p>这里可以看清楚的看到，出队列方法的值,就是默认的第一个嘛，这么一眼看下去就是很清楚明了的.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (size == <span class="number">0</span>) ? <span class="keyword">null</span> : (E) queue[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>remove 方法 :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	删除元素的方法。</span></span><br><span class="line"><span class="comment">	indexOf 如果返回的不是-1的话,就说明是有值得,就会走到 removeAt 方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = indexOf(o);</span><br><span class="line">    <span class="keyword">if</span> (i == -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        removeAt(i);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	indexOf 这个方法就是判断在这个集合里面有没有 o 这个值, 如果有的话就会返回对应的下标,如果不存在的话,就会返回-1的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(queue[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	removeAt 方法就会将传入进来的i的下标的值重置为null,这是满足 i == --size 的情况下.</span></span><br><span class="line"><span class="comment">	然后会将要删除的下标 i 和 对应的值 moved 传入到 siftDown 这个方法中.</span></span><br><span class="line"><span class="comment">	siftUp()是在前面有讲解到的.</span></span><br><span class="line"><span class="comment">	这里还是很明显的看到, priorityQueue是一直在维护这排序的关系。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">removeAt</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert i &gt;= 0 &amp;&amp; i &lt; size;</span></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">int</span> s = --size;</span><br><span class="line">        <span class="keyword">if</span> (s == i) <span class="comment">// removed last element</span></span><br><span class="line">            queue[i] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            E moved = (E) queue[s];</span><br><span class="line">            queue[s] = <span class="keyword">null</span>;</span><br><span class="line">            siftDown(i, moved);</span><br><span class="line">            <span class="keyword">if</span> (queue[i] == moved) &#123;</span><br><span class="line">                siftUp(i, moved);</span><br><span class="line">                <span class="keyword">if</span> (queue[i] != moved)</span><br><span class="line">                    <span class="keyword">return</span> moved;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	根据comparator走不同的方法</span></span><br><span class="line"><span class="comment">	可以看到走的二个方法，其中的区别是 comparator.compare 和 comparator.compareTo 调用的api是不一样的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">            siftDownUsingComparator(k, x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            siftDownComparable(k, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDownUsingComparator</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">            <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            Object c = queue[child];</span><br><span class="line">            <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (right &lt; size &amp;&amp;</span><br><span class="line">                comparator.compare((E) c, (E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">                c = queue[child = right];</span><br><span class="line">            <span class="keyword">if</span> (comparator.compare(x, (E) c) &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            queue[k] = c;</span><br><span class="line">            k = child;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[k] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDownComparable</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">        Comparable&lt;? <span class="keyword">super</span> E&gt; key = (Comparable&lt;? <span class="keyword">super</span> E&gt;)x;</span><br><span class="line">        <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;        <span class="comment">// loop while a non-leaf</span></span><br><span class="line">        <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">            <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// assume left child is least</span></span><br><span class="line">            Object c = queue[child];</span><br><span class="line">            <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (right &lt; size &amp;&amp;</span><br><span class="line">                ((Comparable&lt;? <span class="keyword">super</span> E&gt;) c).compareTo((E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">                c = queue[child = right];</span><br><span class="line">            <span class="keyword">if</span> (key.compareTo((E) c) &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            queue[k] = c;</span><br><span class="line">            k = child;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[k] = key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​       PriorityQueue 的存储数据结构是采用一个数据来进行存储,也就是一直在操作这个数组，只是每次都对数据进行了维护排序的关系。</p>
<p>​        PriorityQueue  是线程不安全的队列，这里还是提一下吧,因为添加元素和删除元素的方法都是没有进行加锁处理，当然了,如果不使用作为全局变量的话，自然是没有任何问题的,在局部变量里面.</p>
<p>​        </p>
]]></content>
      <categories>
        <category>Java集合源码</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>PriorityQueue</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap源码阅读记录</title>
    <url>/2020/04/29/java_list/HashMap%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><blockquote>
<p>HashMap 是基于哈希表的Map接口.是可以使用null来做为key.不保证映射的顺序.</p>
<p>HashMap 是一种基于Key-Value的数据结构.</p>
</blockquote>
<p>​    </p>
<p><img src="" alt="[https://github.com/baoyang23/images_repository/blob/master/java/hashMap/HashMap%E7%BB%93%E6%9E%84%E5%9B%BE.png](https://github.com/baoyang23/images_repository/blob/master/java/hashMap/HashMap结构图.png)"></p>
<h3 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a>HashMap源码分析</h3><p>默认初始化容量</p>
<blockquote>
<p>static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16</p>
</blockquote>
<hr>
<p>构造函数中未指定时使用的加载因子.</p>
<blockquote>
<p>static final float DEFAULT_LOAD_FACTOR = 0.75f</p>
</blockquote>
<hr>
<p>存储数据使用的Node节点,可以理解为你Java中定义的一个类,就是这个类的next中的值,可能是下一个类似的节点，也可能是null(没有下一个指向).</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">   <span class="keyword">final</span> K key;</span><br><span class="line">   V value;</span><br><span class="line">   Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">   Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">       <span class="keyword">this</span>.hash = hash;</span><br><span class="line">       <span class="keyword">this</span>.key = key;</span><br><span class="line">       <span class="keyword">this</span>.value = value;</span><br><span class="line">       <span class="keyword">this</span>.next = next;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">       V oldValue = value;</span><br><span class="line">       value = newValue;</span><br><span class="line">       <span class="keyword">return</span> oldValue;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">           Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">           <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">               Objects.equals(value, e.getValue()))</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<hr>
<p><strong>Note: TreeNode这个内部类也是需要仔细看的。Java8中,当链表中的Node个数大于8的时候，就会转化为TreNode来进行存储Node节点.这里由于代码比较多，就不贴出来，但是对于要提升的，就要去仔细看看。</strong></p>
<hr>
<p>来看put方法，就是我们每次调用存储的方法，来看看代码层面是怎么实现。先根据key来调用hash()方法,可以看到调用hash方法后，就返回了int类型的,也就是调用hash来计算出哈希值.然后直接调用putVal方法，这才是真正的存储数据的方法.</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>注释的译文: 将指定值与此映射中的指定键相关联。如果映射先前包含键的映射，则替换旧值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> h;</span><br><span class="line">   <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>putVal 方法讲解:</strong></p>
<p>定义tab 的 Node数组, (tab = table) == null 这行代码是可以看到,全局变量的 table赋值给tab.</p>
<p>Node&lt;K,V&gt; p 的话，这里如果算出来的hash值，tab[i= ()n-1 &amp; hash] , 也就是这样代码,如果是null的话,就说明在数组tab(table)中是不存在的.反正,就说明该哈希值在数组中是已经存在的(这就是哈希冲突).</p>
<p>然后发生哈希冲突怎么办呢？</p>
<p>我们看到代码 p.hash == hash &amp;&amp; ((k = p. key) == key || (key != null &amp;&amp; key.equals(k))), 判断hash值是否相等并且二者的key的值是否相等,使用==或者equals来进行判断，如果是想相同的话,就说明 Key 已经是存在的了,覆盖掉。   </p>
<p>如果p是 TreeNode类型的话,就说明该哈希值冲突的个数已经大于8了，看到 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this,tab,hash,key,value)这行代码，点进去看就可以,这里就有之前提到的说需要看TreeNode这个类的。</p>
<p>for(int bigCount = 0;;++bigCount){} 中的代码,就是发生了put进来的key的哈希值是一样的,但是Key的值却不是一样。 e = p.next == null,如果p节点的next是Null的话,就是说明没有下一个节点,然后调用newNode来生成一个Node节点. bigCount &gt;= TREEIFY_THRESHOLD - 1 , 如果大于7的话,链表就会调用treeIfBin(tab,hash)这个方法转化为红黑树结构.</p>
<p>可以看到putVal中的方法，仔细去阅读还是比较容易理解的.</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">   Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">   <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">       n = (tab = resize()).length;</span><br><span class="line">   <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">       tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">       Node&lt;K,V&gt; e; K k;</span><br><span class="line">       <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">           ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">           e = p;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">           e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">               <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                   <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                       treeifyBin(tab, hash);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                   ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               p = e;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">           V oldValue = e.value;</span><br><span class="line">           <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">               e.value = value;</span><br><span class="line">           afterNodeAccess(e);</span><br><span class="line">           <span class="keyword">return</span> oldValue;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ++modCount;</span><br><span class="line">   <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">       resize();</span><br><span class="line">   afterNodeInsertion(evict);</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>resize() 方法讲解</strong></p>
<p>这是HashMap中进行扩容的方法.</p>
<p>int oldCap = (oldTab == null) ? 0 : oldTab.length;  拿出tab的长度,如果没有就是0(第一次初始化的时候,就是没有值1).</p>
<p>threshold 这个值,是根据你传入进来的数值,比如第一次初始化的时候，你在构造函数中传入进来的值，就会调用返回生成值并且赋值给threshold这个全局变量。</p>
<p>oldCap &gt; 0 , 看到 newThr = old &lt;&lt;&lt;1; 二倍扩容.</p>
<p>oldThr &gt; 0 , 这个 newCap = oldThr 这个值取决于threshold，目前感觉像是第一次初始化并且构造函数有传入值才是有用的.</p>
<p>否则就是使用默认的数值来进行初始化.大小确定完后,就将 newTab的值也会赋值给threshold.</p>
<p>Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</p>
<p>table = newTable;</p>
<p>for int j =0; j &lt; oldCap; ++j 中可以看出来,根据每个下标去进行迭代的，每个值有可能是 单个Node节点,也就是Node的next的值是null。 也有可能是 TreeNode类型的 。 也有可能是 Node下面的next还是有Node的。然后分别根据这三种情况,将老的数组中的值赋值给新扩容大小的数组中.</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">   Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">   <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">   <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">   <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">           threshold = Integer.MAX_VALUE;</span><br><span class="line">           <span class="keyword">return</span> oldTab;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">           newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">       newCap = oldThr;</span><br><span class="line">   <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">       newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">       newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">       newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                 (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">   &#125;</span><br><span class="line">   threshold = newThr;</span><br><span class="line">   <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">   Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">   table = newTab;</span><br><span class="line">   <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">           Node&lt;K,V&gt; e;</span><br><span class="line">           <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">               oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">               <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                   newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                   ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">               <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                   Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                   Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                   Node&lt;K,V&gt; next;</span><br><span class="line">                   <span class="keyword">do</span> &#123;</span><br><span class="line">                       next = e.next;</span><br><span class="line">                       <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                           <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                               loHead = e;</span><br><span class="line">                           <span class="keyword">else</span></span><br><span class="line">                               loTail.next = e;</span><br><span class="line">                           loTail = e;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">else</span> &#123;</span><br><span class="line">                           <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                               hiHead = e;</span><br><span class="line">                           <span class="keyword">else</span></span><br><span class="line">                               hiTail.next = e;</span><br><span class="line">                           hiTail = e;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                   <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                       newTab[j] = loHead;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                       newTab[j + oldCap] = hiHead;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> newTab;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>


</blockquote>
<p><strong>get方法讲解</strong></p>
<p>调用hash()方法，这个在pul的方法中是有提到的.我们这里主要是看getNode方法,可以看到get方法中也有tab数组(这个数组才是存储数据的). if条件,tab不为null,并且长度也是大于0的,并且根据 tab[(n-1)&amp;hash]算出来的下表在数组中的值是不为null的.先判断,hash是否相等,key对应的值是否也相等,如果是的话，直接返回first节点,first节点是在if判断条件中进行赋值了的。如果不是的话,就拿取first节点的next值,如果是TreeNode类型的话,就说明这个哈希值已经冲突8次甚至更多,然后调用TreeNode的getTreeNode()来获取节点并且返回。还有一种就是没有转化TreeNode，还是使用单链表, while(e=e.next) 可以看出来,往下继续next，就是在迭代单链表,如果满足key值相同的话,就会返回。</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123; </span><br><span class="line">   Node&lt;K,V&gt; e;</span><br><span class="line">   <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>注释译文: 返回指定键映射到的值，如果此映射不包含键的映射，则返回{@code null}。可以看到译文,如果根据Key映射到值,就返回值,如果没有映射到的话,就会返回Null.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">   Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line">   if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">       (first &#x3D; tab[(n - 1) &amp; hash]) !&#x3D; null) &#123;</span><br><span class="line">       if (first.hash &#x3D;&#x3D; hash &amp;&amp; &#x2F;&#x2F; always check first node</span><br><span class="line">           ((k &#x3D; first.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">           return first;</span><br><span class="line">       if ((e &#x3D; first.next) !&#x3D; null) &#123;</span><br><span class="line">           if (first instanceof TreeNode)</span><br><span class="line">               return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">           do &#123;</span><br><span class="line">               if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                   ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                   return e;</span><br><span class="line">           &#125; while ((e &#x3D; e.next) !&#x3D; null);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return null;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<hr>
<p><strong>containKey 方法讲解</strong></p>
<p>可以看出来判断是否包含一个key，是直接调用getNode()方法,然后根据判断是否等于null来进行返回。</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> getNode(hash(key), key) != <span class="keyword">null</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<hr>
<p>好啦,HashMap中put 和 get 理解明白即可,主要是 put 方法,这才是整个HashMap中的灵魂代码，也是必须了解的。</p>
]]></content>
      <categories>
        <category>Java源码</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>买菜&amp;跑步</title>
    <url>/2020/11/25/life/%E4%B9%B0%E8%8F%9C&amp;%E8%B7%91%E6%AD%A5/</url>
    <content><![CDATA[<h3 id="买菜"><a href="#买菜" class="headerlink" title="买菜"></a>买菜</h3><blockquote>
<p>说来也是好笑，由于今年疫情的原因，导致一个不会做饭的我，到现在也可以做出饭来了,也是奇奇怪怪的.</p>
<p>这里记录前不久,我在买菜的时候,看见一哥们在买鸡蛋的时候(这里可以买包装好了的,也可以买自己拿的,也就是一个一个的那种), 然后我看见那哥们买一个一个的,每个都拿起来摇一下,我就好奇了，他说:  <strong>摇一下,没用那种很散或者液体的流动的话,这个鸡蛋就可以放到久点.</strong></p>
</blockquote>
<h3 id="跑步"><a href="#跑步" class="headerlink" title="跑步"></a>跑步</h3><blockquote>
<p>2020-11-25 : 这是我坚持跑步的第十天，从之前的路程来看,我从第一天的2千米过渡到了 2到4这三天的三千多米，在过渡到5到7这三天的4千多米, 再到8到10这三天的5千多米.</p>
<p>从这几天跑5千米的过程来看,在过渡到第三千米的时候，是比较难坚持下去的,但是你咬咬牙，想到一些让自己很愤怒或者很去期待的事情,再就是把握好呼吸的节奏,其余的就交给自己的腿力啦.</p>
<p>跑完后,一定要拉伸下. 最初几天拉伸的时候,肯定会比较痛,我只说: 慢慢坚持下来.</p>
</blockquote>
<h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><blockquote>
<p>这段时间,因为一些事情或者个人原因,我总是很消极,具体原因也没有好说的.</p>
<p>于是,现在写这个,虽然我没有完全从那种很悲伤的情况中走出来,但是至少我不会像之前,真的是,每天都受那种情况所影响,所难受.</p>
<p>从我现在,下班回来就去跑步,然后做饭(第二天带去公司吃),然后做一组Keep，完完全全的充实了自己大晚上的时候.</p>
<p>如果晚上没时间，我还立下了那么多目标呢？</p>
<p>比如:  每周 录一个 源码的视频(手动狗头,虽然现在自己都不怎么明白hhhhh).</p>
<p>​           坚持Coding/坚持学习新技术/坚持去了解底层</p>
<p>​           坚持跑步/坚持做饭</p>
<p>​           坚持摄影(虽然现在拍出来的都是废片)</p>
<p>​           学习英语(规划)</p>
<p>​           学普通话标准.</p>
<p>​           每月看一本文学书籍(<strong>不是技术书籍,不是技术书籍,不是技术书籍</strong>.).</p>
<p>想之后:    学会游泳(等我瘦下去,一定要学花式).</p>
<p>​                 照片的后期处理</p>
<p>​                视频的剪辑和去杂音(hhhh,这个应该现在就要学习的.).</p>
</blockquote>
<p>最后,望看到这篇文章的人啊,我们一起加油,一起去期待下一个更好的自我.</p>
]]></content>
      <categories>
        <category>生活记录</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>爬山&amp;运动</title>
    <url>/2020/11/29/life/%E7%88%AC%E5%B1%B1&amp;%E8%BF%90%E5%8A%A8/</url>
    <content><![CDATA[<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="爬山"><a href="#爬山" class="headerlink" title="爬山"></a>爬山</h4><p>​    距离上次爬上大梧桐，应该是过去了一年了. 说来也是好奇,这次爬上大梧桐的道路和去年爬上大梧桐的上山之道不一样,所以我也可以很装B的说句 :  <strong>完成一样的任务或者做一样东西的时候,方式有很多种,你可以尝试很多种,找到最合适自己的(hhhhhh).</strong></p>
<blockquote>
<p>​     由于现在地铁开通了,可以直接坐地铁到梧桐山的入口,相比于之前只能坐地铁转公交，现在有了地铁,是真的方便很多呀.</p>
<p>​       路线  :   小梧桐上 —&gt; 大梧桐 — &gt; 小梧桐下.</p>
<p>​       用时  :    9:30多开始, 然后四点下.  中间还有各种休息时间等.</p>
<p>​        </p>
<p>​       总结 :   总体阔别一年再上大梧桐,内心多多少少还是有点波动的,毕竟去年一起爬上去的人,都没再约了.所以这次爬上去,是我和我表姐(职业爬山？). hhhhh. </p>
<p>​                    爬小梧桐的时候,休息到比较少,所以在爬的时候,也难免会出现衣服上都是汉的. 这也是我不晓得大约过了多久之后,再出现这种都是汉的感觉. 然后再上大梧桐的时候,这种感觉就没有这么强烈了吧.</p>
<p>​                    好汉坡还是哪个好汉坡,给人看上去第一眼的感觉就好难.其实上过一次的话,我感觉都还好. 因为你爬完好汉坡之后,其实后面还是有一小段距离的.</p>
<p>​                   最后到了山顶,人还是蛮多的. 应该来这儿打卡的人会比较居多吧.</p>
</blockquote>
<h4 id="运动"><a href="#运动" class="headerlink" title="运动"></a>运动</h4><p>​     谈到运动,就想到我从小其实也不是喜欢运动的人, 反倒是一个喜欢吃喝,能不走的路就绝不会走. 说到运动,感觉也是一种机缘巧合的情况下,导致我这次疯狂的跑步什么的呀.</p>
<p>​       </p>
<blockquote>
<p> 运动不仅仅是跑步,但是先通过坚持跑步来锻炼自己的意志力吧.  要自己可以坚持下去,在有限的时间内,一直坚持下去,最好不要做到半途而废,这样不太好.</p>
<p>希望: 能通过跑步来锻炼出自己的韧性.  后期时间就了,能添加更多的其他运动操作.</p>
<p>感受:   跑步的时候,带上耳机,尽量控制均匀呼吸,然后你就会发现,你跑到越久,到后面的呼吸可能会比较难控制什么的,要经常跑,到后面就会慢慢控制好.  跑到中途的时候,其实自己的脑子就已经放空了很多东西. 这种放空脑子的感受,还是蛮舒服的. </p>
<p><strong>跑完记得拉伸下/跑完记得拉伸下/跑完记得拉伸下</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>生活记录</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>LinkedList源码阅读记录</title>
    <url>/2020/04/29/java_list/LinkedList_Source/</url>
    <content><![CDATA[<p>虽然一般都是使用ArrayList集合比使用LinkedList集合要多,但是这并不妨碍我们对LinkedList的源码研究和学习</p>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>LinkedList 是一个双向链表的结构,这点可以直接看其内部内就可以非常明显的看出来. 静态私有的内部类,只提供一个构造函数.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然后我们看 LinkedList 自身的变量. size 肯定是记录这个链表的长度,不然到时候node.next.next….获取长度就很得不偿失了.  然后记录了一个头节点和尾节点，个人认为这是方便遍历。从头开始遍历就从first节点获取,从尾部开始遍历的话,就从last开始获取.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">transient int size &#x3D; 0;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Pointer to first node.</span><br><span class="line"> * Invariant: (first &#x3D;&#x3D; null &amp;&amp; last &#x3D;&#x3D; null) ||</span><br><span class="line"> *            (first.prev &#x3D;&#x3D; null &amp;&amp; first.item !&#x3D; null)</span><br><span class="line"> *&#x2F;</span><br><span class="line">transient Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Pointer to last node.</span><br><span class="line"> * Invariant: (first &#x3D;&#x3D; null &amp;&amp; last &#x3D;&#x3D; null) ||</span><br><span class="line"> *            (last.next &#x3D;&#x3D; null &amp;&amp; last.item !&#x3D; null)</span><br><span class="line"> *&#x2F;</span><br><span class="line">transient Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li><p>add 方法</p>
<p>add方法调用一个linkLast方法,然后就返回true了. 也就是说add(E e)就是默认从尾部开始插入元素进去.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Links e as last element.</span></span><br><span class="line"><span class="comment">       翻译 : 链接e作为最后一个元素。</span></span><br><span class="line"><span class="comment">       先对last赋值给 Node&lt;E&gt; l , 然后调用new Node&lt;&gt;(l,e,null);传入进去的上个节点,也就是l,上次保存的尾部节点,也就是从倒数第一变为了倒数二,这样理解。然后此时的newNode就是尾节点了,然后赋值给last,因为last每次记录的都是尾节点.</span></span><br><span class="line"><span class="comment">       if else 中是对之前的尾节点进行判断,如果是null的话,说明此时就是添加的第一个元素,first也赋值给newNode,否则的话,l.next 和 尾节点进行关联。</span></span><br><span class="line"><span class="comment">       size 长度加一</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">        last = newNode;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>  根据下标添加 add(int index,E  element)</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	1: 检查传入进来的下标是否越界了,如果下标越界的话,就会抛出 下标越界的异常</span></span><br><span class="line"><span class="comment">	2: 根据传入进来的下标值,判断是否和 size 相等,如果是相等的话,就说明是尾部插入,就不需要挨个迭代去获取对应的下标值对应的节点.满足条件,就会调用上面说到的 linkLast方法</span></span><br><span class="line"><span class="comment">	3: 不满足条件2的话,就会走lineBefore()方法,其中也调用到了.传入下标调用node方法.node会返回对应下标的值,根据返回的节点和当前的值调用lienkBefore方法.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkPositionIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isPositionIndex(index))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPositionIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	size &gt;&gt; 1 ; 是对 size 进行去半, 比如 6 &gt;&gt; 1 是 3， 5 &gt;&gt; 1 是2</span></span><br><span class="line"><span class="comment">	如果小于一半的话,就会从first节点开始遍历,也就是从头节点开始遍历,否则就是从尾节点开始遍历.</span></span><br><span class="line"><span class="comment">	这个方法可以看到,从头开始遍历的话,就是调用的next,如果尾部遍历的话,调用的就是prev。找到对应下标的节点并且返回回去.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">            Node&lt;E&gt; x = first;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">                x = x.next;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;E&gt; x = last;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">                x = x.prev;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	获取节点的上个节点赋值给pred，其实类似于pred这种,都是用于变量替换创建出来的.</span></span><br><span class="line"><span class="comment">	上一个节点,当前值e,succ节点来new一个新的节点出来.</span></span><br><span class="line"><span class="comment">	succ.prev 指向当前new出来的节点</span></span><br><span class="line"><span class="comment">	对pred判断是否是null,如果是null的话,就说明是第一个值,否则就是赋值上pred个节点的next</span></span><br><span class="line"><span class="comment">	,size ++ 就是对长度 ++ </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert succ != null;</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">        succ.prev = newNode;</span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pred.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>   头插入 和 尾插入</p>
<p>   头插入，将值插入到头部</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkFirst(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	先将first 赋值给 f ,  根据传入进来的值e 和 下一个节点f(前一个头节点),new一个新的newNode节点出来,first指向newNode.如果f是null的话就说明是初始化,如果不是null的话,f的上一个节点指向newNode,刚刚程序newNode出来的.就完成了头节点的插入</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);</span><br><span class="line">        first = newNode;</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">            last = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            f.prev = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>  尾节点插入;与头节点相似，也是利用变量last来实现尾部插入.</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void addLast(E e) &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void linkLast(E e) &#123;</span><br><span class="line">        final Node&lt;E&gt; l &#x3D; last;</span><br><span class="line">        final Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(l, e, null);</span><br><span class="line">        last &#x3D; newNode;</span><br><span class="line">        if (l &#x3D;&#x3D; null)</span><br><span class="line">            first &#x3D; newNode;</span><br><span class="line">        else</span><br><span class="line">            l.next &#x3D; newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>get 方法,获取值方法</p>
<p>根据下标来获取出值 ,然后调用node方法获取出节点,node.item就是我们需要的值,然后对其进行返回即可.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public E get(int index) &#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    return node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果输入index是小于0和大于size的话,就会爆出下标越界的错误.</span><br><span class="line">private void checkElementIndex(int index) &#123;</span><br><span class="line">        if (!isElementIndex(index))</span><br><span class="line">            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>​       </p>
<p>getFirst / getLast     可以看到first和 last都是直接从定义的变量中获取出对应的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">return</span> l.item;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>​    peek 方法;使用first节点,如果是null的话就会返回null，否则就是f.item. 这里是没有删除first元素,poll是弹出元素并且删除.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public E peek() &#123;</span><br><span class="line">    final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">    return (f &#x3D;&#x3D; null) ? null : f.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>​    poll 方法 :  这里主要看unlinkFirst方法.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   取出 f 的item,节点对应的值和 f的next个节点,如果下个节点是null的话,就说明是没有值的,如果不为null的话，说将next的上一个节点prev指向null,因为头节点的prev和尾节点的next都是null来进行区分。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert f == first &amp;&amp; f != null;</span></span><br><span class="line">        <span class="keyword">final</span> E element = f.item;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">        f.item = <span class="keyword">null</span>;</span><br><span class="line">        f.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">        first = next;</span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">            last = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            next.prev = <span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>​    offer 等方法都是内部调用了add / addFirst / addLast等方法.</p>
<ul>
<li><p>remove 方法</p>
<p>根据下标进来remove方法, node(index) 也是在上面进行讲到的,就是根据下标获取对应的node节点信息.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	这里获取出节点的 next 和 prev方法.</span></span><br><span class="line"><span class="comment">	该节点的上一个节点(prev)的next需要指向指向该节点的下个节点(next),该节点的下一个节点和prev的操作是相反的,因为这样的话,就删除了该节点,并且上一个节点和下一个节点关联起来了.	</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> <span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert x != null;</span></span><br><span class="line">        <span class="keyword">final</span> E element = x.item;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">            first = next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev.next = next;</span><br><span class="line">            x.prev = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            last = prev;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next.prev = prev;</span><br><span class="line">            x.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        x.item = <span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>  remove(Object o) 根据值来进行删除.这个可以看出来，如果有二个相同节点的值,调用一次这个方法是只可以删除一个,而不是二个.</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    if (o &#x3D;&#x3D; null) &#123;</span><br><span class="line">        for (Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; x &#x3D; x.next) &#123;</span><br><span class="line">            if (x.item &#x3D;&#x3D; null) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; x &#x3D; x.next) &#123;</span><br><span class="line">            if (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p> 好啦,今天的知识内容就更新到这里,虽然文字描述到很难理解,但是主要去理解 Node 节点的 双向指向,并且每次添加节点和删除添加，都是靠Node的prev和next来进行指向. 所以说LinkedList是删除快，查询慢的原因。</p>
]]></content>
      <categories>
        <category>Java集合源码</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>如何面对失恋</title>
    <url>/2020/11/22/life/%E5%85%B3%E4%BA%8E%E5%A4%B1%E6%81%8B/</url>
    <content><![CDATA[<h3 id="Why"><a href="#Why" class="headerlink" title="Why ?"></a>Why ?</h3><p>   为什么要写这篇文章呢？</p>
<p>   对感情复盘，晓得自己的问题，勇敢的去面对，去面对最真实的自己。</p>
<blockquote>
<p>   对，你没看错，我2020-10-24,晚上8点十多分钟,我分手了.</p>
<p>   疑问句式的分手.  如果我说分手呢？</p>
<p>   其实失望并不是一瞬间有的,但是说分手以及要分手,是实实在在的一瞬间就可以的.</p>
<p>  这里可以说，单方面全部都是我的问题.</p>
<p>  如果我说 那杯 乌糖玛奇朵 很好喝？不多对你瞅二下？ 多主动说一些话题 ? 多去关心下你的话题 ? 去给你主动夹菜 ？  去……………………</p>
<p>  最后我现在编写于2020-11-22, 现在也是对那时的我以及我们来复盘。 错误99%都是我,如果硬是说那1%的错误在哪? 我也会说，在我.  </p>
<p>  p1:  我的不主动以及做事没主见(怕是最后的没主见，是最后杀死的我.). </p>
<p>  p2:  那些我瞅你的细节,都是我对自己情绪的不满,最后也给你留下了很多不好的印象(这里,我真诚甚至比较奢求的求你忘记这些不好,如果代价是忘记我,那我也是OK的).</p>
<p>  p3:  对你,我想也许没机会了.    以后，我永远不会失约了.</p>
<p>  p4:  如果之前不规划以后,我想现在也不会这么难受…. 难受到什么地步来了呢？ 总是想到也许以后的什么都没意思了, 想着这辈子怎么过都是过. 和朋友喝醉过几次, 想得都是你.  我也抽了这些年我没都没抽过的烟. 2020-10-30 , 这天晚上，我在深圳五和地铁口C出来往上走,二巷十五号的天台，抽了一包黄鹤楼.   抽到想吐,甚至我当时就在想,咦， 尼古丁一次摄入怎么多，我怎么还没事呢？ 也是好奇. </p>
<p>​        于是第二天我就去找你, 其实月末不月末，小周六不小周六的，我又会怎么不晓得呢？ </p>
<p>​         我就是想去看你，哪怕匆匆一眼………</p>
<p>​        至此，我当你的面说的最后一句花，也是: 我还爱你.</p>
</blockquote>
<hr>
<h3 id="What"><a href="#What" class="headerlink" title="What?"></a>What?</h3><p>  从2020-11-01后，我是怎么过的呢？</p>
<p>  说来也是好笑. </p>
<p>  不喜欢你的人，她会连你在10-31 晚上去哪里睡觉？去哪里？去哪里？去哪里？都不会关心。</p>
<p>  不过，也好在没用关心hhhhh</p>
<p>   那夜，我在武汉站，呆了整整一夜，往前走有钟点房，我没去。 我就想感受下，那种心痛以及最后的绝望会给我带来什么？ 很遗憾,什么都没带来(所以，兄弟们或者姐妹们，不管怎么样，面对什么，都不要像我这样折磨自己的肉体.).    其实那夜的风好冷, 武汉站更冷, 可是我的心比这还冷…….</p>
<p>​    于是,我在家以及在公司都是丧到死，都是那种无精打采，甚至都是那种没看到一个人，都想问，她为什么会说分手的话？为什么不肯等我一个月，我辞职回来. 我记得那段时间,我开会,我甚至开到半一半都偷偷的哭起来，想起我对她说的自己的想法以及未来.  后来几天,我开会就干脆偷偷的坐到角落，想到她，我就眼眶给红起来留下了眼泪.    可是啊，我更希望她过的更好. 是我自己的问题，弄丢了, 怪我怪我怪我. 然后加上室友不合租，我一下子面对的问题啊，就多起来，工作上堆积了好久的活/失恋/找租房/搬家/走出失恋, 然后我一下子就爆发了，我觉得我不能这样，我不能就这样没任何行动，我要去找租房，我还想找一份工资高的工资，我还想……减肥/护肤/搭配衣服等.</p>
<p>​    至于怎么走出来，你在刚刚分手的时候，肯定会特别失落以及一度不晓得自己要干什么，如果你还恰好是一个工作者的话，那你就会发现，如果你保持这样的状态，你会丢失的不仅仅的是时间，还有工作/生活/成长，那些对你一切有好的，你都会发现，你丢失了.</p>
<p>​    所以，当你选择自己去忙碌的时候，就是最好走出来的时候.</p>
<p>   去忙碌吧，去改变自己，去复盘那些让她/他觉得很有问题的性格或习惯…</p>
<hr>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>  写在最后，我也要去跑步了。</p>
<p>  对了，去改变自己，去让自己变优秀。 去等待下一个花海的时候，去拍很多美美的相片留给下一个自己.</p>
<p>  不必担心自己能不能遇到下一个什么，你要想到：我要成为什么样子的？我去要等待下一次花海？</p>
<p>  最后，祝大家不要失恋.</p>
<p>  如果真的失恋了也不要怕，去让自己变强，变优秀.</p>
<p>​                                                                                                     ——2020-11-22  写于深圳地铁六号线元芬站</p>
]]></content>
      <categories>
        <category>生活记录</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis-local-cache</title>
    <url>/2020/12/27/mybatis/mybatis-local-cache/</url>
    <content><![CDATA[<h4 id="题记"><a href="#题记" class="headerlink" title="题记"></a>题记</h4><p>​    缓存这个知识点在许多地方都有的，利用到好的话，对系统的很多地方查询是有很大的提升的.  可以看到,MyBatis 也是有  cache 的，那MyBatis 是怎么利用这个缓存的呢？ 在  INSERT/UPDATE/DELETE/SELECT中,是不是只有SELECT的时候用到了缓存，如果是  INSERT/UPDATE/DELETE 是否会对缓存有影响？</p>
<p>​    可以看结果来分析，然后跟进源码来仔细分析.</p>
<p>​    MyBatis 是分为 一级缓存 和 二级缓存的. 那么，我们就先从一级缓存开始.</p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h4><p>​     案例代码 :</p>
<p>​     这里我们是打印的查询sql的语句，再第二次再查询的时候，是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">InputStream mybatisInputStream &#x3D; Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line"></span><br><span class="line">SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(mybatisInputStream);</span><br><span class="line">SqlSession session &#x3D; sqlSessionFactory.openSession();</span><br><span class="line">BlogMapper blogMapper &#x3D; session.getMapper(BlogMapper.class);</span><br><span class="line">TbBlog tbBlog &#x3D; blogMapper.selectBlog(1);</span><br><span class="line">System.out.println(blogMapper.selectBlog(1));</span><br><span class="line">System.out.println(tbBlog);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 结果可以看到,第二次并没有再打印出 sql 语句来.</span><br><span class="line">&#x3D;&#x3D;&gt;  Preparing: select * from tb_blog where id &#x3D; ? </span><br><span class="line">&#x3D;&#x3D;&gt; Parameters: 1(Integer)</span><br><span class="line">&lt;&#x3D;&#x3D;    Columns: id, name</span><br><span class="line">&lt;&#x3D;&#x3D;        Row: 1, 6565</span><br><span class="line">&lt;&#x3D;&#x3D;      Total: 1</span><br><span class="line">TbBlog&#123;id&#x3D;1, name&#x3D;&#39;6565&#39;&#125;</span><br><span class="line">TbBlog&#123;id&#x3D;1, name&#x3D;&#39;6565&#39;&#125;</span><br></pre></td></tr></table></figure>



<p>案例二 :  我们再第二次查询之前 加入 一个add 方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">InputStream mybatisInputStream &#x3D; Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line"></span><br><span class="line">SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(mybatisInputStream);</span><br><span class="line">SqlSession session &#x3D; sqlSessionFactory.openSession();</span><br><span class="line">BlogMapper blogMapper &#x3D; session.getMapper(BlogMapper.class);</span><br><span class="line">TbBlog tbBlog &#x3D; blogMapper.selectBlog(1);</span><br><span class="line"></span><br><span class="line">System.out.println(blogMapper.addBlog(&quot;GavinYang&quot;));</span><br><span class="line">System.out.println(blogMapper.selectBlog(1));</span><br><span class="line">System.out.println(tbBlog);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 看结果,可以看到当中间穿插一个 insert 的sql语句,那么在第二次查询的时候,就会执行sql语句.</span><br><span class="line">&#x2F;&#x2F; 那么也就说，这个时候缓存是失效了.</span><br><span class="line">&#x3D;&#x3D;&gt;  Preparing: select * from tb_blog where id &#x3D; ? </span><br><span class="line">&#x3D;&#x3D;&gt; Parameters: 1(Integer)</span><br><span class="line">&lt;&#x3D;&#x3D;    Columns: id, name</span><br><span class="line">&lt;&#x3D;&#x3D;        Row: 1, 6565</span><br><span class="line">&lt;&#x3D;&#x3D;      Total: 1</span><br><span class="line">&#x3D;&#x3D;&gt;  Preparing: insert into tb_blog (name) values(?) </span><br><span class="line">&#x3D;&#x3D;&gt; Parameters: GavinYang(String)</span><br><span class="line">&lt;&#x3D;&#x3D;    Updates: 1</span><br><span class="line">1</span><br><span class="line">&#x3D;&#x3D;&gt;  Preparing: select * from tb_blog where id &#x3D; ? </span><br><span class="line">&#x3D;&#x3D;&gt; Parameters: 1(Integer)</span><br><span class="line">&lt;&#x3D;&#x3D;    Columns: id, name</span><br><span class="line">&lt;&#x3D;&#x3D;        Row: 1, 6565</span><br><span class="line">&lt;&#x3D;&#x3D;      Total: 1</span><br><span class="line">TbBlog&#123;id&#x3D;1, name&#x3D;&#39;6565&#39;&#125;</span><br><span class="line">TbBlog&#123;id&#x3D;1, name&#x3D;&#39;6565&#39;&#125;</span><br></pre></td></tr></table></figure>



<p>案例三 :  使用二个 SqlSession  案例</p>
<p>可以很明显的看到 , 在第二次的时候还出现了脏数据.</p>
<p>这里也可以看到一级缓存是只在 SqlSession 中存在的,也就是数据库会话内部共享的.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">InputStream mybatisInputStream &#x3D; Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line">SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(mybatisInputStream);</span><br><span class="line"></span><br><span class="line">SqlSession openSession1 &#x3D; sqlSessionFactory.openSession();</span><br><span class="line">SqlSession openSession2 &#x3D; sqlSessionFactory.openSession();</span><br><span class="line">BlogMapper blogMapper1 &#x3D; openSession1.getMapper(BlogMapper.class);</span><br><span class="line">BlogMapper blogMapper2 &#x3D; openSession2.getMapper(BlogMapper.class);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;blogMapper1 读取数据 &quot; + blogMapper1.selectBlog(1));</span><br><span class="line">System.out.println(&quot;blogMapper2 读取数据&quot; + blogMapper2.selectBlog(1));</span><br><span class="line"></span><br><span class="line">System.out.println(blogMapper1.updateHashCode(&quot;PeterWong&quot;));</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;blogMapper1 读取数据 &quot; + blogMapper1.selectBlog(1));</span><br><span class="line">System.out.println(&quot;blogMapper2 读取数据&quot; + blogMapper2.selectBlog(1));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 然后我们可以看到 log 打印出来的内容</span><br><span class="line">&#x3D;&#x3D;&gt;  Preparing: select * from tb_blog where id &#x3D; ? </span><br><span class="line">&#x3D;&#x3D;&gt; Parameters: 1(Integer)</span><br><span class="line">&lt;&#x3D;&#x3D;    Columns: id, name</span><br><span class="line">&lt;&#x3D;&#x3D;        Row: 1, 6565</span><br><span class="line">&lt;&#x3D;&#x3D;      Total: 1</span><br><span class="line">blogMapper1 读取数据 TbBlog&#123;id&#x3D;1, name&#x3D;&#39;6565&#39;&#125;</span><br><span class="line">Created connection 433287555.</span><br><span class="line">Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@19d37183]</span><br><span class="line">&#x3D;&#x3D;&gt;  Preparing: select * from tb_blog where id &#x3D; ? </span><br><span class="line">&#x3D;&#x3D;&gt; Parameters: 1(Integer)</span><br><span class="line">&lt;&#x3D;&#x3D;    Columns: id, name</span><br><span class="line">&lt;&#x3D;&#x3D;        Row: 1, 6565</span><br><span class="line">&lt;&#x3D;&#x3D;      Total: 1</span><br><span class="line">blogMapper2 读取数据TbBlog&#123;id&#x3D;1, name&#x3D;&#39;6565&#39;&#125;</span><br><span class="line">&#x3D;&#x3D;&gt;  Preparing: update tb_blog set name &#x3D; ? where id &#x3D; 1; </span><br><span class="line">&#x3D;&#x3D;&gt; Parameters: PeterWong(String)</span><br><span class="line">&lt;&#x3D;&#x3D;    Updates: 1</span><br><span class="line">1</span><br><span class="line">&#x3D;&#x3D;&gt;  Preparing: select * from tb_blog where id &#x3D; ? </span><br><span class="line">&#x3D;&#x3D;&gt; Parameters: 1(Integer)</span><br><span class="line">&lt;&#x3D;&#x3D;    Columns: id, name</span><br><span class="line">&lt;&#x3D;&#x3D;        Row: 1, PeterWong</span><br><span class="line">&lt;&#x3D;&#x3D;      Total: 1</span><br><span class="line">blogMapper1 读取数据 TbBlog&#123;id&#x3D;1, name&#x3D;&#39;PeterWong&#39;&#125;</span><br><span class="line">blogMapper2 读取数据TbBlog&#123;id&#x3D;1, name&#x3D;&#39;6565&#39;&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到我们说了三面的这三种情况, 具体的执行流程可以我们可以现在 案例一里面对第二次 query 进行 debug 分析操作.    当我们debug到  org.apache.ibatis.executor.BaseExecutor#query(org.apache.ibatis.mapping.MappedStatement, java.lang.Object, org.apache.ibatis.session.RowBounds,  org.apache.ibatis.session.ResultHandler,  org.apache.ibatis.cache.CacheKey, org.apache.ibatis.mapping.BoundSql)  的时候，可以看到  org.apache.ibatis.executor.BaseExecutor#localCache 只有一个 缓存的值的 ， 根据 getObject 方法可以跟进到 org.apache.ibatis.cache.impl.PerpetualCache#cache  中来,</p>
<p>传入进来的 key 值是 :   -1896651191:1062027004:com.iyang.mybatis.mapper.BlogMapper.selectBlog:0:2147483647:select * from tb_blog where id = ?:1:development  然后从 cache 中获取出值来, 所以这里就没有走  query 的查询语句.</p>
<p>这是命中缓存的情况.</p>
<p>下面我们来看下, 在第二次 query 之前如果执行了一个 add 方法，为什么就命中不了了呢？</p>
<p>这里可以大致猜测下，在执行完 add 方法后，是不是给 cache 给清除掉了，然后再去查询的时候，就查询不到了.</p>
<p>于是我们在 add 方法上进行 debug 查看下 :</p>
<p>最后我们 debug 跟进到这里 :  org.apache.ibatis.executor.BaseExecutor#clearLocalCache 就可以发现</p>
<p>这里是有二个 clear 方法，也就是清除方法.</p>
<p>localCache.clear()   —-&gt;     org.apache.ibatis.cache.impl.PerpetualCache#clear   对应的就是这里的清楚方法，直接调用 HashMap 的clear 方法进行清除.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">localCache.clear();</span><br><span class="line">localOutputParameterCache.clear();</span><br></pre></td></tr></table></figure>

<p>所以这里可以看出在第二次调用 query 之前，如果是有 insert/update/delete 等方法的话，就会去重置这二个地方的缓存的.</p>
<p>MyBatis 的一级缓存的是跟随  SqlSession 的，这里是可以根据简单的案例效果看出来的.</p>
<p>一级缓存只是使用了一个 HashMap , 最后清除缓存的时候，也是调用 HashMap 的clear 方法</p>
<p>最后从案例三可以看出来，当多个  SqlSession 的时候，由于各自有存有各自的缓存，所以是很容易引起脏数据的, 将缓存级别设置为 Statement.</p>
<h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4><h4 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h4><p>​     可以看到一级缓存的话，是局限于 SqlSession . 如果要多个 sqlSession 之间共享缓存的话，就需要开启二级缓存.   开启的话,我们在 MyBatis 配置文件中加上:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;settings&gt;</span><br><span class="line">    &lt;setting name&#x3D;&quot;logImpl&quot; value&#x3D;&quot;STDOUT_LOGGING&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 开启二级缓存 --&gt;</span><br><span class="line">    &lt;setting name&#x3D;&quot;cacheEnabled&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;settings&gt;</span><br></pre></td></tr></table></figure>

<p>​    <strong>案例一 :  是否提交事务</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    InputStream mybatisInputStream &#x3D; Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line">    SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(mybatisInputStream);</span><br><span class="line">    SqlSession sqlSession1 &#x3D; sqlSessionFactory.openSession(true);</span><br><span class="line">    SqlSession sqlSession2 &#x3D; sqlSessionFactory.openSession(true);</span><br><span class="line"></span><br><span class="line">    BlogMapper blogMapper1 &#x3D; sqlSession1.getMapper(BlogMapper.class);</span><br><span class="line">    BlogMapper blogMapper2 &#x3D; sqlSession2.getMapper(BlogMapper.class);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;blogMapper1 获取数据&quot; + blogMapper1.selectBlog(1));</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; sqlSession1.commit();</span><br><span class="line">    </span><br><span class="line">    System.out.println(&quot;blogMapper2 获取数据&quot; + blogMapper2.selectBlog(1));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;   ----------------   true结果   -----------------------</span><br><span class="line"></span><br><span class="line">Created connection 492079624.</span><br><span class="line">&#x3D;&#x3D;&gt;  Preparing: select * from tb_blog where id &#x3D; ? </span><br><span class="line">&#x3D;&#x3D;&gt; Parameters: 1(Integer)</span><br><span class="line">&lt;&#x3D;&#x3D;    Columns: id, name</span><br><span class="line">&lt;&#x3D;&#x3D;        Row: 1, 6565</span><br><span class="line">&lt;&#x3D;&#x3D;      Total: 1</span><br><span class="line">blogMapper1 获取数据TbBlog&#123;id&#x3D;1, name&#x3D;&#39;6565&#39;&#125;</span><br><span class="line">Opening JDBC Connection</span><br><span class="line">    </span><br><span class="line">Created connection 433287555.</span><br><span class="line">&#x3D;&#x3D;&gt;  Preparing: select * from tb_blog where id &#x3D; ? </span><br><span class="line">&#x3D;&#x3D;&gt; Parameters: 1(Integer)</span><br><span class="line">&lt;&#x3D;&#x3D;    Columns: id, name</span><br><span class="line">&lt;&#x3D;&#x3D;        Row: 1, 6565</span><br><span class="line">&lt;&#x3D;&#x3D;      Total: 1</span><br><span class="line">blogMapper2 获取数据TbBlog&#123;id&#x3D;1, name&#x3D;&#39;6565&#39;&#125;    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ------------   加上commit()方法结果   ---------------</span><br><span class="line"></span><br><span class="line">Created connection 630074945.</span><br><span class="line">&#x3D;&#x3D;&gt;  Preparing: select * from tb_blog where id &#x3D; ? </span><br><span class="line">&#x3D;&#x3D;&gt; Parameters: 1(Integer)</span><br><span class="line">&lt;&#x3D;&#x3D;    Columns: id, name</span><br><span class="line">&lt;&#x3D;&#x3D;        Row: 1, 6565</span><br><span class="line">&lt;&#x3D;&#x3D;      Total: 1</span><br><span class="line">blogMapper1 获取数据TbBlog&#123;id&#x3D;1, name&#x3D;&#39;6565&#39;&#125;</span><br><span class="line">Cache Hit Ratio [com.iyang.mybatis.mapper.BlogMapper]: 0.5</span><br><span class="line">blogMapper2 获取数据TbBlog&#123;id&#x3D;1, name&#x3D;&#39;6565&#39;&#125;</span><br></pre></td></tr></table></figure>

<p>​    从这里看, 是否提交事务可以看出来，是会影响二级缓存的.</p>
<p><strong>案例二 :  中间穿插更新语句</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args)  throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    InputStream mybatisInputStream &#x3D; Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line">    SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(mybatisInputStream);</span><br><span class="line">    SqlSession sqlSession1 &#x3D; sqlSessionFactory.openSession(false);</span><br><span class="line">    SqlSession sqlSession2 &#x3D; sqlSessionFactory.openSession(false);</span><br><span class="line">    SqlSession sqlSession3 &#x3D; sqlSessionFactory.openSession(false);</span><br><span class="line"></span><br><span class="line">    BlogMapper blogMapper1 &#x3D; sqlSession1.getMapper(BlogMapper.class);</span><br><span class="line">    BlogMapper blogMapper2 &#x3D; sqlSession2.getMapper(BlogMapper.class);</span><br><span class="line">    BlogMapper blogMapper3 &#x3D; sqlSession3.getMapper(BlogMapper.class);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot; blogMapper1 查询出来的数据 : &quot; + blogMapper1.selectBlog(1));</span><br><span class="line">    sqlSession1.commit();</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot; blogMapper2 查询出来的结果 : &quot; + blogMapper2.selectBlog(1));</span><br><span class="line"></span><br><span class="line">    System.out.println(blogMapper3.updateHashCode(&quot;GavinYang&quot;));</span><br><span class="line">    sqlSession3.commit();</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot; blogMapper2 查询出来的结果 : &quot; + blogMapper2.selectBlog(1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;  ------------------  打印结果 ------</span><br><span class="line"></span><br><span class="line">Created connection 630074945.</span><br><span class="line">Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@258e2e41]</span><br><span class="line">&#x3D;&#x3D;&gt;  Preparing: select * from tb_blog where id &#x3D; ? </span><br><span class="line">&#x3D;&#x3D;&gt; Parameters: 1(Integer)</span><br><span class="line">&lt;&#x3D;&#x3D;    Columns: id, name</span><br><span class="line">&lt;&#x3D;&#x3D;        Row: 1, 6565</span><br><span class="line">&lt;&#x3D;&#x3D;      Total: 1</span><br><span class="line"> blogMapper1 查询出来的数据 : TbBlog&#123;id&#x3D;1, name&#x3D;&#39;6565&#39;&#125;</span><br><span class="line">Cache Hit Ratio [com.iyang.mybatis.mapper.BlogMapper]: 0.5</span><br><span class="line"> blogMapper2 查询出来的结果 : TbBlog&#123;id&#x3D;1, name&#x3D;&#39;6565&#39;&#125;</span><br><span class="line"></span><br><span class="line">Created connection 603443293.</span><br><span class="line">Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@23f7d05d]</span><br><span class="line">&#x3D;&#x3D;&gt;  Preparing: update tb_blog set name &#x3D; ? where id &#x3D; 1; </span><br><span class="line">&#x3D;&#x3D;&gt; Parameters: GavinYang(String)</span><br><span class="line">&lt;&#x3D;&#x3D;    Updates: 1</span><br><span class="line">1</span><br><span class="line">Committing JDBC Connection [com.mysql.jdbc.JDBC4Connection@23f7d05d]</span><br><span class="line">Cache Hit Ratio [com.iyang.mybatis.mapper.BlogMapper]: 0.3333333333333333</span><br><span class="line">Opening JDBC Connection</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">Created connection 707976812.</span><br><span class="line">Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@2a32de6c]</span><br><span class="line">&#x3D;&#x3D;&gt;  Preparing: select * from tb_blog where id &#x3D; ? </span><br><span class="line">&#x3D;&#x3D;&gt; Parameters: 1(Integer)</span><br><span class="line">&lt;&#x3D;&#x3D;    Columns: id, name</span><br><span class="line">&lt;&#x3D;&#x3D;        Row: 1, GavinYang</span><br><span class="line">&lt;&#x3D;&#x3D;      Total: 1</span><br><span class="line"> blogMapper2 查询出来的结果 : TbBlog&#123;id&#x3D;1, name&#x3D;&#39;GavinYang&#39;&#125;</span><br></pre></td></tr></table></figure>

<p>这里是可以看到在更新之后并且 commit 了事务之后，后面紧跟的 sql 是去查询 数据库了的.   所以这里是可以看出来，update等操作是会去 清空对应的缓存的。</p>
<p>这里我们根据 案例一 的情况来分析，在开启了 二级缓存 的时候，是从哪里获取出来的数据的呢？</p>
<p>debug 跟进来 :     org.apache.ibatis.executor.CachingExecutor#query(org.apache.ibatis.mapping.MappedStatement, java.lang.Object, org.apache.ibatis.session.RowBounds,  org.apache.ibatis.session.ResultHandler,  org.apache.ibatis.cache.CacheKey, org.apache.ibatis.mapping.BoundSql)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span><br><span class="line">    throws SQLException &#123;</span><br><span class="line">  Cache cache &#x3D; ms.getCache();</span><br><span class="line">  if (cache !&#x3D; null) &#123;</span><br><span class="line">    flushCacheIfRequired(ms);</span><br><span class="line">    if (ms.isUseCache() &amp;&amp; resultHandler &#x3D;&#x3D; null) &#123;</span><br><span class="line">      ensureNoOutParams(ms, boundSql);</span><br><span class="line">      @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">&#x2F;&#x2F; debug 到这里，可以看到,就已经返回了我们需要的数据.        </span><br><span class="line">      List&lt;E&gt; list &#x3D; (List&lt;E&gt;) tcm.getObject(cache, key);</span><br><span class="line">      if (list &#x3D;&#x3D; null) &#123;</span><br><span class="line">        list &#x3D; delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">        tcm.putObject(cache, key, list); &#x2F;&#x2F; issue #578 and #116</span><br><span class="line">      &#125;</span><br><span class="line">      return list;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>org.apache.ibatis.executor.CachingExecutor#tcm  调用这个对象的 getObject  方法获取到了我们需要的值, 跟进来又从  org.apache.ibatis.cache.decorators.TransactionalCache 的 getObject  获取出我们的值, 最后从   org.apache.ibatis.cache.decorators.TransactionalCache#delegate 获取出值,  返回回来的.</p>
<p>org.apache.ibatis.cache.decorators.TransactionalCache#getObject</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object getObject(Object key) &#123;</span><br><span class="line">  &#x2F;&#x2F; issue #116</span><br><span class="line">&#x2F;&#x2F; 从缓存中获取出值.    </span><br><span class="line">  Object object &#x3D; delegate.getObject(key);</span><br><span class="line">  if (object &#x3D;&#x3D; null) &#123;</span><br><span class="line">&#x2F;&#x2F; 如果获取出来是null,也就是缓存中没有的话,org.apache.ibatis.cache.decorators.TransactionalCache#entriesMissedInCache 就添加到这个集合中来.      </span><br><span class="line">    entriesMissedInCache.add(key);</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; issue #146</span><br><span class="line">&#x2F;&#x2F; commit 后需要 clear 的话，就会返回 null.</span><br><span class="line">&#x2F;&#x2F; 这里想下这个变量会不会和我门案例二中的 update 操作有关系呢？</span><br><span class="line">&#x2F;&#x2F; 这里再 update后再 debug 发现,  delegate 中获取出来的是 null ,也就是确实是获取不到缓存了</span><br><span class="line">&#x2F;&#x2F; 和这个参数没关系.    </span><br><span class="line">  if (clearOnCommit) &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return object;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MyBatis 二级缓存不适应于配置文件中存在多表查询的情况. 一般我们是单表的 cache, 由于 mybatis 的二级缓存是基于  namespace 的, 多表查询语句所在的 namespace 无法感应到其他的 namespace  中的语句对多表中设计修改，就会引发脏数据.  这个时候，可以采用 cache-ref 来做处理，但是这样的话,缓存的颗粒度就变粗了.</p>
<p>执行流程 :  如果开启了二级缓存的话， MyBatis 会先走二级缓存，如果二级缓存没有的话，就会去一级缓存看看，如果都没有的话，就去查询数据库.</p>
<p>二级缓存 :  用  org.apache.ibatis.executor.CachingExecutor 装饰了   org.apache.ibatis.executor.BaseExecutor 的子类, 委托具体职责给 delegate  之前，实现了二级缓存的查询和写入功能.</p>
<h4 id="-2"><a href="#-2" class="headerlink" title=""></a></h4><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>最后看 一级缓存和二级缓存，都是利用的 HashMap 这种来做到本地缓存， 只是二级缓存的作用范围比起一级缓存的话，是要大的，并且也利用了一些 装饰者 等设计模式来设计二级缓存的.</p>
<p>如果是部署的分布式项目的话，那么还是 得切换到 redis 这种缓存来了， 本地利用 HashMap 这种缓存满足不了的.</p>
<p>文献参考地址 : <a href="https://tech.meituan.com/2018/01/19/mybatis-cache.html" target="_blank" rel="noopener">https://tech.meituan.com/2018/01/19/mybatis-cache.html</a></p>
]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>Java源码</tag>
      </tags>
  </entry>
  <entry>
    <title>深入了解JVM阅读笔记</title>
    <url>/2020/04/18/java_reflect_other/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3JVM%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="深入理解JVM阅读笔记"><a href="#深入理解JVM阅读笔记" class="headerlink" title="深入理解JVM阅读笔记"></a>深入理解JVM阅读笔记</h3><ol>
<li><p>个人认为学习JVM是对每个学习(深入)JAVA的人是一个必备的知识。</p>
</li>
<li><p>同时JVM里面的知识也不是一遍就可以学习好的，是要经过反复的阅读和自己的理解。肯定还要带有一定的项目实战经历(但是这个一般的情况都不是很容易遇见)。  </p>
<hr>
</li>
</ol>
<h3 id="Java内存区域笔记"><a href="#Java内存区域笔记" class="headerlink" title="Java内存区域笔记"></a>Java内存区域笔记</h3><ol>
<li><p>程序计数器: </p>
<p> 程序计数器是一块较小的内存,可以看成当前线程所执行的字节码的行号指示器.字节码解释器工作是通过改变计数器的值来选取吓一条需要执行的字节码,分支,循环,跳转,异常处理,线程恢复等基础功能都需要依赖这个计数器来完成.</p>
<p>  如果线程正在执行的是一个JAVA方法,这个计数器记录的是正在执行的虚拟机字节码指令地址,如果执行的是Native方法,这个计数器的值就是空(Undefind).此内存区域是唯一一个在JAVA虚拟机规范中没有规定任    OutOfMemoryError情况的区域</p>
</li>
<li><p>Java虚拟机栈</p>
<p>​        与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p>
<p>​       局部变量表存放了编译可知的各种基本类型(boolean,byte,char,short,int,float,long,double),对象引用(reference类型,它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型)    </p>
<p>​       在JAVA虚拟机规范中,对这个区域的规定了二种异常情况,如果线程请求的栈深度大于虚拟机所允许的深度,将会跑出来StackOverflowError异常,如果虚拟机栈可以动态扩展,如果扩展的是无法申请到足够的内存,就会抛出OutOfMeneryError异常</p>
</li>
</ol>
<p>   ​       虚拟机栈是Java执行方法的内存模型。每个方法被执行的时候，都会创建一个栈帧，当把栈帧压入栈，当方法正常返回或者抛出未捕获的异常时，栈帧就会出栈。</p>
<p>   ​       栈帧:  栈帧存储方法的相关信息，包含局部变量数表，返回值，操作数栈，动态链接。</p>
<p>   ​                  局部变量表:  包含了方法执行过程中的所有变量。局部变量数组所需要的空间在编译期间完成分配，在方法运行期间不会改变局部变量数组大小。</p>
<p>   ​                  返回值: 如果有返回值的话,压入调用者栈帧中的操作数栈中，并且把PC的值指向 方法调用指令 后面的一条指令地址。</p>
<p>   ​                  操作数栈:  操作变量的内存模型。操作数栈的最大深度在编译的时候已经确定（写入方法区Code属性的max_stacks项中）。操作数栈的元素可以是任意JAVA类型。32位数据占用栈空间为1，64位数据占用栈空间为6。方法刚开始执行的时候，栈是空的，当方法执行过程中，各种字节码指令往栈中存取数据。</p>
<p>   ​                  动态链接:  每个栈帧都持有在运行常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程的动态链接。</p>
<ol start="3">
<li><p>本地方法栈</p>
<p>​       本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。在虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常</p>
<p>​      调用本地Native的内存模型</p>
<p>​      线程独享</p>
</li>
<li><p>Java堆</p>
<p>​    Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块.Java堆是被所有线程共享的一块内存区域.此内存区域的唯一目的就是存放对象实例,几乎所有的对象实例都在这里分配.所有的对象实例以及数组都要在堆上分配,但是随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了`</p>
<p>​    Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆。从内存回收的角度来看，由于现在收集器基本都采用分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。从内存分配的角度来看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。不过无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。</p>
<p>​    当前主流的虚拟机都是按照可扩展来实现的(通过-Xmx 和 -Xms控制)。如果在堆中没有内存完成实例分配，堆中没有内存完成实例配置，并且堆也无法再扩展时，将会抛出来OurOfMemoryError异常。</p>
</li>
<li><p>方法区</p>
<p>  方法区与Java堆一样,是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。</p>
<p>  多人都更愿意把方法区称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已，这样HotSpot的垃圾收集器可以像管理Java堆一样管理这部分内存。（Java8 中好像永久代换了名字）</p>
<p>​    根据虚拟机规定，当方法区无法满足内存分配的需求时，将会抛出OutOfMemoryError异常。</p>
</li>
<li><p>运行时常量池</p>
<p>​        运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p>
<p>​        运行时常量池相对于Class文件常量池的另外一个重要特性时具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。</p>
<p>​        运行时常量池时方法区的一部分，自然受到方法区内存限制,当常量池无法再申请到内存时就会抛出OutOfMemeryError异常。</p>
</li>
<li><p>直接内存</p>
<p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现，所以我们放到这里一起讲解。</p>
</li>
</ol>
<p>总结 :  对于Java内存区域的知识点大致是这样，但是每个点都是要深入进去了解的。这里是摘抄书籍的内容来做笔记。后期再看的时候，会添加上个人笔记。</p>
<hr>
<h3 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h3><ol>
<li><p>Class类文件结构</p>
<p>​     任何一个Class文件都对应着唯一一个类或接口的定义信息，但反过来说，类或接口并不一定都得定义在文件里（譬如类或接口也可以通过类加载器直接生成）。</p>
<p>​     Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。</p>
<p>​      这里我们就采用书中的代码,跟着来一步一步实现。</p>
<p>​       进入到这个TestClass.java的目录下，执行javac TestClass.java 就会在同一级目录下生成出 TestClass.class文件，这里我是用 Sublime 打开的.class文件,也同样可以看到书中的效果，开头的cafe babe(至于这其中的故事可以去看原书籍).</p>
<p>​        然后继续在刚刚的目录下,来执行 javap -verbose TestClass ，都可以看到效果。这里的内容对着原书籍上仔细的一一对看即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.yang.basicjavatest.gjvm;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Author: Mu_Yi</span><br><span class="line"> * @Date: 2020&#x2F;4&#x2F;18 14:27</span><br><span class="line"> * @Version 1.0</span><br><span class="line"> * @qq: 1411091515</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class TestClass &#123;</span><br><span class="line"></span><br><span class="line">    private int m;</span><br><span class="line"></span><br><span class="line">    public int inc()&#123;</span><br><span class="line"></span><br><span class="line">        return m + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>cafe babe 0000 0034 0013 0a00 0400 0f09<br>0003 0010 0700 1107 0012 0100 016d 0100<br>0149 0100 063c 696e 6974 3e01 0003 2829<br>5601 0004 436f 6465 0100 0f4c 696e 654e<br>756d 6265 7254 6162 6c65 0100 0369 6e63<br>0100 0328 2949 0100 0a53 6f75 7263 6546<br>696c 6501 000e 5465 7374 436c 6173 732e<br>6a61 7661 0c00 0700 080c 0005 0006 0100<br>2563 6f6d 2f79 616e 672f 6261 7369 636a<br>6176 6174 6573 742f 676a 766d 2f54 6573<br>7443 6c61 7373 0100 106a 6176 612f 6c61<br>6e67 2f4f 626a 6563 7400 2100 0300 0400<br>0000 0100 0200 0500 0600 0000 0200 0100<br>0700 0800 0100 0900 0000 1d00 0100 0100<br>0000 052a b700 01b1 0000 0001 000a 0000<br>0006 0001 0000 0009 0001 000b 000c 0001<br>0009 0000 001f 0002 0001 0000 0007 2ab4<br>0002 0460 ac00 0000 0100 0a00 0000 0600<br>0100 0000 0f00 0100 0d00 0000 0200 0e</p>
</blockquote>
</li>
</ol>
<pre><code>javap -verbose TestClass.class 效果</code></pre><blockquote>
<p>D:\Java_DaiMa\idea_github_self\basic-java-io\basic-java-test\src\main\java\com\yang\basicjavatest\gjvm&gt;javap -verbose TestClass.class<br>Classfile /D:/Java_DaiMa/idea_github_self/basic-java-io/basic-java-test/src/main/java/com/yang/basicjavatest/gjvm/TestClass.class<br>  Last modified 2020-4-18; size 303 bytes<br>  MD5 checksum b5c0b88622793ee9ace089dce2d2959d<br>  Compiled from “TestClass.java”<br>public class com.yang.basicjavatest.gjvm.TestClass<br>  minor version: 0<br>  major version: 52<br>  flags: ACC_PUBLIC, ACC_SUPER<br>Constant pool:<br>   #1 = Methodref          #4.#15         // java/lang/Object.”<init>“:()V<br>   #2 = Fieldref           #3.#16         // com/yang/basicjavatest/gjvm/TestClass.m:I<br>   #3 = Class              #17            // com/yang/basicjavatest/gjvm/TestClass<br>   #4 = Class              #18            // java/lang/Object<br>   #5 = Utf8               m<br>   #6 = Utf8               I<br>   #7 = Utf8               <init><br>   #8 = Utf8               ()V<br>   #9 = Utf8               Code<br>  #10 = Utf8               LineNumberTable<br>  #11 = Utf8               inc<br>  #12 = Utf8               ()I<br>  #13 = Utf8               SourceFile<br>  #14 = Utf8               TestClass.java<br>  #15 = NameAndType        #7:#8          // “<init>“:()V<br>  #16 = NameAndType        #5:#6          // m:I<br>  #17 = Utf8               com/yang/basicjavatest/gjvm/TestClass<br>  #18 = Utf8               java/lang/Object<br>{<br>  public com.yang.basicjavatest.gjvm.TestClass();<br>    descriptor: ()V<br>    flags: ACC_PUBLIC<br>    Code:<br>      stack=1, locals=1, args_size=1<br>         0: aload_0<br>         1: invokespecial #1                  // Method java/lang/Object.”<init>“:()V<br>         4: return<br>      LineNumberTable:<br>        line 9: 0</p>
<p>  public int inc();<br>    descriptor: ()I<br>    flags: ACC_PUBLIC<br>    Code:<br>      stack=2, locals=1, args_size=1<br>         0: aload_0<br>         1: getfield      #2                  // Field m:I<br>         4: iconst_1<br>         5: iadd<br>         6: ireturn<br>      LineNumberTable:<br>        line 15: 0<br>}<br>SourceFile: “TestClass.java”</p>
</blockquote>
<ol start="2">
<li><p>LineNumberTable 属性 </p>
<p> LineNumberTable属性用于描述Java源码行号与字节码行号（字节码的偏移量）之间的对应关系。它并不是运行时必需的属性，但默认会生成到Class文件之中，可以在Javac中分别使用-g:none或-g:lines选项来取消或要求生成这项信息。如果选择不生成LineNumberTable属性，对程序运行产生的最主要的影响就是当抛出异常时，堆栈中将不会显示出错的行号，并且在调试程序的时候，也无法按照源码行来设置断点。     </p>
</li>
</ol>
<ol start="3">
<li><p>LocalVariableTable属性</p>
<p>LocalVariableTable属性用于描述栈帧中局部变量表中的变量与Java源码中定义的变量之间的关系，它也不是运行时必需的属性，但默认会生成到Class文件之中，可以在Javac中分别使用-g:none或-g:vars选项来取消或要求生成这项信息。如果没有生成这项属性，最大的影响就是当其他人引用这个方法时，所有的参数名称都将会丢失，IDE将会使用诸如arg0、arg1之类的占位符代替原有的参数名，这对程序运行没有影响，但是会对代码编写带来较大不便，而且在调试期间无法根据参数名称从上下文中获得参数值。</p>
</li>
</ol>
<ol start="4">
<li><p>SourceFile属性</p>
<p> SourceFile属性用于记录生成这个Class文件的源码文件名称。这个属性也是可选的，可以分别使用Javac的-g:none或-g:source选项来关闭或要求生成这项信息。在Java中，对于大多数的类来说，类名和文件名是一致的，但是有一些特殊情况（如内部类）例外。如果不生成这项属性，当抛出异常时，堆栈中将不会显示出错代码所属的文件名。这个属性是一个定长的属性。</p>
</li>
</ol>
<ol start="5">
<li><p>ConstantValue 属性</p>
<p> ConstantValue属性的作用是通知虚拟机自动为静态变量赋值。只有被static关键字修饰的变量（类变量）才可以使用这项属性。类似“int x=123”和“static int x=123”这样的变量定义在Java程序中是非常常见的事情，但虚拟机对这两种变量赋值的方式和时刻都有所不同。对于非static类型的变量（也就是实例变量）的赋值是在实例构造器<init>方法中进行的；而对于类变量，则有两种方式可以选择：在类构造器<clinit>方法中或者使用ConstantValue属性。目前Sun Javac编译器的选择是：如果同时使用final和static来修饰一个变量（按照习惯，这里称“常量”更贴切），并且这个变量的数据类型是基本类型或者java.lang.String的话，就生成ConstantValue属性来进行初始化，如果这个变量没有被final修饰，或者并非基本类型及字符串，则将会选择在<clinit>方法中进行初始化。</p>
</li>
<li><p>InnerClasses 属性</p>
<p> InnerClasses属性用于记录内部类与宿主类之间的关联。如果一个类中定义了内部类，那编译器将会为它以及它所包含的内部类生成InnerClasses属性。</p>
</li>
</ol>
<p>   等等更多的属性就去具体的原书籍中查看</p>
<hr>
<ol start="2">
<li>字节码指令也推荐在原书籍中查看。</li>
</ol>
<hr>
<h3 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h3><ol>
<li><p>类加载的时机 :  </p>
<p>  类从被加载到虚拟机内存中开始,到卸载出内存为止，它的整个生命周期包括 : 加载(loading),验证(verification),准备(Preparation), 解析(resolution),初始化(init),使用(use) 和 卸载(unloading).</p>
</li>
<li><p>加载(类加载):</p>
<ul>
<li>通过一个类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据。</li>
<li>在内存中生成一个代表这个类的 java.lang.Class对象，作为方法区这个类的各种数据访问入口。</li>
</ul>
</li>
<li><p>验证 :</p>
<p>  验证是连接阶段的第一步,这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害到虚拟机自身的安危。</p>
<ul>
<li>​    文件格式的检验 ： 这一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。</li>
<li>元数据验证:  是对字节码描述的信息进行语义分析，以确保起描述的信息符合Java语言虚拟机的要求。</li>
<li>字节码验证:  通过数据流和控制流分析，确保程序语义是合法的，符合逻辑的。</li>
<li>符号引用验证: 最后一阶段的检验发生在虚拟机将符号引用转化为直接引用的时候。</li>
</ul>
</li>
<li><p>准备 :  </p>
<p>​    准备阶段是正式为类变量分配内存并设置类变变量初始化的阶段，这些变量所使用的内存都将在方法区中进行分配。这时候进行内存分配的仅包括类变量(被static修饰的变量)，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。</p>
</li>
<li><p>解析 : </p>
<ul>
<li><p>​     类或接口的解析:   假设当前代码所处的类是D,如果要把一个从未解析的过的符号引用N解析为一个类或者接口C直接引用</p>
<ol>
<li><p>​     如果C不是一个数组类型，那虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C。在加载过程中，由于元数据验证、字节码验证的需要，又可能触发其他相关类的加载动作，例如加载这个类的父类或实现的接口。一旦这个加载过程出现了任何异常，解析过程就宣告失败。</p>
</li>
<li><p>如果C是一个数组类型，并且数组的元素类型为对象，也就是N的描述符会是类似“[Ljava/lang/Integer”的形式，那将会按照第1点的规则加载数组元素类型。如果N的描述符如前面所假设的形式，需要加载的元素类型就是“java.lang.Integer”，接着由虚拟机生成一个代表此数组维度和元素的数组对象。</p>
</li>
<li><p>如果上面的步骤没有出现任何异常，那么C在虚拟机中实际上已经成为一个有效的类或接口了，但在解析完成之前还要进行符号引用验证，确认D是否具备对C的访问权限。如果发现不具备访问权限，将抛出java.lang.IllegalAccessError异常。</p>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>字段解析 : </p>
<p>​      要解析一个未被解析过的字段符号引用，首先将会对字段表内class_index[插图]项中索引的CONSTANT_Class_info符号引用进行解析，也就是字段所属的类或接口的符号引用。如果在解析这个类或接口符号引用的过程中出现了任何异常，都会导致字段符号引用解析的失败。如果解析成功完成，那将这个字段所属的类或接口用C表示，虚拟机规范要求按照如下步骤对C进行后续字段的搜索。</p>
<ol>
<li>​        如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li>
<li>否则，如果在C中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li>
<li>否则，如果C不是java.lang.Object的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li>
<li>否则，查找失败，抛出java.lang.NoSuchFieldError异常。</li>
</ol>
</li>
<li><p>类方法解析 :</p>
<p>​     类方法解析的第一个步骤与字段解析一样，也需要先解析出类方法表的class_index[插图]项中索引的方法所属的类或接口的符号引用，如果解析成功，我们依然用C表示这个类，接下来虚拟机将会按照如下步骤进行后续的类方法搜索。</p>
<ol>
<li><p>​      类方法和接口方法符号引用的常量类型定义是分开的，如果在类方法表中发现class_index中索引的C是个接口，那就直接抛出java.lang.IncompatibleClassChangeError异常。</p>
</li>
<li><p>如果通过了第1步，在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</p>
</li>
<li><p>否则，在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</p>
</li>
<li><p>否则，在类C实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果存在匹配的方法，说明类C是一个抽象类，这时查找结束，抛出java.lang.AbstractMethodError异常。</p>
</li>
<li><p>否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError。</p>
</li>
</ol>
</li>
</ul>
<pre><code>最后，如果查找过程成功返回了直接引用，将会对这个方法进行权限验证，如果发现不具备对此方法的访问权限，将抛出java.lang.IllegalAccessError异常。</code></pre><ul>
<li><p>接口方法解析: </p>
<p> 接口方法也需要先解析出接口方法表的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，依然用C表示这个接口，接下来虚拟机将会按照如下步骤进行后续的接口方法搜索。</p>
<ol>
<li>​    与类方法解析不同，如果在接口方法表中发现class_index中的索引C是个类而不是接口，那就直接抛出java.lang.IncompatibleClassChangeError异常。</li>
<li>否则，在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li>
<li>否则，在接口C的父接口中递归查找，直到java.lang.Object类（查找范围会包括Object类）为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li>
<li>否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError异常。</li>
</ol>
</li>
</ul>
<pre><code>​    由于接口中的所有方法默认都是public的，所以不存在访问权限的问题，因此接口方法的符号解析应当不会抛出java.lang.IllegalAccessError异常。</code></pre><ol start="6">
<li><p>初始化 : </p>
<p>​    类初始化阶段是类加载过程的最后一步，前面的类加载过程中。除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码（或者说是字节码）</p>
</li>
<li><p>类加载阶段:</p>
<pre><code>类加载器虽然只用于实现类的加载动作，但它在JAVA程序中起到的作用却远远不限于类加载阶段。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在JAVA虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。</code></pre><p>跟着书上的写了代码，结果也是书上的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.yang.basicjavatest.gjvm;</span><br><span class="line"></span><br><span class="line">import java.io.InputStream;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Author: Mu_Yi</span><br><span class="line"> * @Date: 2020&#x2F;4&#x2F;18 15:35</span><br><span class="line"> * @Version 1.0</span><br><span class="line"> * @qq: 1411091515</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class ClassLoaderTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        ClassLoader classLoader &#x3D; new ClassLoader() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">               try&#123;</span><br><span class="line">                   String fileName &#x3D; name.substring(name.lastIndexOf(&quot;.&quot;) + 1 ) + &quot;.class&quot;;</span><br><span class="line">                   InputStream inputStream &#x3D; getClass().getResourceAsStream(fileName);</span><br><span class="line">                   if(inputStream &#x3D;&#x3D; null)&#123;</span><br><span class="line">                       return super.loadClass(name);</span><br><span class="line">                   &#125;</span><br><span class="line">                   byte [] b &#x3D; new byte[inputStream.available()];</span><br><span class="line">                   inputStream.read(b);</span><br><span class="line">                   return defineClass(name,b,0,b.length);</span><br><span class="line">               &#125;catch (Exception e)&#123;</span><br><span class="line">                   throw new ClassNotFoundException(name);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Object instance &#x3D; classLoader.loadClass(&quot;com.yang.basicjavatest.gjvm.ClassLoaderTest&quot;).newInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(instance.getClass());</span><br><span class="line">        System.out.println(instance instanceof ClassLoaderTest);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<hr>
<p>后续会持续学习JVM方面的知识,也会持续更新这篇知识。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis-spring</title>
    <url>/2020/12/27/mybatis/mybatis-spring/</url>
    <content><![CDATA[<h4 id="题记"><a href="#题记" class="headerlink" title="题记"></a>题记</h4><p>​    MyBatis 与 Spring 整合操作.   在我们入门学习 SSM  等东西的时候，就发现了任何东西，最后都是逃不过与Spring整合起来的道路.   然后这里看完 MyBatis 整合完 Spring  之后，那么之后一些其他的第三方，比如axon/redis/apollo/shiro 等这些东西，如果要整合 Spring  的时候，是不是也是相似的整合方式呢？</p>
<p>​    这个需要我们看完 MyBatis 与 Spring 之后，探究其整合的操作.</p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h4><p>​     分几个步骤，操作一把即可,带你回到哪个  SM 时代，不过这回是没有了 tomcat 的.</p>
<p>​     先放上一个完成的整合地址 :    <a href="https://github.com/baoyang23/mybtatis-analysis/tree/master/mybatis-spring-hello" target="_blank" rel="noopener">https://github.com/baoyang23/mybtatis-analysis/tree/master/mybatis-spring-hello</a>    如果不要看下面流程的,一步跳过即可.</p>
<ol>
<li>先创建一个 maven 项目，引入依赖.  依赖参考地址 :    <a href="https://github.com/baoyang23/mybtatis-analysis/blob/master/mybatis-spring-hello/pom.xml" target="_blank" rel="noopener">https://github.com/baoyang23/mybtatis-analysis/blob/master/mybatis-spring-hello/pom.xml</a></li>
<li>db配置 : <a href="https://github.com/baoyang23/mybtatis-analysis/blob/master/mybatis-spring-hello/src/main/resources/db.properties" target="_blank" rel="noopener">https://github.com/baoyang23/mybtatis-analysis/blob/master/mybatis-spring-hello/src/main/resources/db.properties</a></li>
<li>MyBatis配置:  <a href="https://github.com/baoyang23/mybtatis-analysis/tree/master/mybatis-spring-hello/src/main/resources/mybatis" target="_blank" rel="noopener">https://github.com/baoyang23/mybtatis-analysis/tree/master/mybatis-spring-hello/src/main/resources/mybatis</a></li>
<li>Spring 配置:  <a href="https://github.com/baoyang23/mybtatis-analysis/blob/master/mybatis-spring-hello/src/main/resources/spring-beans.xml" target="_blank" rel="noopener">https://github.com/baoyang23/mybtatis-analysis/blob/master/mybatis-spring-hello/src/main/resources/spring-beans.xml</a></li>
<li>最后,来份我们熟悉的 <a href="https://github.com/baoyang23/mybtatis-analysis/tree/master/mybatis-spring-hello/src/main/resources/sql" target="_blank" rel="noopener">https://github.com/baoyang23/mybtatis-analysis/tree/master/mybatis-spring-hello/src/main/resources/sql</a>  mapper.xml 文件.</li>
<li>不忘记再来一份代码 :   <a href="https://github.com/baoyang23/mybtatis-analysis/tree/master/mybatis-spring-hello/src" target="_blank" rel="noopener">https://github.com/baoyang23/mybtatis-analysis/tree/master/mybatis-spring-hello/src</a>     这些直接跑测试类即可.</li>
</ol>
<p>跟着这上面的几个步骤，就可以搭建完一个项目. 然后喊上我们的 永哥， 打上传说中的 debug , 疯狂的调试看每步干了什么事.</p>
<p>这个的时候，可以跑下测试类，是ok的.</p>
<h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>​       这里我们首先想到的是我们引入的依赖,是不是有个 mybatis-spring 的依赖. 从这个依赖，可以很明显的看出来，就是通过这个依赖，将 MyBatis 和 Spring 整合起来的。</p>
<p>​       然后再想想，我们除了这个依赖的话，还再哪里有使用到一些 Spring 和 MyBatis 的东西呢？  然后看到  spring-beans.xml 这个xml配置, 可以看到 org.mybatis.spring.SqlSessionFactoryBean  给注入到 bean 里面来了.org.mybatis.spring.mapper.MapperScannerConfigurer也是给注入到  bean 里面来了. 并且二者都有通过来进行属性设置值操作.</p>
<p>​        那么,我们就基于这二个类的源码开始阅读.</p>
<p>​    <strong>SqlSessionFactoryBean (org.mybatis.spring.SqlSessionFactoryBean)</strong></p>
<p>这里 SqlSessionFactoryBean 是实现了很多接口,这些接口都是Spring的.</p>
<p>FactoryBean 工厂bean,点进去可以看到,其有方法getObject()/getObjectType等方法获取bean的,然后加上泛型,也就是这里获取的 getObject就是泛型.</p>
<p>InitializingBean:  afterPropertiesSet 初始化 bean 的时候，会调用该方法.</p>
<p>ApplicationEvent:   Spring的事件传播机制，就是使用的这种方式.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**  可以看到这个类实现了 Spring 这个多接口,那么就有个问题,实现了这么多接口的方法,到底是哪个方法先执行的呢？ 如果你对Spring源码很熟悉的话,是有可能清楚的,但是还是会有点绕的. </span><br><span class="line">这里我们给 getObject&#x2F;afterPropertiesSet&#x2F;onApplicationEvent这三个方法打上断点来进行debug,</span><br><span class="line">debug每走的一步,就是执行的先后顺序。如果不是特别熟悉源码的执行顺序,这种笨方法其实也是可以的.</span><br><span class="line">*</span><br><span class="line">* 所以这里debug的执行顺序是 : afterPropertiesSet --&gt; getObject  ---&gt; onApplicationEvent</span><br><span class="line">* 于是我们就跟着这个顺序来阅读.</span><br><span class="line">* 注意在调用这些方法之前,&lt;property&gt;标签的值都是已经赋值进来了的,是通过反射走的set 方法进来的.</span><br><span class="line">*&#x2F;</span><br><span class="line">public class SqlSessionFactoryBean</span><br><span class="line">    implements FactoryBean&lt;SqlSessionFactory&gt;, InitializingBean, ApplicationListener&lt;ApplicationEvent&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 实现FactoryBean 方法,这里是实现了该接口的三个方法. 其实这里的 isSingle是可以不用实现的</span><br><span class="line">&#x2F;&#x2F; 因为接口是用 default 来修饰的.</span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 该方法是判断并且再次确认 SqlSessionFactory是不是有了. 如果没有的话,就会调用afterProperties来初始化.</span><br><span class="line">   * &#123;@inheritDoc&#125;</span><br><span class="line">   *&#x2F;</span><br><span class="line">  @Override</span><br><span class="line">  public SqlSessionFactory getObject() throws Exception &#123;</span><br><span class="line">    if (this.sqlSessionFactory &#x3D;&#x3D; null) &#123;</span><br><span class="line">      afterPropertiesSet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return this.sqlSessionFactory;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public Class&lt;? extends SqlSessionFactory&gt; getObjectType() &#123;</span><br><span class="line">    return this.sqlSessionFactory &#x3D;&#x3D; null ? SqlSessionFactory.class : this.sqlSessionFactory.getClass();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public boolean isSingleton() &#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; InitializingBean 实现的方法</span><br><span class="line">  @Override</span><br><span class="line">  public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line">&#x2F;&#x2F; 先对 dataSource&#x2F;sqlSessionFactoryBuilder进行非null的判断.</span><br><span class="line">    notNull(dataSource, &quot;Property &#39;dataSource&#39; is required&quot;);</span><br><span class="line">    notNull(sqlSessionFactoryBuilder, &quot;Property &#39;sqlSessionFactoryBuilder&#39; is required&quot;);</span><br><span class="line">    state((configuration &#x3D;&#x3D; null &amp;&amp; configLocation &#x3D;&#x3D; null) || !(configuration !&#x3D; null &amp;&amp; configLocation !&#x3D; null),</span><br><span class="line">        &quot;Property &#39;configuration&#39; and &#39;configLocation&#39; can not specified with together&quot;);</span><br><span class="line">&#x2F;&#x2F; 这里构建出 一个 sqlSessionFactory工厂来,想想我们最初再看单个MyBatis项目的时候,是不是也有一个获取SqlSessionFactroy的方法,然后从sqlSessionFactory会话中获取出SqlSession来.</span><br><span class="line">    this.sqlSessionFactory &#x3D; buildSqlSessionFactory();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ApplicationListener实现方法</span><br><span class="line">  &#x2F;**</span><br><span class="line">   * failFast 时ture 并且传过来的 event是 ContextRefreshedEvent的话,就会进来.</span><br><span class="line">   *  这里目前都是调用get方法,没有很仔细看出其作用.</span><br><span class="line">   * &#123;@inheritDoc&#125;</span><br><span class="line">   *&#x2F;</span><br><span class="line">  @Override</span><br><span class="line">  public void onApplicationEvent(ApplicationEvent event) &#123;</span><br><span class="line">    if (failFast &amp;&amp; event instanceof ContextRefreshedEvent) &#123;</span><br><span class="line">      &#x2F;&#x2F; fail-fast -&gt; check all statements are completed</span><br><span class="line">      this.sqlSessionFactory.getConfiguration().getMappedStatementNames();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>org.mybatis.spring.SqlSessionFactoryBean#buildSqlSessionFactory</strong></p>
<p>该方法需要单独拿出来说下,因为内容还是比较多的.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Build a &#123;@code SqlSessionFactory&#125; instance.</span><br><span class="line"> *</span><br><span class="line"> * The default implementation uses the standard MyBatis &#123;@code XMLConfigBuilder&#125; API to build a</span><br><span class="line"> * &#123;@code SqlSessionFactory&#125; instance based on a Reader. Since 1.3.0, it can be specified a &#123;@link Configuration&#125;</span><br><span class="line"> * instance directly(without config file).</span><br><span class="line"> *</span><br><span class="line"> * @return SqlSessionFactory</span><br><span class="line"> * @throws Exception</span><br><span class="line"> *           if configuration is failed</span><br><span class="line"> *&#x2F;</span><br><span class="line">protected SqlSessionFactory buildSqlSessionFactory() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">  final Configuration targetConfiguration;</span><br><span class="line"></span><br><span class="line">  XMLConfigBuilder xmlConfigBuilder &#x3D; null;</span><br><span class="line">    </span><br><span class="line"> &#x2F;&#x2F; 这里分为configuration&#x2F; configLocation &#x2F; 非前二者(可以理解为默认的).</span><br><span class="line"> &#x2F;&#x2F; 三种处理方式.   </span><br><span class="line">  if (this.configuration !&#x3D; null) &#123;</span><br><span class="line">    targetConfiguration &#x3D; this.configuration;</span><br><span class="line">    if (targetConfiguration.getVariables() &#x3D;&#x3D; null) &#123;</span><br><span class="line">      targetConfiguration.setVariables(this.configurationProperties);</span><br><span class="line">    &#125; else if (this.configurationProperties !&#x3D; null) &#123;</span><br><span class="line">      targetConfiguration.getVariables().putAll(this.configurationProperties);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else if (this.configLocation !&#x3D; null) &#123;</span><br><span class="line">&#x2F;&#x2F; 这里就是我们配置的情况 </span><br><span class="line">&#x2F;&#x2F; org.apache.ibatis.builder.xml.XMLConfigBuilder#XMLConfigBuilder(java.io.InputStream, java.lang.String, java.util.Properties),可以看到这个熟悉的操作,也就是我们单个解析 MyBatis的时候有进行分析过的.      </span><br><span class="line">    xmlConfigBuilder &#x3D; new XMLConfigBuilder(this.configLocation.getInputStream(), null, this.configurationProperties);</span><br><span class="line">&#x2F;&#x2F; 获取出 configuration 配置信息.      </span><br><span class="line">    targetConfiguration &#x3D; xmlConfigBuilder.getConfiguration();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    LOGGER.debug(</span><br><span class="line">        () -&gt; &quot;Property &#39;configuration&#39; or &#39;configLocation&#39; not specified, using default MyBatis Configuration&quot;);</span><br><span class="line">    targetConfiguration &#x3D; new Configuration();</span><br><span class="line">    Optional.ofNullable(this.configurationProperties).ifPresent(targetConfiguration::setVariables);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这里采用 Optional,如果objectFactory不是null的话,就会调用targetConfiguration的 setObjectFactory方法.下面这二个是同理.</span><br><span class="line">  Optional.ofNullable(this.objectFactory).ifPresent(targetConfiguration::setObjectFactory);</span><br><span class="line">  Optional.ofNullable(this.objectWrapperFactory).ifPresent(targetConfiguration::setObjectWrapperFactory);</span><br><span class="line">  Optional.ofNullable(this.vfs).ifPresent(targetConfiguration::setVfsImpl);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这里如果有配置typeAliasesPackage这个参数的话,就会对该包下进行扫描,进行一系列的过滤,</span><br><span class="line">&#x2F;&#x2F; 如果都满足条件的话,targetConfiguration.getTypeAliasRegistry()::registerAlias就会注册到这里. </span><br><span class="line">  if (hasLength(this.typeAliasesPackage)) &#123;</span><br><span class="line">    scanClasses(this.typeAliasesPackage, this.typeAliasesSuperType).stream()</span><br><span class="line">        .filter(clazz -&gt; !clazz.isAnonymousClass()).filter(clazz -&gt; !clazz.isInterface())</span><br><span class="line">        .filter(clazz -&gt; !clazz.isMemberClass()).forEach(targetConfiguration.getTypeAliasRegistry()::registerAlias);</span><br><span class="line">  &#125;</span><br><span class="line">&#x2F;&#x2F; 是否有typeAliases这个参数,如果有的话,也是可以看到是注册到上面哪一步的里面来.</span><br><span class="line">  if (!isEmpty(this.typeAliases)) &#123;</span><br><span class="line">    Stream.of(this.typeAliases).forEach(typeAlias -&gt; &#123;</span><br><span class="line">      targetConfiguration.getTypeAliasRegistry().registerAlias(typeAlias);</span><br><span class="line">      LOGGER.debug(() -&gt; &quot;Registered type alias: &#39;&quot; + typeAlias + &quot;&#39;&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;判断是否有插件,如果有插件的话,也会添加到configuration中来.    </span><br><span class="line">  if (!isEmpty(this.plugins)) &#123;</span><br><span class="line">    Stream.of(this.plugins).forEach(plugin -&gt; &#123;</span><br><span class="line">      targetConfiguration.addInterceptor(plugin);</span><br><span class="line">      LOGGER.debug(() -&gt; &quot;Registered plugin: &#39;&quot; + plugin + &quot;&#39;&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (hasLength(this.typeHandlersPackage)) &#123;</span><br><span class="line">    scanClasses(this.typeHandlersPackage, TypeHandler.class).stream().filter(clazz -&gt; !clazz.isAnonymousClass())</span><br><span class="line">        .filter(clazz -&gt; !clazz.isInterface()).filter(clazz -&gt; !Modifier.isAbstract(clazz.getModifiers()))</span><br><span class="line">        .forEach(targetConfiguration.getTypeHandlerRegistry()::register);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (!isEmpty(this.typeHandlers)) &#123;</span><br><span class="line">    Stream.of(this.typeHandlers).forEach(typeHandler -&gt; &#123;</span><br><span class="line">      targetConfiguration.getTypeHandlerRegistry().register(typeHandler);</span><br><span class="line">      LOGGER.debug(() -&gt; &quot;Registered type handler: &#39;&quot; + typeHandler + &quot;&#39;&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  targetConfiguration.setDefaultEnumTypeHandler(defaultEnumTypeHandler);</span><br><span class="line"></span><br><span class="line">  if (!isEmpty(this.scriptingLanguageDrivers)) &#123;</span><br><span class="line">    Stream.of(this.scriptingLanguageDrivers).forEach(languageDriver -&gt; &#123;</span><br><span class="line">      targetConfiguration.getLanguageRegistry().register(languageDriver);</span><br><span class="line">      LOGGER.debug(() -&gt; &quot;Registered scripting language driver: &#39;&quot; + languageDriver + &quot;&#39;&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  Optional.ofNullable(this.defaultScriptingLanguageDriver)</span><br><span class="line">      .ifPresent(targetConfiguration::setDefaultScriptingLanguage);</span><br><span class="line"></span><br><span class="line">  if (this.databaseIdProvider !&#x3D; null) &#123;&#x2F;&#x2F; fix #64 set databaseId before parse mapper xmls</span><br><span class="line">    try &#123;</span><br><span class="line">      targetConfiguration.setDatabaseId(this.databaseIdProvider.getDatabaseId(this.dataSource));</span><br><span class="line">    &#125; catch (SQLException e) &#123;</span><br><span class="line">      throw new NestedIOException(&quot;Failed getting a databaseId&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Optional.ofNullable(this.cache).ifPresent(targetConfiguration::addCache);</span><br><span class="line">&#x2F;&#x2F; 这这之前,都是对一些配置信息的读取,如果有的话,就会进行相应的赋值之类的操作.</span><br><span class="line">    </span><br><span class="line">  if (xmlConfigBuilder !&#x3D; null) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">&#x2F;&#x2F; 最后这里的 parse 解析方法,是和单个 Mybatis的解读是一样的.        </span><br><span class="line">      xmlConfigBuilder.parse();</span><br><span class="line">      LOGGER.debug(() -&gt; &quot;Parsed configuration file: &#39;&quot; + this.configLocation + &quot;&#39;&quot;);</span><br><span class="line">    &#125; catch (Exception ex) &#123;</span><br><span class="line">      throw new NestedIOException(&quot;Failed to parse config resource: &quot; + this.configLocation, ex);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;这里可以看事务工厂,是使用了mybatis-spring包下的.</span><br><span class="line">  targetConfiguration.setEnvironment(new Environment(this.environment,</span><br><span class="line">      this.transactionFactory &#x3D;&#x3D; null ? new SpringManagedTransactionFactory() : this.transactionFactory,</span><br><span class="line">      this.dataSource));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这里是处理 mapper.xml 文件的配置,如果在这里是有配置的话,那么也是会被解析到的.    </span><br><span class="line">  if (this.mapperLocations !&#x3D; null) &#123;</span><br><span class="line">    if (this.mapperLocations.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">      LOGGER.warn(() -&gt; &quot;Property &#39;mapperLocations&#39; was specified but matching resources are not found.&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      for (Resource mapperLocation : this.mapperLocations) &#123;</span><br><span class="line">        if (mapperLocation &#x3D;&#x3D; null) &#123;</span><br><span class="line">          continue;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">          XMLMapperBuilder xmlMapperBuilder &#x3D; new XMLMapperBuilder(mapperLocation.getInputStream(),</span><br><span class="line">              targetConfiguration, mapperLocation.toString(), targetConfiguration.getSqlFragments());</span><br><span class="line">          xmlMapperBuilder.parse();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">          throw new NestedIOException(&quot;Failed to parse mapping resource: &#39;&quot; + mapperLocation + &quot;&#39;&quot;, e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">          ErrorContext.instance().reset();</span><br><span class="line">        &#125;</span><br><span class="line">        LOGGER.debug(() -&gt; &quot;Parsed mapper file: &#39;&quot; + mapperLocation + &quot;&#39;&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    LOGGER.debug(() -&gt; &quot;Property &#39;mapperLocations&#39; was not specified.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#x2F;&#x2F;org.apache.ibatis.session.defaults.DefaultSqlSessionFactory,最后到这里也是new了一个mybatis包下的默认SqlSessionFactory类.</span><br><span class="line">  return this.sqlSessionFactoryBuilder.build(targetConfiguration);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到该方法给人感觉, 先是判断一些配置信息是不是有值，如果是有值的话，就会进行相应的处理。最后调用我们在看单个 mybatis 的 parse 解析方法,最后new了一个默认的sqlSessionFactory工厂类出来.</p>
<p><strong>MapperScannerConfigurer(org.mybatis.spring.mapper.MapperScannerConfigurer)</strong></p>
<p>接着看,spring-beans.xml 里面的第二个配置.</p>
<p>可以看到该类，也是实现了 spring 的很多接口.</p>
<p>BeanDefinitionRegistryPostProcessor :  注册BeanDefinition到Spring容器中来.</p>
<p>ApplicationContextAware :  获取 ApplicationContext</p>
<p>BeanNameAware :   设置 beanName名字.</p>
<p>这里也可以按照上面的笨方法，一次对重写的方法打上断点. 然后开启我们的debug来看看方法的执行顺序.</p>
<p>其执行顺序 :   setBeanName   —&gt;  setApplicationContext —&gt;  afterPropertiesSet  —&gt;  postProcessBeanDefinitionRegistry ,  跟着这四个方法执行的顺序来看.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MapperScannerConfigurer</span><br><span class="line">    implements BeanDefinitionRegistryPostProcessor, InitializingBean, ApplicationContextAware, BeanNameAware &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>赋值给 beanName 值.   org.mybatis.spring.mapper.MapperScannerConfigurer#0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void setBeanName(String name) &#123;</span><br><span class="line">  this.beanName &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 然后这里是给到 ApplicationContext. 这也就说这个类现在有了 ApplicationContext,可以根据context提供的api来进行相应的操作.</span><br><span class="line">  @Override</span><br><span class="line">  public void setApplicationContext(ApplicationContext applicationContext) &#123;</span><br><span class="line">    this.applicationContext &#x3D; applicationContext;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 检验配置包的值不能为null.</span><br><span class="line">  @Override</span><br><span class="line">  public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line">    notNull(this.basePackage, &quot;Property &#39;basePackage&#39; is required&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * &#123;@inheritDoc&#125;</span><br><span class="line">   * 可以感受到这个方法, 在拿到了BeanDefinitionRegistry的情况下,往里面注册bd.</span><br><span class="line">   * @since 1.0.2</span><br><span class="line">   *&#x2F;</span><br><span class="line">  @Override</span><br><span class="line">  public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) &#123;</span><br><span class="line">    if (this.processPropertyPlaceHolders) &#123;</span><br><span class="line">      processPropertyPlaceHolders();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这段是创建了一个 ClassPathMapperScanner 对象,然后往里面set属性.      </span><br><span class="line">    ClassPathMapperScanner scanner &#x3D; new ClassPathMapperScanner(registry);</span><br><span class="line">    scanner.setAddToConfig(this.addToConfig);</span><br><span class="line">    scanner.setAnnotationClass(this.annotationClass);</span><br><span class="line">    scanner.setMarkerInterface(this.markerInterface);</span><br><span class="line">    scanner.setSqlSessionFactory(this.sqlSessionFactory);</span><br><span class="line">    scanner.setSqlSessionTemplate(this.sqlSessionTemplate);</span><br><span class="line">    scanner.setSqlSessionFactoryBeanName(this.sqlSessionFactoryBeanName);</span><br><span class="line">    scanner.setSqlSessionTemplateBeanName(this.sqlSessionTemplateBeanName);</span><br><span class="line">    scanner.setResourceLoader(this.applicationContext);</span><br><span class="line">    scanner.setBeanNameGenerator(this.nameGenerator);</span><br><span class="line">    scanner.setMapperFactoryBeanClass(this.mapperFactoryBeanClass);</span><br><span class="line">      </span><br><span class="line">    if (StringUtils.hasText(lazyInitialization)) &#123;</span><br><span class="line">      scanner.setLazyInitialization(Boolean.valueOf(lazyInitialization));</span><br><span class="line">    &#125;</span><br><span class="line">    if (StringUtils.hasText(defaultScope)) &#123;</span><br><span class="line">      scanner.setDefaultScope(defaultScope);</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#x2F;&#x2F; 对register里的信息进行过滤      </span><br><span class="line">    scanner.registerFilters();</span><br><span class="line">&#x2F;&#x2F; org.springframework.context.annotation.ClassPathBeanDefinitionScanner#scan</span><br><span class="line">&#x2F;&#x2F; 这里主要看扫描的方法. 根据,来切割我们写的 basePackage 信息.扫描类的信息,最后还是借用了 org.springframework.context.annotation.ClassPathBeanDefinitionScanner#doScan 来进行扫描的. &#x2F;&#x2F;  doScan(basePackages) 是对 xml 进行扫描的.</span><br><span class="line">&#x2F;&#x2F; AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry); 是对注解进行扫描的.</span><br><span class="line">&#x2F;&#x2F; 最后返回注册到 Spring 容器中的 bean 个数</span><br><span class="line">&#x2F;&#x2F; 所以如果我们配置了下面的标签,那么在这里都会被扫描到并且注册到Spring容器中.</span><br><span class="line">&#x2F;&#x2F;     &lt;bean class&#x3D;&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;</span><br><span class="line">&#x2F;&#x2F;        &lt;property name&#x3D;&quot;basePackage&quot; value&#x3D;&quot;com.iyang.sm.mapper&quot; &gt;&lt;&#x2F;property&gt;</span><br><span class="line">&#x2F;&#x2F;    &lt;&#x2F;bean&gt;</span><br><span class="line">&#x2F;&#x2F; 这里需要注意的是:  org.mybatis.spring.mapper.ClassPathMapperScanner#processBeanDefinitions</span><br><span class="line">&#x2F;&#x2F;   definition.setBeanClass(this.mapperFactoryBeanClass);  这里的这行代码,是给bd的beanClass给换成了 MapperFactoryBean.class , </span><br><span class="line">&#x2F;&#x2F;  definition.getConstructorArgumentValues().addGenericArgumentValue(beanClassName);     &#x2F;&#x2F; 这句代码,将 beanClassName 给到 db之后, 然后就才用 beanClassName来new一个 MapperFactoryBean 对象来, 所以这里并不是使用无参构造函数.</span><br><span class="line">&#x2F;&#x2F; 也许会问,怎么证实没有走无参数构造函数呢 ? 而是去走的 set 方法呢 ? </span><br><span class="line">&#x2F;&#x2F; 再不能动源码的情况下, 面对这种情况情况最好的办法就是, 在无参构造函数上打上断点.</span><br><span class="line">&#x2F;&#x2F; 如果没走到断点上,那就说明不是走的无参构造函数来初始化的.      </span><br><span class="line">    scanner.scan(</span><br><span class="line">        StringUtils.tokenizeToStringArray(this.basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>所以到这里, 可以看到 MyBatis 与 Spring 整合的过程就已经完成了.</p>
<p>我们这里是主要对 SqlSessionFactoryBean 和 MapperScannerConfigurer 来进行分析的,  可以很明显的感觉到,我们是配置好这二个bean后,就可以使用了.  着重看第二个,   org.mybatis.spring.mapper.MapperScannerConfigurer 这个bean,就是做了如何将 MyBatis 的 mapper接口文件给加载到 Spring 中来的.   <strong>那么这里我在想, 如果有天我自己开发出一个好用的框架来,要与 Spring 进行整合的话,是不是也这样整合就可以了？</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 配置sqlSessionFactory，SqlSessionFactoryBean是用来产生sqlSessionFactory的 --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;sqlSessionFactory&quot; class&#x3D;&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;</span><br><span class="line">    &lt;!-- 加载mybatis的全局配置文件，放在classpath下的mybatis文件夹中了 --&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;configLocation&quot; value&#x3D;&quot;mybatis&#x2F;SqlMapConfig.xml&quot; &#x2F;&gt;</span><br><span class="line">    &lt;!-- 加载数据源，使用上面配置好的数据源 --&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--  配置扫描 MyBatis 接口的包 --&gt;</span><br><span class="line">&lt;bean class&#x3D;&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;basePackage&quot; value&#x3D;&quot;com.iyang.sm.mapper&quot; &gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<h4 id="-2"><a href="#-2" class="headerlink" title=""></a></h4><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​    可以看到  MyBatis 与 Spring 整合后,  对于解析 MyBatis 的 mapper  配置文件等，都是走的之前单个 mybatis 的逻辑, 是没有什么变化的.   主要的是将 , SqlSessionFactory 和  Mapper.class(接口类) 给注入到 Spring 容器中.然后接口的话, 是怎么使用的代理类来进行实例化完后, 将对象给注入到  Spring 容器中的呢 ？ 这里看  org.mybatis.spring.mapper.MapperScannerConfigurer  做的事情就明白了.</p>
<p>​    不过在看 mybatis 与 Spring 整合的时候, 还是建议要有对  BeanDefinitionRegistryPostProcessor  /  InitializingBean /   ApplicationContextAware  /  BeanNameAware 有一定的了接.  就是有了了解后, 你就会很明显的感受到，  mybatis 为什么是实现这个接口，实现这个接口并且重写这个方法，在后面是什么时候被调用的. 意思也就是，你至少得明白点 Spring  对外提供的一些扩展点，才能很好的理解这些东西.</p>
]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>Java源码</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis-config-xml-read</title>
    <url>/2020/12/25/mybatis/mybatis-config-xml-read/</url>
    <content><![CDATA[<h4 id="题记"><a href="#题记" class="headerlink" title="题记"></a>题记</h4><p> 对于配置文件的解析, 还是相对比较好理解的, 就是读取配置文件, 然后在代码需要的地方给使用到.</p>
<p> 这里,可以扩展下, Spring / SpringBoot 等是怎么读取配置文件呢 ? 并且配置文件还是有 xml / properties/yaml 等格式的 ， 其读取代码是怎么写的 ? 然后基于 阿波罗(携程开源) 的配置中心 , 其实现配置又是怎么实现的呢 ? 然后这里，看了 Mybatis 读取配置文件, 后续再出 Spring 配置文件的时候，如果二者读取配置进行对比, 你个人更倾向使用代码呢 ?</p>
<p> 所以,这里就开启读取 Mybatis 是如何解析配置文件的操作.</p>
<h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p> 这里的配置文件解读,是根据 MyBatis官网来一步一步的解析阅读. 如果有官网没有涉及到的,发现了也会在后续加上去的. 解析多行代码, 才能理解 何为优秀.</p>
<p> <strong>标签一 : properties</strong></p>
<p> org.apache.ibatis.builder.xml.XMLConfigBuilder#parseConfiguration —&gt; propertiesElement(root.evalNode(“properties”)) 方法中来.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 这里传入进来的 XNode 的值,就是我们写的 properties 标签.</span><br><span class="line">&#x2F;&#x2F; 可以看到 XNode的属性,name标签的名字,attributes就是key&#x2F;value属性</span><br><span class="line">&#x2F;&#x2F; 比如这里: key 就是 resource , value 就是 .&#x2F;db.properties.</span><br><span class="line">private void propertiesElement(XNode context) throws Exception &#123;</span><br><span class="line">  if (context !&#x3D; null) &#123;</span><br><span class="line">&#x2F;&#x2F; 这里调用的node.getChildNodes(),如果有点话,会遍历挨个解析,最后封装成为key&#x2F;value结构.      </span><br><span class="line">    Properties defaults &#x3D; context.getChildrenAsProperties();</span><br><span class="line">&#x2F;&#x2F; 获取 resource &#x2F; url 二者的值.      </span><br><span class="line">    String resource &#x3D; context.getStringAttribute(&quot;resource&quot;);</span><br><span class="line">    String url &#x3D; context.getStringAttribute(&quot;url&quot;);</span><br><span class="line">&#x2F;&#x2F; 如果二者都是null,就会抛出异常来.      </span><br><span class="line">    if (resource !&#x3D; null &amp;&amp; url !&#x3D; null) &#123;</span><br><span class="line">      throw new BuilderException(&quot;The properties element cannot specify both a URL and a resource based property file reference.  Please specify one or the other.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line"> &#x2F;&#x2F; 这里先处理resource,再处理url,也就是有可能url会覆盖掉resource的内容.</span><br><span class="line"> &#x2F;&#x2F; 二者读取的方式不一样,前者是根据 resource开始读,url是根据绝对路径开始读.</span><br><span class="line"> &#x2F;&#x2F; 最后 defaults 里面放入的全部是 key&#x2F;value 对应的键值对</span><br><span class="line"> &#x2F;&#x2F; 也就是db.properties中的 key &#x2F; value 相对应i起来.     </span><br><span class="line">    if (resource !&#x3D; null) &#123;</span><br><span class="line">      defaults.putAll(Resources.getResourceAsProperties(resource));</span><br><span class="line">    &#125; else if (url !&#x3D; null) &#123;</span><br><span class="line">      defaults.putAll(Resources.getUrlAsProperties(url));</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F; 这里看的是 xml 里面是不是直接有 porperties 配置.     </span><br><span class="line">&#x2F;&#x2F; 如果有的话,就会putAll进去.      </span><br><span class="line">    Properties vars &#x3D; configuration.getVariables();</span><br><span class="line">    if (vars !&#x3D; null) &#123;</span><br><span class="line">      defaults.putAll(vars);</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F; 最后吧 defaults,也就是properties给放入到 BaseBuilder 和 Confifuration中去.      </span><br><span class="line">    parser.setVariables(defaults);</span><br><span class="line">    configuration.setVariables(defaults);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----------------------------</span><br><span class="line">&#x2F;&#x2F;  如何让 Properties vars &#x3D; configuration.getVariables(); 有值呢 ?</span><br><span class="line">&#x2F;&#x2F;  如果只是单个的 MyBatis 项目的话, 就自己手动new一个properties对象</span><br><span class="line">&#x2F;&#x2F;  然后key输入自己要覆盖掉的key就可以了</span><br><span class="line">        Properties dbConfigProperties &#x3D; new Properties();</span><br><span class="line">        dbConfigProperties.setProperty(&quot;jdbc.password&quot;,&quot;GavinYang&quot;);</span><br><span class="line"></span><br><span class="line">        SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(mybatisInputStream,dbConfigProperties);</span><br></pre></td></tr></table></figure>

<p> <strong>标签二 : settings</strong></p>
<p> 这是 MyBatis对 settings 的操作.</p>
<p> 具体的 settings 中每项配置参考官网链接 : <a href="https://mybatis.org/mybatis-3/configuration.html#properties" target="_blank" rel="noopener">https://mybatis.org/mybatis-3/configuration.html#properties</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 解析 setting ---&gt; 转化为 key &#x2F;value</span><br><span class="line">Properties settings &#x3D; settingsAsProperties(root.evalNode(&quot;settings&quot;));</span><br><span class="line">&#x2F;&#x2F; </span><br><span class="line">loadCustomVfs(settings);</span><br><span class="line">loadCustomLogImpl(settings);</span><br></pre></td></tr></table></figure>

<p>settingsAsProperties 方法</p>
<p> 可以看到, 该方法就是进行加载,转化为key/value键值对类型, 然后对其key检验是否在</p>
<p> Configuration 中都有 set 方法.</p>
<p>Notes : 为了验证下, 我们加上一个没有的标签, 可以看到下面的异常. 所以我们看到这种异常的时候，是可以去检查下是不是名字什么有问题.</p>
<h3 id="Cause-org-apache-ibatis-builder-BuilderException-Error-parsing-SQL-Mapper-Configuration-Cause-org-apache-ibatis-builder-BuilderException-The-setting-nnnnn-is-not-known-Make-sure-you-spelled-it-correctly-case-sensitive"><a href="#Cause-org-apache-ibatis-builder-BuilderException-Error-parsing-SQL-Mapper-Configuration-Cause-org-apache-ibatis-builder-BuilderException-The-setting-nnnnn-is-not-known-Make-sure-you-spelled-it-correctly-case-sensitive" class="headerlink" title="Cause: org.apache.ibatis.builder.BuilderException: Error parsing SQL Mapper Configuration. Cause: org.apache.ibatis.builder.BuilderException: The setting nnnnn is not known. Make sure you spelled it correctly (case sensitive)."></a>Cause: org.apache.ibatis.builder.BuilderException: Error parsing SQL Mapper Configuration. Cause: org.apache.ibatis.builder.BuilderException: The setting nnnnn is not known. Make sure you spelled it correctly (case sensitive).</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private Properties settingsAsProperties(XNode context) &#123;</span><br><span class="line">  if (context &#x3D;&#x3D; null) &#123;</span><br><span class="line">    return new Properties();</span><br><span class="line">  &#125;</span><br><span class="line"> &#x2F;&#x2F; 对 settings 下的 setting 进行解析 并且 转化为 key &#x2F; value 操作.   </span><br><span class="line">  Properties props &#x3D; context.getChildrenAsProperties();</span><br><span class="line">  &#x2F;&#x2F; Check that all settings are known to the configuration class</span><br><span class="line"> &#x2F;&#x2F; 对 Configuration 进行校验, 确认上面的 props 中的key 在 Configuration</span><br><span class="line">&#x2F;&#x2F; 中是都有set 方法的,目测是后面反射需要使用到.    </span><br><span class="line">  MetaClass metaConfig &#x3D; MetaClass.forClass(Configuration.class, localReflectorFactory);</span><br><span class="line">  for (Object key : props.keySet()) &#123;</span><br><span class="line">    if (!metaConfig.hasSetter(String.valueOf(key))) &#123;</span><br><span class="line">      throw new BuilderException(&quot;The setting &quot; + key + &quot; is not known.  Make sure you spelled it correctly (case sensitive).&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return props;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>loadCustomVfs(settings) 方法</p>
<p>该方法,主要就是读取 vfsImpl 对用的value,切割下,然后用 classForName 来获取 class,</p>
<p>最后赋值到 configuration 中去. 这里算是对 vfs 的一种自定义的扩展,虽然目前还不太清楚vfs具体作用.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void loadCustomVfs(Properties props) throws ClassNotFoundException &#123;</span><br><span class="line">  &#x2F;&#x2F; 获取 vfsImpl 的 value.  </span><br><span class="line">  String value &#x3D; props.getProperty(&quot;vfsImpl&quot;);</span><br><span class="line">  if (value !&#x3D; null) &#123;</span><br><span class="line">   &#x2F;&#x2F; 根据 , 进行切割.   </span><br><span class="line">    String[] clazzes &#x3D; value.split(&quot;,&quot;);</span><br><span class="line">    for (String clazz : clazzes) &#123;</span><br><span class="line">      if (!clazz.isEmpty()) &#123;</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        &#x2F;&#x2F; 反射,获取出 Class , 最后赋值到 configuration 中去.  </span><br><span class="line">        Class&lt;? extends VFS&gt; vfsImpl &#x3D; (Class&lt;? extends VFS&gt;)Resources.classForName(clazz);</span><br><span class="line">        configuration.setVfsImpl(vfsImpl);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>loadCustomLogImpl(settings) 方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void loadCustomLogImpl(Properties props) &#123;</span><br><span class="line">  Class&lt;? extends Log&gt; logImpl &#x3D; resolveClass(props.getProperty(&quot;logImpl&quot;));</span><br><span class="line">  &#x2F;&#x2F; 将 log set 到 configuration 中去.  </span><br><span class="line">  configuration.setLogImpl(logImpl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-----------------------</span><br><span class="line">&#x2F;&#x2F; resolve 最后如果不是 null 的话,</span><br><span class="line">org.apache.ibatis.type.TypeAliasRegistry#resolveAlias</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F; 就会走到这里,这里可以看先是在 typeAliases(HashMap) 中判断下,如果存在就直接获取</span><br><span class="line">&#x2F;&#x2F; 如果不存在就用 Resources.ClassForName来操作</span><br><span class="line">&#x2F;&#x2F; 这里的 HashMap就类似于,记录之前是否已经加载了或者预热.</span><br><span class="line">&#x2F;&#x2F; 如果是用来做cache的话, 那就应该最后会在 return 之前继续把值给放入进去.    </span><br><span class="line">  public &lt;T&gt; Class&lt;T&gt; resolveAlias(String string) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      if (string &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; issue #748</span><br><span class="line">      String key &#x3D; string.toLowerCase(Locale.ENGLISH);</span><br><span class="line">      Class&lt;T&gt; value;</span><br><span class="line">      if (typeAliases.containsKey(key)) &#123;</span><br><span class="line">        value &#x3D; (Class&lt;T&gt;) typeAliases.get(key);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        value &#x3D; (Class&lt;T&gt;) Resources.classForName(string);</span><br><span class="line">      &#125;</span><br><span class="line">      return value;</span><br><span class="line">    &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">      throw new TypeException(&quot;Could not resolve type alias &#39;&quot; + string + &quot;&#39;.  Cause: &quot; + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">&#x2F;&#x2F; 如果我们在配置文件中没有定义的话,这里默认是null,也就是说不会set进去.    </span><br><span class="line">  public void setLogImpl(Class&lt;? extends Log&gt; logImpl) &#123;</span><br><span class="line">    if (logImpl !&#x3D; null) &#123;</span><br><span class="line">      this.logImpl &#x3D; logImpl;</span><br><span class="line">      LogFactory.useCustomLogging(this.logImpl);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>标签三 :</strong></p>
<p> 关于别名的配置.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typeAliasesElement(root.evalNode(&quot;typeAliases&quot;));</span><br><span class="line">private void typeAliasesElement(XNode parent) &#123;</span><br><span class="line">  if (parent !&#x3D; null) &#123;</span><br><span class="line">   &#x2F;&#x2F; 对 typeAliases 下的子标签进行迭代.</span><br><span class="line">   &#x2F;&#x2F; 分为是 package 和非 package   </span><br><span class="line">    for (XNode child : parent.getChildren()) &#123;</span><br><span class="line">      if (&quot;package&quot;.equals(child.getName())) &#123;</span><br><span class="line">       &#x2F;&#x2F; 获取你输入的包   </span><br><span class="line">        String typeAliasPackage &#x3D; child.getStringAttribute(&quot;name&quot;);</span><br><span class="line">        configuration.getTypeAliasRegistry().registerAliases(typeAliasPackage);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line"> &#x2F;&#x2F; &lt;typeAlias type&#x3D;&quot;com.iyang.mybatis.pojo.TbBlog&quot; alias&#x3D;&quot;TbBlog&quot; &#x2F;&gt;</span><br><span class="line"> &#x2F;&#x2F; 这里就是对这种进行解析的         </span><br><span class="line">        String alias &#x3D; child.getStringAttribute(&quot;alias&quot;);</span><br><span class="line">        String type &#x3D; child.getStringAttribute(&quot;type&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">          Class&lt;?&gt; clazz &#x3D; Resources.classForName(type);</span><br><span class="line">   &#x2F;&#x2F; 如果没写别名,就只传入 clazz.         </span><br><span class="line">          if (alias &#x3D;&#x3D; null) &#123;</span><br><span class="line">            typeAliasRegistry.registerAlias(clazz);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">   &#x2F;&#x2F; 写了别名,就别名和clazz一起传入进来.           </span><br><span class="line">            typeAliasRegistry.registerAlias(alias, clazz);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">          throw new BuilderException(&quot;Error registering typeAlias for &#39;&quot; + alias + &quot;&#39;. Cause: &quot; + e, e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----------------</span><br><span class="line">&#x2F;&#x2F; 这里可以看到是根据 packageName 来 register进来的.    </span><br><span class="line">  public void registerAliases(String packageName, Class&lt;?&gt; superType) &#123;</span><br><span class="line">    &#x2F;&#x2F; new 一个解析器工具类</span><br><span class="line">    ResolverUtil&lt;Class&lt;?&gt;&gt; resolverUtil &#x3D; new ResolverUtil&lt;&gt;();</span><br><span class="line">    &#x2F;&#x2F; 获取包的path,然后获取该包下的文件,如果文件是.class结尾的话</span><br><span class="line">    &#x2F;&#x2F; 最后在 ResolverUtil 中matchess是有该包下的全名称.</span><br><span class="line">    resolverUtil.find(new ResolverUtil.IsA(superType), packageName);</span><br><span class="line">    &#x2F;&#x2F; 这里返回的是上一步说的 matches</span><br><span class="line">    Set&lt;Class&lt;? extends Class&lt;?&gt;&gt;&gt; typeSet &#x3D; resolverUtil.getClasses();</span><br><span class="line">    for (Class&lt;?&gt; type : typeSet) &#123;</span><br><span class="line">      &#x2F;&#x2F; Ignore inner classes and interfaces (including package-info.java)</span><br><span class="line">      &#x2F;&#x2F; Skip also inner classes. See issue #6</span><br><span class="line">      &#x2F;&#x2F; 如果不是接口,不是内部类等条件的话,就走  registerAlias 方法</span><br><span class="line">      if (!type.isAnonymousClass() &amp;&amp; !type.isInterface() &amp;&amp; !type.isMemberClass()) &#123;</span><br><span class="line"> &#x2F;&#x2F; 先获取类名字,判断该类上有没有 @Alias 注解,如果有注解的话,就用注解的值作为缩写的.</span><br><span class="line"> &#x2F;&#x2F; 最后判断是不是null,是null就会抛出异常来.最后将上面获取出来的缩写名字,转化为大写.</span><br><span class="line"> &#x2F;&#x2F; 如果此时 typeAliases 是已经有了该值的话,就会抛出异常来.否则就放入到typeAliases来</span><br><span class="line"> &#x2F;&#x2F; private final Map&lt;String, Class&lt;?&gt;&gt; typeAliases &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"> &#x2F;&#x2F; 可以看到 typeAliases 是一个HashMap,并且其存储的Key&#x2F;Value还是蛮明显的.         </span><br><span class="line">        registerAlias(type);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>标签四</strong></p>
<p> 扩展的 demo 可以参考 MyBatis官网 : <a href="https://mybatis.org/mybatis-3/configuration.html" target="_blank" rel="noopener">https://mybatis.org/mybatis-3/configuration.html</a></p>
<p> 然后看 MyBatis 是如何将插件给利用上的呢 ?</p>
<p> 首先在 mybatis-config.xml 中配置好我们自己定义的 plugin</p>
<p> 这里以我配置了二个插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;plugins&gt;</span><br><span class="line">    &lt;plugin interceptor&#x3D;&quot;com.iyang.mybatis.plugins.ExamplePlugin&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;GavinYang&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;age&quot; value&#x3D;&quot;22&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;hobby&quot; value&#x3D;&quot;lwf&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;plugin&gt;</span><br><span class="line"></span><br><span class="line">    &lt;plugin interceptor&#x3D;&quot;com.iyang.mybatis.plugins.QuerySqlPlugin&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;GavinYang&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;plugin&gt;</span><br><span class="line">&lt;&#x2F;plugins&gt;</span><br></pre></td></tr></table></figure>

<p>// 处理 plugin 的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void pluginElement(XNode parent) throws Exception &#123;</span><br><span class="line">  &#x2F;&#x2F; 这里传入进来的就是 &lt;plugins&gt;整个标签内容.  </span><br><span class="line">  if (parent !&#x3D; null) &#123;</span><br><span class="line">   &#x2F;&#x2F; 获取 &lt;plugins&gt; 下的 &lt;plugin&gt; 集合,进行迭代处理.   </span><br><span class="line">    for (XNode child : parent.getChildren()) &#123;</span><br><span class="line">     &#x2F;&#x2F; 获取插件的 全限定名字.   </span><br><span class="line">      String interceptor &#x3D; child.getStringAttribute(&quot;interceptor&quot;);</span><br><span class="line">     &#x2F;&#x2F; 获取我们定义在 plugin 下的 properties.   </span><br><span class="line">      Properties properties &#x3D; child.getChildrenAsProperties();</span><br><span class="line">&#x2F;&#x2F; resolveClass是最后注册到typeAliasRegistry来.    </span><br><span class="line">&#x2F;&#x2F; 实例化,这里就可以看到我们在定义的Plugin中,无参构造函数打印出来的内容了.        </span><br><span class="line">      Interceptor interceptorInstance &#x3D; (Interceptor) resolveClass(interceptor).getDeclaredConstructor().newInstance();</span><br><span class="line">&#x2F;&#x2F; 将 properties 赋值给  interceptorInstance</span><br><span class="line">&#x2F;&#x2F; 也就是放入到 interceptorInstance 来.        </span><br><span class="line">      interceptorInstance.setProperties(properties);</span><br><span class="line">&#x2F;&#x2F; org.apache.ibatis.plugin.InterceptorChain</span><br><span class="line">&#x2F;&#x2F; 这是是将interceptorInstance添加到InterceptorChain的interceptors中来.        </span><br><span class="line">      configuration.addInterceptor(interceptorInstance);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 可以看到 MyBatis在加载plugin的时候,是利用了反射来new出一个对象来,并且注册到 typeAliasRegistry 中来. 这里主要是解析 plugin 的配置, 后面在执行sql的时候,都是如何使用到这些 plugin 的呢 ? 肯定是有一个从InterceptorChain中获取interceptors来,然后进行处理.</p>
<p><strong>标签五 : &lt; objectFactory &gt;</strong></p>
<p>objectFactory 的处理方式是和 标签四相似的,只是最后在使用场景是有点不同的.</p>
<p>代码上的操作也是类似的.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void objectFactoryElement(XNode context) throws Exception &#123;</span><br><span class="line">  if (context !&#x3D; null) &#123;</span><br><span class="line">    String type &#x3D; context.getStringAttribute(&quot;type&quot;);</span><br><span class="line">    Properties properties &#x3D; context.getChildrenAsProperties();</span><br><span class="line">    ObjectFactory factory &#x3D; (ObjectFactory) resolveClass(type).getDeclaredConstructor().newInstance();</span><br><span class="line">    factory.setProperties(properties);</span><br><span class="line">    configuration.setObjectFactory(factory);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>标签五 :</strong></p>
<p>该标签在 MyBatis 官网是没有demo, 我是根据代码来顺藤摸瓜写的一个.</p>
<p> 参考 : org.apache.ibatis.reflection.wrapper.DefaultObjectWrapperFactory 这个源码,来模仿写的一个.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objectWrapperFactoryElement(root.evalNode(&quot;objectWrapperFactory&quot;));</span><br><span class="line">private void objectWrapperFactoryElement(XNode context) throws Exception &#123;</span><br><span class="line">  if (context !&#x3D; null) &#123;</span><br><span class="line">   &#x2F;&#x2F; 获取 配置文件中的type值   </span><br><span class="line">    String type &#x3D; context.getStringAttribute(&quot;type&quot;);</span><br><span class="line"> &#x2F;&#x2F; 先注册到  typeAliasRegistry 来,然后实例化这个类.</span><br><span class="line"> &#x2F;&#x2F; 我们在自己定义的类中,写一个无参构造函数,就可以看到我们打印的内容了.     </span><br><span class="line">    ObjectWrapperFactory factory &#x3D; (ObjectWrapperFactory) resolveClass(type).getDeclaredConstructor().newInstance();</span><br><span class="line">&#x2F;&#x2F; 最后赋值到 confifuration 中来.      </span><br><span class="line">    configuration.setObjectWrapperFactory(factory);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>标签六 : &lt; reflectorFactory &gt;</strong></p>
<p>处理方式和上面类似.</p>
<p>这里我们自己写一个 com.iyang.mybatis.factory.GavinReflectorFactory 来继承DefaultReflectorFactory,在无参数构造函数中打印下内容, 然后debug跟进.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void reflectorFactoryElement(XNode context) throws Exception &#123;</span><br><span class="line">  if (context !&#x3D; null) &#123;</span><br><span class="line">    String type &#x3D; context.getStringAttribute(&quot;type&quot;);</span><br><span class="line">    ReflectorFactory factory &#x3D; (ReflectorFactory) resolveClass(type).getDeclaredConstructor().newInstance();</span><br><span class="line">    configuration.setReflectorFactory(factory);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>标签七 :</strong></p>
<p>environments 标签都是放入一些 db 的配置信息等.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;environments default&#x3D;&quot;development&quot;&gt;</span><br><span class="line">    &lt;environment id&#x3D;&quot;development&quot;&gt;</span><br><span class="line">        &lt;!-- 事务 --&gt;</span><br><span class="line">        &lt;transactionManager type&#x3D;&quot;JDBC&quot;&#x2F;&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;!-- DB 连接配置 --&gt;</span><br><span class="line">        &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;$&#123;jdbc.driver&#125;&quot; &#x2F;&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;jdbc.url&#125;&quot; &#x2F;&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;username&quot; value &#x3D; &quot;$&#123;jdbc.username&#125;&quot; &#x2F;&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;jdbc.password&#125;&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;dataSource&gt;</span><br><span class="line">    &lt;&#x2F;environment&gt;</span><br><span class="line">&lt;&#x2F;environments&gt;</span><br><span class="line">private void environmentsElement(XNode context) throws Exception &#123;</span><br><span class="line">  if (context !&#x3D; null) &#123;</span><br><span class="line">    if (environment &#x3D;&#x3D; null) &#123;</span><br><span class="line">&#x2F;&#x2F; 获取 default 对应字段的值         </span><br><span class="line">      environment &#x3D; context.getStringAttribute(&quot;default&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F; 这里的 getChildren 获取的是 &lt;environments&gt; --&gt; &lt;environment&gt;下的子标签      </span><br><span class="line">    for (XNode child : context.getChildren()) &#123;</span><br><span class="line">      String id &#x3D; child.getStringAttribute(&quot;id&quot;);</span><br><span class="line">&#x2F;&#x2F; 确保 id 和  上一步的environment 的值是相同的,就会返回true.      </span><br><span class="line">      if (isSpecifiedEnvironment(id)) &#123;</span><br><span class="line">&#x2F;**</span><br><span class="line">*  获取出 transactionManager 对应的标签.</span><br><span class="line">*  然后根据 JBDC(配置文件中的值),然后从 typeAliasRegistry中获取出来，</span><br><span class="line">*  调用反射来 实例化 这个对象. </span><br><span class="line">*  最后还是可以配置 properties,会被set到txFactory中去的.</span><br><span class="line">*  但是 JdbcTransactionFactory 好像没有重写 setProperties 方法.</span><br><span class="line">*&#x2F;          </span><br><span class="line">        TransactionFactory txFactory &#x3D; transactionManagerElement(child.evalNode(&quot;transactionManager&quot;));</span><br><span class="line">&#x2F;&#x2F; 先获取  dataSource 字段</span><br><span class="line">&#x2F;**</span><br><span class="line">*  先获取type的值,然后再获取 properties的标签字段值.</span><br><span class="line">*  根据我们的配置 : org.apache.ibatis.datasource.pooled.PooledDataSourceFactory,应该会获取出这个对象.该对象其内部是有一个,org.apache.ibatis.datasource.pooled.PooledDataSource的,里面有部分默认值的.</span><br><span class="line">*最后将  properties 调用 org.apache.ibatis.datasource.unpooled.UnpooledDataSourceFactory#setProperties方法,</span><br><span class="line">最后是将 properties 里面的key&#x2F;value 都设置到 MetaObject metaDataSource &#x3D; SystemMetaObject.forObject(dataSource);来了.</span><br><span class="line">*&#x2F;</span><br><span class="line">        DataSourceFactory dsFactory &#x3D; dataSourceElement(child.evalNode(&quot;dataSource&quot;));</span><br><span class="line">&#x2F;&#x2F; 从  PooledDataSourceFactory 中获取 datasource 属性.         </span><br><span class="line">        DataSource dataSource &#x3D; dsFactory.getDataSource();</span><br><span class="line">&#x2F;&#x2F; 这里采用链式编程,也就是将id&#x2F;txFactory&#x2F;dataSource 都给set到 Environment.Builder来了.         </span><br><span class="line">        Environment.Builder environmentBuilder &#x3D; new Environment.Builder(id)</span><br><span class="line">            .transactionFactory(txFactory)</span><br><span class="line">            .dataSource(dataSource);</span><br><span class="line">  &#x2F;&#x2F;    environmentBuilder.build() 也就是new 了一个 Environment </span><br><span class="line">  &#x2F;&#x2F; 最后 赋值到 configuration 中来了.        </span><br><span class="line">        configuration.setEnvironment(environmentBuilder.build());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 解析 environments ,利用 typeAliasRegistry 中已经注册好了的信息,然后根据名字缩写(比如JDBC)这种,来获取class对象, 用 反射来 new 一波对象出来,真是美滋滋. 接着就是解析 事务/JDBC连接配置信息等, 最后将信息保存到 DataSource 中来. 反手再来一波 链式编程 来new对象出来, 最后就是一个 Environment 对象出来,给set 到 configuration 中来.</p>
<p><strong>标签八</strong></p>
<p> 到这里,可以看到对xml的解析操作. 先解析 标签 的值出来,然后根据值进行分类处理或者根据自己的需求来进行处理.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void typeHandlerElement(XNode parent) &#123;</span><br><span class="line">  if (parent !&#x3D; null) &#123;</span><br><span class="line">    for (XNode child : parent.getChildren()) &#123;</span><br><span class="line">      &#x2F;&#x2F; 如果子标签是 package   </span><br><span class="line">      if (&quot;package&quot;.equals(child.getName())) &#123;</span><br><span class="line">       &#x2F;&#x2F; 获取出 name 对应的值.   </span><br><span class="line">        String typeHandlerPackage &#x3D; child.getStringAttribute(&quot;name&quot;);</span><br><span class="line">      &#x2F;&#x2F; 注册到   typeHandlerRegistry 中来.  </span><br><span class="line">        typeHandlerRegistry.register(typeHandlerPackage);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line"> &#x2F;&#x2F; 这里获取出三种值来,   javaType&#x2F;jdbcType&#x2F;  handler    </span><br><span class="line">        String javaTypeName &#x3D; child.getStringAttribute(&quot;javaType&quot;);</span><br><span class="line">        String jdbcTypeName &#x3D; child.getStringAttribute(&quot;jdbcType&quot;);</span><br><span class="line">        String handlerTypeName &#x3D; child.getStringAttribute(&quot;handler&quot;);</span><br><span class="line">        Class&lt;?&gt; javaTypeClass &#x3D; resolveClass(javaTypeName);</span><br><span class="line">        JdbcType jdbcType &#x3D; resolveJdbcType(jdbcTypeName);</span><br><span class="line">        Class&lt;?&gt; typeHandlerClass &#x3D; resolveClass(handlerTypeName);</span><br><span class="line">  &#x2F;&#x2F; 分为  javaTypeClass 是不是 null 的情况       </span><br><span class="line">        if (javaTypeClass !&#x3D; null) &#123;</span><br><span class="line">         &#x2F;&#x2F; 基于 javaTypeClass 是不是 null的情况,再判断 jdbcType 是不是null  </span><br><span class="line">          if (jdbcType &#x3D;&#x3D; null) &#123;</span><br><span class="line">            typeHandlerRegistry.register(javaTypeClass, typeHandlerClass);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            typeHandlerRegistry.register(javaTypeClass, jdbcType, typeHandlerClass);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">&#x2F;&#x2F; 这是根据   handlerTypeName 注册到 typeHandlerRegistry 中来.           </span><br><span class="line">          typeHandlerRegistry.register(typeHandlerClass);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>标签九 :</strong></p>
<p> 该标签是对我们对应的对象,其sql语句存放的地址. 也就是里面放入的是于mapper接口对应的方法,查询的sql语句.</p>
<p> 接下来看下 MyBatis 是对 mappers 标签的内容进行了说明解析和处理.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mapperElement</span><span class="params">(XNode parent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">      </span><br><span class="line"> <span class="comment">// getChildren 获取的是 mappers 下的 mapper 标签</span></span><br><span class="line">    <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123;</span><br><span class="line"><span class="comment">// 如果配置的是 package.        </span></span><br><span class="line">      <span class="keyword">if</span> (<span class="string">"package"</span>.equals(child.getName())) &#123;</span><br><span class="line">        String mapperPackage = child.getStringAttribute(<span class="string">"name"</span>);</span><br><span class="line">        configuration.addMappers(mapperPackage);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 获取出    resource/url/class 这三类的值.       </span></span><br><span class="line">        String resource = child.getStringAttribute(<span class="string">"resource"</span>);</span><br><span class="line">        String url = child.getStringAttribute(<span class="string">"url"</span>);</span><br><span class="line">        String mapperClass = child.getStringAttribute(<span class="string">"class"</span>);</span><br><span class="line"> <span class="comment">// 对 resource 处理         </span></span><br><span class="line">        <span class="keyword">if</span> (resource != <span class="keyword">null</span> &amp;&amp; url == <span class="keyword">null</span> &amp;&amp; mapperClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 将 resource 赋值给 ErrorContext 中  </span></span><br><span class="line">          ErrorContext.instance().resource(resource);</span><br><span class="line">     <span class="comment">// 读取文件.       </span></span><br><span class="line">          InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line"><span class="comment">// 使用 XMLMapperBuilder 来对解析xml内容.            </span></span><br><span class="line">          XMLMapperBuilder mapperParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());</span><br><span class="line">          mapperParser.parse();</span><br><span class="line"><span class="comment">// url 处理            </span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="keyword">null</span> &amp;&amp; url != <span class="keyword">null</span> &amp;&amp; mapperClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">          ErrorContext.instance().resource(url);</span><br><span class="line">          InputStream inputStream = Resources.getUrlAsStream(url);</span><br><span class="line">          XMLMapperBuilder mapperParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments());</span><br><span class="line">          mapperParser.parse();</span><br><span class="line"><span class="comment">// mapperClass 处理            </span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="keyword">null</span> &amp;&amp; url == <span class="keyword">null</span> &amp;&amp; mapperClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">          Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass);</span><br><span class="line">          configuration.addMapper(mapperInterface);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"A mapper element may only specify a url, resource or class, but not more than one."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----------------------</span><br><span class="line"><span class="comment">// 这里我们跟进 mapperParser.parse() 方法来</span></span><br><span class="line"><span class="comment">// org.apache.ibatis.builder.xml.XMLMapperBuilder</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 判断 configuration 的 loadedResources 是否含有该值,如果不含有的话,就会去解析.  </span></span><br><span class="line">    <span class="keyword">if</span> (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line"><span class="comment">// 对mapper 标签进行解析        </span></span><br><span class="line">      configurationElement(parser.evalNode(<span class="string">"/mapper"</span>));</span><br><span class="line">      configuration.addLoadedResource(resource);</span><br><span class="line">      bindMapperForNamespace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    parsePendingResultMaps();</span><br><span class="line">    parsePendingCacheRefs();</span><br><span class="line">    parsePendingStatements();</span><br><span class="line">  &#125;    </span><br><span class="line"></span><br><span class="line">-----------------------------------</span><br><span class="line"><span class="comment">//   configurationElement 方法</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configurationElement</span><span class="params">(XNode context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="comment">// 获取 namespace       </span></span><br><span class="line">      String namespace = context.getStringAttribute(<span class="string">"namespace"</span>);</span><br><span class="line">      <span class="keyword">if</span> (namespace == <span class="keyword">null</span> || namespace.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Mapper's namespace cannot be empty"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//  MapperBuilderAssistant 将 namespace 绑定到该类的参数中来.        </span></span><br><span class="line">      builderAssistant.setCurrentNamespace(namespace);</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 这里的 cache-ref / cache 都是暂时没有配置的.     </span></span><br><span class="line">      cacheRefElement(context.evalNode(<span class="string">"cache-ref"</span>));</span><br><span class="line">      cacheElement(context.evalNode(<span class="string">"cache"</span>));</span><br><span class="line">        </span><br><span class="line"> <span class="comment">//  /mapper/parameterMap 也是暂时没有配置的  </span></span><br><span class="line">      parameterMapElement(context.evalNodes(<span class="string">"/mapper/parameterMap"</span>));</span><br><span class="line">        </span><br><span class="line"><span class="comment">// resultMap 是对对象字段的映射</span></span><br><span class="line"><span class="comment">// mapper/sql 是对一些公用的sql进行抽取</span></span><br><span class="line"><span class="comment">// 二者暂时都没有配置        </span></span><br><span class="line">      resultMapElements(context.evalNodes(<span class="string">"/mapper/resultMap"</span>));</span><br><span class="line">      sqlElement(context.evalNodes(<span class="string">"/mapper/sql"</span>));</span><br><span class="line"><span class="comment">// 获取 select / insert / update / delete 等 标签.        </span></span><br><span class="line">      buildStatementFromContext(context.evalNodes(<span class="string">"select|insert|update|delete"</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Error parsing Mapper XML. The XML location is '"</span> + resource + <span class="string">"'. Cause: "</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;    </span><br><span class="line"></span><br><span class="line"><span class="comment">// 往下跟方法</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildStatementFromContext</span><span class="params">(List&lt;XNode&gt; list, String requiredDatabaseId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (XNode context : list) &#123;</span><br><span class="line">      <span class="keyword">final</span> XMLStatementBuilder statementParser = <span class="keyword">new</span> XMLStatementBuilder(configuration, builderAssistant, context, requiredDatabaseId);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        statementParser.parseStatementNode();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IncompleteElementException e) &#123;</span><br><span class="line">        configuration.addIncompleteStatement(statementParser);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>Java源码</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis-springboot</title>
    <url>/2020/12/27/mybatis/mybatis-springboot/</url>
    <content><![CDATA[<h4 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h4><p>​    MyBatis 与 SpringBoot 整合操作.  在这次整合的过程中,再次明白自己毫无疑问的是一个比较手残的同学了.</p>
<p>​    这里我们是基于 sql 语句写在 xml 里面进行整合的操作.</p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h4><p>​      这里说下创建一个 入门 项目的大致流程.</p>
<p>​       先创建一个 SpringBoot 项目 ,  引入依赖 :   <a href="https://github.com/baoyang23/mybtatis-analysis/blob/master/mybatis-spring-boot-hello/pom.xml" target="_blank" rel="noopener">https://github.com/baoyang23/mybtatis-analysis/blob/master/mybatis-spring-boot-hello/pom.xml</a></p>
<p>​        创建 MyBatis 的配置文件信息 :     <a href="https://github.com/baoyang23/mybtatis-analysis/blob/master/mybatis-spring-boot-hello/src/main/resources/mybatis-config.xml" target="_blank" rel="noopener">https://github.com/baoyang23/mybtatis-analysis/blob/master/mybatis-spring-boot-hello/src/main/resources/mybatis-config.xml</a></p>
<p>​        创建查询的 sql 语句，也就是我们的 mapper 文件 : <a href="https://github.com/baoyang23/mybtatis-analysis/tree/master/mybatis-spring-boot-hello/src/main/resources/mapper" target="_blank" rel="noopener">https://github.com/baoyang23/mybtatis-analysis/tree/master/mybatis-spring-boot-hello/src/main/resources/mapper</a></p>
<p>​       application.properties :  <a href="https://github.com/baoyang23/mybtatis-analysis/blob/master/mybatis-spring-boot-hello/src/main/resources/application.properties" target="_blank" rel="noopener">https://github.com/baoyang23/mybtatis-analysis/blob/master/mybatis-spring-boot-hello/src/main/resources/application.properties</a></p>
<p>​      扫描 mapper 接口 :  @MapperScan(basePackages = {“com.iyang.mybatis.springboot.hello.mapper”})  <a href="https://github.com/baoyang23/mybtatis-analysis/blob/master/mybatis-spring-boot-hello/src/main/java/com/iyang/mybatis/springboot/hello/MybatisSpringBootHelloApplication.java" target="_blank" rel="noopener">https://github.com/baoyang23/mybtatis-analysis/blob/master/mybatis-spring-boot-hello/src/main/java/com/iyang/mybatis/springboot/hello/MybatisSpringBootHelloApplication.java</a></p>
<p>这里是没有引入 web 依赖的 , 直接启动 main 方法 ,  然后就可以看到我们查询出来的结果了.</p>
<p>如果你熟悉 SpringBoot 源码的话，就会晓得有一个自动装配的操作.</p>
<p>如果不熟悉的话，那么就只能通过 @MapperScan(basePackages =  {“com.iyang.mybatis.springboot.hello.mapper”}) 去看 ,  这样有些是依赖自动装配（spring.factories） 中的配置加载的,  所以这里建议在看之前，如果是有一点 SpringBoot  扩展的知识了解是很好的。如果没有怎么办呢？没有就来看我接下来的内容。</p>
<p>其实这个地方你仔细想下，在 MyBatis 与 Spring 整合的时候，通过 xml 的方式给 MyBatis 的bean 已经  mybatis-spring 中自己写的扫描类，最后将扫描出来的 bd 在还没初始化之前，将bd 的beanClass 替换为我们的代理类.</p>
<p>那么，SpringBoot 与 MyBatis 整合的时候，最后要做的事情是不是也是将 MyBatis 的信息注入到 SpringBoot 来呢？只不过，SpringBoot 就不像 Spring 一样了，还将 bean 的信息配置到 xml 文件中.</p>
<p>于是，接下来跟我的阅读&amp;分析来一步一步的往下看.</p>
<h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4><h4 id="方法分析"><a href="#方法分析" class="headerlink" title="方法分析"></a>方法分析</h4><p>​     <strong>关注点一</strong> :   这里我们点入到    org.mybatis.spring.annotation.MapperScan 注解里面来，可以看到有一个   @Import(MapperScannerRegistrar.class) , 于是我们顺手跟进来 :   org.mybatis.spring.annotation.MapperScannerRegistrar ,  从名字上来，这个类就做了一个扫描mapper并且将mapper注入到Spring容器中来的事情.</p>
<p>​    <strong>关注点二</strong> :   我们从引入进来的依赖来看,    mybatis-spring-boot-starter-2.1.2.jar  跟进到 这个包来，可以看到这个包也是引入一些进来.   mybatis/mybatis-spring/spring-boot-starter-jdbc  这三个依赖我们应该不是很陌生的，mybatis-spring-boot-autoconfigure主要来看这个。    spring.factories 的作用大家可以去了解下，SpringBoot很多 EnableAutoConfiguration  的配置都是放入在这个里面的，在启动的时候，会去一层一层的去读取 spring.factories 文件的内容。  这里我们主要来看 :   org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration 这个类皆可.</p>
<p>​     MyBatis 在 properties 中的配置文件读取 :  org.mybatis.spring.boot.autoconfigure.MybatisProperties</p>
<p>可以看到该类上是有: @ConfigurationProperties(prefix = MybatisProperties.MYBATIS_PREFIX)</p>
<p>于是我们一下子就多了二个关注点, 这里我们可以采用之前的  笨方法，  当你对整合流程执行不是很熟悉的话，可以在这二个关注点的重写方法上都打算断点，看下其执行顺序是怎么执行的.    弄清楚了执行流程,就可以跟着流程来一步一步的分析. 从我们打上 debug 开始，往下的执行流程就是一步一步来的，那么就跟着我们debug  的方法来一步一步的分析.</p>
<p>org.mybatis.spring.annotation.MapperScannerRegistrar#registerBeanDefinitions() —&gt;     org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration#MybatisAutoConfiguration  —&gt;  org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration#afterPropertiesSet  —-&gt;    org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration#sqlSessionFactory  —&gt;   org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration#sqlSessionTemplate() —-&gt;</p>
<p><strong>org.mybatis.spring.annotation.MapperScannerRegistrar#registerBeanDefinitions() 方法</strong> :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * &#123;@inheritDoc&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Override</span><br><span class="line">public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123;</span><br><span class="line">&#x2F;***</span><br><span class="line">*  这里是获取出了注解里面属性的值. </span><br><span class="line">*&#x2F;   </span><br><span class="line">  AnnotationAttributes mapperScanAttrs &#x3D; </span><br><span class="line">  AnnotationAttributes.fromMap(importingClassMetadata.getAnnotationAttributes(MapperScan.class.getName()));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 能获取到有注解,不是null,就会走到下面的代码中来.    </span><br><span class="line">  if (mapperScanAttrs !&#x3D; null) &#123;</span><br><span class="line">    registerBeanDefinitions(importingClassMetadata, mapperScanAttrs, registry,</span><br><span class="line">        generateBaseBeanName(importingClassMetadata, 0));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* </span><br><span class="line">*&#x2F;</span><br><span class="line">  void registerBeanDefinitions(AnnotationMetadata annoMeta, AnnotationAttributes annoAttrs,</span><br><span class="line">      BeanDefinitionRegistry registry, String beanName) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 利用 BeanDefinitionBuilder 构造者,传入了一个 MapperScannerConfigurer.class</span><br><span class="line">&#x2F;&#x2F; 这里的 builder里面是有一个 bd 的,里面的beanClass就是 MapperScannerConfigurer      </span><br><span class="line">    BeanDefinitionBuilder builder &#x3D; BeanDefinitionBuilder.genericBeanDefinition(MapperScannerConfigurer.class);</span><br><span class="line">    builder.addPropertyValue(&quot;processPropertyPlaceHolders&quot;, true);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这里获取 @MapperScan 注解的属性, 如果属性是有值的话,就会设置到 builder 中来. </span><br><span class="line">    Class&lt;? extends Annotation&gt; annotationClass &#x3D; annoAttrs.getClass(&quot;annotationClass&quot;);</span><br><span class="line">    if (!Annotation.class.equals(annotationClass)) &#123;</span><br><span class="line">      builder.addPropertyValue(&quot;annotationClass&quot;, annotationClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; markerInterface &#x3D; annoAttrs.getClass(&quot;markerInterface&quot;);</span><br><span class="line">    if (!Class.class.equals(markerInterface)) &#123;</span><br><span class="line">      builder.addPropertyValue(&quot;markerInterface&quot;, markerInterface);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends BeanNameGenerator&gt; generatorClass &#x3D; annoAttrs.getClass(&quot;nameGenerator&quot;);</span><br><span class="line">    if (!BeanNameGenerator.class.equals(generatorClass)) &#123;</span><br><span class="line">      builder.addPropertyValue(&quot;nameGenerator&quot;, BeanUtils.instantiateClass(generatorClass));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends MapperFactoryBean&gt; mapperFactoryBeanClass &#x3D; annoAttrs.getClass(&quot;factoryBean&quot;);</span><br><span class="line">    if (!MapperFactoryBean.class.equals(mapperFactoryBeanClass)) &#123;</span><br><span class="line">      builder.addPropertyValue(&quot;mapperFactoryBeanClass&quot;, mapperFactoryBeanClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String sqlSessionTemplateRef &#x3D; annoAttrs.getString(&quot;sqlSessionTemplateRef&quot;);</span><br><span class="line">    if (StringUtils.hasText(sqlSessionTemplateRef)) &#123;</span><br><span class="line">      builder.addPropertyValue(&quot;sqlSessionTemplateBeanName&quot;, annoAttrs.getString(&quot;sqlSessionTemplateRef&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String sqlSessionFactoryRef &#x3D; annoAttrs.getString(&quot;sqlSessionFactoryRef&quot;);</span><br><span class="line">    if (StringUtils.hasText(sqlSessionFactoryRef)) &#123;</span><br><span class="line">      builder.addPropertyValue(&quot;sqlSessionFactoryBeanName&quot;, annoAttrs.getString(&quot;sqlSessionFactoryRef&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 下面是根据 value&#x2F;basePackages&#x2F;basePackageClasses 来获取包的信息,</span><br><span class="line">&#x2F;&#x2F; 这里也就说, 我们可以跟着这三个属性来配置包信息.      </span><br><span class="line">    List&lt;String&gt; basePackages &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    basePackages.addAll(</span><br><span class="line">        Arrays.stream(annoAttrs.getStringArray(&quot;value&quot;)).filter(StringUtils::hasText).collect(Collectors.toList()));</span><br><span class="line"></span><br><span class="line">    basePackages.addAll(Arrays.stream(annoAttrs.getStringArray(&quot;basePackages&quot;)).filter(StringUtils::hasText)</span><br><span class="line">        .collect(Collectors.toList()));</span><br><span class="line"></span><br><span class="line">    basePackages.addAll(Arrays.stream(annoAttrs.getClassArray(&quot;basePackageClasses&quot;)).map(ClassUtils::getPackageName)</span><br><span class="line">        .collect(Collectors.toList()));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果没有获取到包的信息,那就根据注解所在的路径来获取默认的路径.      </span><br><span class="line">    if (basePackages.isEmpty()) &#123;</span><br><span class="line">      basePackages.add(getDefaultBasePackage(annoMeta));</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F; 如果有lazyInitialization属性的值,就设置到 builder 中来. </span><br><span class="line">    String lazyInitialization &#x3D; annoAttrs.getString(&quot;lazyInitialization&quot;);</span><br><span class="line">    if (StringUtils.hasText(lazyInitialization)) &#123;</span><br><span class="line">      builder.addPropertyValue(&quot;lazyInitialization&quot;, lazyInitialization);</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F; 添加包的属性</span><br><span class="line">    builder.addPropertyValue(&quot;basePackage&quot;, StringUtils.collectionToCommaDelimitedString(basePackages));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;  getBeanDefinition() 在返回 bd 之前，会走一个 validate 方法.</span><br><span class="line">&#x2F;&#x2F; org.springframework.beans.factory.support.DefaultListableBeanFactory#registerBeanDefinition</span><br><span class="line">&#x2F;&#x2F; 走这个方法来将 bd 给注入到 Spring 容器中来.</span><br><span class="line">&#x2F;&#x2F; 这里注入进去的 beanName 的值是 :  com.iyang.mybatis.springboot.hello.MybatisSpringBootHelloApplication#MapperScannerRegistrar#0</span><br><span class="line">&#x2F;&#x2F; 注入进去的 bd 的 beanClass : class org.mybatis.spring.mapper.MapperScannerConfigurer </span><br><span class="line">    registry.registerBeanDefinition(beanName, builder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>这里可以总结下 registerBeanDefinitions 方法，该方法就是将 @MapperScan  的注解属性的值给到  : BeanDefinitionBuilder builder, 该builder  里面有bd,bd的beanClass是MapperScannerConfigurer，最后将MapperScannerConfigurer注入到 Spring 容器中来.</strong></p>
<hr>
<p><strong>MyBatisAutoConfiguration()  有参构造函数</strong></p>
<p>这里我们在 MybatisAutoConfiguration 构造函数上打上断点, 可以根据 断点来分析，走完👆面的方法，然后我们点击走到下一个断点来，就会走到 这个 有参构造函数.</p>
<p>如果好奇的话，可以跟踪debug 的堆栈信息，是怎么走到这步来的. 走到这个方法来 : finishBeanFactoryInitialization(beanFactory) 这是最初的入口.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public MybatisAutoConfiguration(MybatisProperties properties, ObjectProvider&lt;Interceptor[]&gt; interceptorsProvider,</span><br><span class="line">    ObjectProvider&lt;TypeHandler[]&gt; typeHandlersProvider, ObjectProvider&lt;LanguageDriver[]&gt; languageDriversProvider,</span><br><span class="line">    ResourceLoader resourceLoader, ObjectProvider&lt;DatabaseIdProvider&gt; databaseIdProvider,</span><br><span class="line">    ObjectProvider&lt;List&lt;ConfigurationCustomizer&gt;&gt; configurationCustomizersProvider) &#123;</span><br><span class="line">&#x2F;&#x2F; 这里都是赋值    </span><br><span class="line">  this.properties &#x3D; properties;</span><br><span class="line">  this.interceptors &#x3D; interceptorsProvider.getIfAvailable();</span><br><span class="line">  this.typeHandlers &#x3D; typeHandlersProvider.getIfAvailable();</span><br><span class="line">  this.languageDrivers &#x3D; languageDriversProvider.getIfAvailable();</span><br><span class="line">  this.resourceLoader &#x3D; resourceLoader;</span><br><span class="line">  this.databaseIdProvider &#x3D; databaseIdProvider.getIfAvailable();</span><br><span class="line">  this.configurationCustomizers &#x3D; configurationCustomizersProvider.getIfAvailable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration#afterPropertiesSet()方法</strong></p>
<p>这里可以看到是对配置文件是否存在进行检验.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void afterPropertiesSet() &#123;</span><br><span class="line">  checkConfigFileExists();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 检验配置文件是否存在</span><br><span class="line">  private void checkConfigFileExists() &#123;</span><br><span class="line">    if (this.properties.isCheckConfigLocation() &amp;&amp; StringUtils.hasText(this.properties.getConfigLocation())) &#123;</span><br><span class="line">      Resource resource &#x3D; this.resourceLoader.getResource(this.properties.getConfigLocation());</span><br><span class="line">      Assert.state(resource.exists(),</span><br><span class="line">          &quot;Cannot find config location: &quot; + resource + &quot; (please add config file or check your Mybatis configuration)&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration#sqlSessionFactory 方法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 这里说下 @ConditionalOnMissingBean 的作用,当bean不存在的时候，则实例化这个bean.</span><br><span class="line">&#x2F;&#x2F; 这里会传入 dataSource 进来.</span><br><span class="line">@Bean</span><br><span class="line">@ConditionalOnMissingBean</span><br><span class="line">public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception &#123;</span><br><span class="line">&#x2F;&#x2F; 创建 sqlSessionBean 对象.    </span><br><span class="line">  SqlSessionFactoryBean factory &#x3D; new SqlSessionFactoryBean();</span><br><span class="line">&#x2F;&#x2F; 设置 dataSource &amp; SpringBootVFS.class      </span><br><span class="line">  factory.setDataSource(dataSource);</span><br><span class="line">  factory.setVfs(SpringBootVFS.class);</span><br><span class="line">&#x2F;&#x2F; 获取到 MyBatis 的配置文件属性,如果有的话,就会设置到 configLocation属性来.    </span><br><span class="line">  if (StringUtils.hasText(this.properties.getConfigLocation())) &#123;</span><br><span class="line">    factory.setConfigLocation(this.resourceLoader.getResource(this.properties.getConfigLocation()));</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F; 这里从 properties 中获取 configuration,没有值就会是null.    </span><br><span class="line">  applyConfiguration(factory);</span><br><span class="line">  if (this.properties.getConfigurationProperties() !&#x3D; null) &#123;</span><br><span class="line">    factory.setConfigurationProperties(this.properties.getConfigurationProperties());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果有插件,就会设置插件.    </span><br><span class="line">  if (!ObjectUtils.isEmpty(this.interceptors)) &#123;</span><br><span class="line">    factory.setPlugins(this.interceptors);</span><br><span class="line">  &#125;</span><br><span class="line">  if (this.databaseIdProvider !&#x3D; null) &#123;</span><br><span class="line">    factory.setDatabaseIdProvider(this.databaseIdProvider);</span><br><span class="line">  &#125;</span><br><span class="line">&#x2F;&#x2F; 包的名别设置    </span><br><span class="line">  if (StringUtils.hasLength(this.properties.getTypeAliasesPackage())) &#123;</span><br><span class="line">    factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage());</span><br><span class="line">  &#125;</span><br><span class="line">  if (this.properties.getTypeAliasesSuperType() !&#x3D; null) &#123;</span><br><span class="line">    factory.setTypeAliasesSuperType(this.properties.getTypeAliasesSuperType());</span><br><span class="line">  &#125;</span><br><span class="line">  if (StringUtils.hasLength(this.properties.getTypeHandlersPackage())) &#123;</span><br><span class="line">    factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage());</span><br><span class="line">  &#125;</span><br><span class="line">  if (!ObjectUtils.isEmpty(this.typeHandlers)) &#123;</span><br><span class="line">    factory.setTypeHandlers(this.typeHandlers);</span><br><span class="line">  &#125;</span><br><span class="line">  if (!ObjectUtils.isEmpty(this.properties.resolveMapperLocations())) &#123;</span><br><span class="line">    factory.setMapperLocations(this.properties.resolveMapperLocations());</span><br><span class="line">  &#125;</span><br><span class="line">&#x2F;&#x2F; 这里都是配置属性的设置.    </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取 propert 字段属性的名字.    </span><br><span class="line">  Set&lt;String&gt; factoryPropertyNames &#x3D; Stream</span><br><span class="line">      .of(new BeanWrapperImpl(SqlSessionFactoryBean.class).getPropertyDescriptors()).map(PropertyDescriptor::getName)</span><br><span class="line">      .collect(Collectors.toSet());</span><br><span class="line">  Class&lt;? extends LanguageDriver&gt; defaultLanguageDriver &#x3D; this.properties.getDefaultScriptingLanguageDriver();</span><br><span class="line">  if (factoryPropertyNames.contains(&quot;scriptingLanguageDrivers&quot;) &amp;&amp; !ObjectUtils.isEmpty(this.languageDrivers)) &#123;</span><br><span class="line">    &#x2F;&#x2F; Need to mybatis-spring 2.0.2+</span><br><span class="line">    factory.setScriptingLanguageDrivers(this.languageDrivers);</span><br><span class="line">    if (defaultLanguageDriver &#x3D;&#x3D; null &amp;&amp; this.languageDrivers.length &#x3D;&#x3D; 1) &#123;</span><br><span class="line">      defaultLanguageDriver &#x3D; this.languageDrivers[0].getClass();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#x2F;&#x2F; 设置默认的脚本语言解析器. 这里没有,设置的是默认的null.    </span><br><span class="line">  if (factoryPropertyNames.contains(&quot;defaultScriptingLanguageDriver&quot;)) &#123;</span><br><span class="line">    &#x2F;&#x2F; Need to mybatis-spring 2.0.2+</span><br><span class="line">    factory.setDefaultScriptingLanguageDriver(defaultLanguageDriver);</span><br><span class="line">  &#125;</span><br><span class="line">&#x2F;&#x2F; org.mybatis.spring.SqlSessionFactoryBean#getObject,这里走到了 SqlSessionBean.</span><br><span class="line">&#x2F;&#x2F; 这个SqlSessionFactoryBean是在有之前 mybatis和Spring 整合分析有提过到的,可以参考getObject方法: https:&#x2F;&#x2F;github.com&#x2F;baoyang23&#x2F;mybtatis-analysis&#x2F;tree&#x2F;master&#x2F;mybatis-spring-hello    </span><br><span class="line">&#x2F;&#x2F; 这里会走 org.mybatis.spring.SqlSessionFactoryBean#getObject 的 afterPropertiesSet 方法来创建一个 SqlSessionFactory , 这里返回的 SqlSessionFactory 就注入到 Spring 容器中来.    </span><br><span class="line">  return factory.getObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以这个方法 ： 先是new了一个SqlSessionFactoryBean对象，如果你仔细看的话，你会发现这个对象在之前 mybatis-spring 整合的时候，我们通过 xml 配置文件配置进来的，并且同时通过标签给赋值了datasource等信息，  而这里是通过代码，if等判断，来对 SqlSessionFactoryBean 的属性进行set值的. 最后也是创建出一个  SqlSessionFactory 给注入到 Spring 容器中来.</strong></p>
<hr>
<p><strong>org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration#sqlSessionTemplate 方法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">@ConditionalOnMissingBean</span><br><span class="line">public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) &#123;</span><br><span class="line">&#x2F;&#x2F; 这里根据 executorType 是否有值来判断要走的构造函数方法.    </span><br><span class="line">  ExecutorType executorType &#x3D; this.properties.getExecutorType();</span><br><span class="line">  if (executorType !&#x3D; null) &#123;</span><br><span class="line">    return new SqlSessionTemplate(sqlSessionFactory, executorType);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">&#x2F;&#x2F; 这里默认的获取是 SIMPLE 这个 ExecutorType.      </span><br><span class="line">    return new SqlSessionTemplate(sqlSessionFactory);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; org.mybatis.spring.SqlSessionTemplate#SqlSessionTemplate(org.apache.ibatis.session.SqlSessionFactory, org.apache.ibatis.session.ExecutorType, org.springframework.dao.support.PersistenceExceptionTranslator),最后可以跟进到这个方法中来.</span><br><span class="line"></span><br><span class="line">  public SqlSessionTemplate(SqlSessionFactory sqlSessionFactory, ExecutorType executorType,</span><br><span class="line">      PersistenceExceptionTranslator exceptionTranslator) &#123;</span><br><span class="line">&#x2F;&#x2F; 对sqlSessionFactory 和 executorType 进行校验</span><br><span class="line">    notNull(sqlSessionFactory, &quot;Property &#39;sqlSessionFactory&#39; is required&quot;);</span><br><span class="line">    notNull(executorType, &quot;Property &#39;executorType&#39; is required&quot;);</span><br><span class="line"></span><br><span class="line">    this.sqlSessionFactory &#x3D; sqlSessionFactory;</span><br><span class="line">    this.executorType &#x3D; executorType;</span><br><span class="line">    this.exceptionTranslator &#x3D; exceptionTranslator;</span><br><span class="line">&#x2F;&#x2F; 这里通过 JDK 的代码来生成了一个 sqlSessionProxy 代理的对象.      </span><br><span class="line">    this.sqlSessionProxy &#x3D; (SqlSession) newProxyInstance(SqlSessionFactory.class.getClassLoader(),</span><br><span class="line">        new Class[] &#123; SqlSession.class &#125;, new SqlSessionInterceptor());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>该方法是将 SqlSessionTemplate 给注入到 Spring 容器中啦.</p>
<h4 id="-2"><a href="#-2" class="headerlink" title=""></a></h4><h4 id="疑惑点"><a href="#疑惑点" class="headerlink" title="疑惑点"></a>疑惑点</h4><p>​     大家有没有疑惑我们定义的 mapper 接口 好像从这个流程分析下来，并没有提到 ，那么是在上面时候被注入到 Spring 容器中来的呢？</p>
<p>​     registerBeanDefinitions()  这个方法 , 注入了MapperScannerConfigurer 到  Spring 容器中来了，可以回顾下之前 mybatis 整合 Spring 的时候，我们是通过 xml 配置了这个对象注入到 spring  容器中来的。 那么注入进来的,回调到  org.mybatis.spring.mapper.MapperScannerConfigurer#postProcessBeanDefinitionRegistry 这个方法的时候，就会将扫描并且将我们的mapper接口文件，给注入到 Spring 容器中来的.  然后扫描的包，是根据@MapperScan 解析注解的时候，是有对扫描的包进行解析的.</p>
<h4 id="-3"><a href="#-3" class="headerlink" title=""></a></h4><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​      其实 SpringBoot 整合 MyBatis , 我们从二个切入点来分析是怎么整合进来的.<br> ​      一是 @MapperScan 注解中的 @Import(MapperScannerRegistrar.class) 将  MapperScannerRegistrar 给导入到 Spring 容器中来, 然后MapperSacnnerRegistrar 来讲  org.mybatis.spring.mapper.MapperScannerConfigurer 给注入到 Spring中来，替换了我们之前用 Spring 整合 Mybatis 的时候，通过xml配置文件整合进来.</p>
<p>​     二是利用 SpringBoot 提供的 spring-boot-autoconfigure +  spring.factories() 来 配置自动注入, 这里注入了 MybatisAutoConfiguration 配置类. 然后注入进来的 MyBatis 配置类做了什么事情呢？  可以看到这个类中是有做:   注入了 SqlSessionFactory.  SqlSessionFactory 又是怎么注入进来的呢？ 可以看到  org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration#sqlSessionFactory 方法是有先创建一个 org.mybatis.spring.SqlSessionFactoryBean 的， 看到  SqlSessionFactoryBean 这个对象，我们就不难想起 Spring + Mybatis 里面的 beans.xml  是将该对象注入到 Spring 容器中来. 这里是直接new的，然后将一些配置属性并满足条件,给set到  SqlSessionFactoryBean  中来，最后调用   org.mybatis.spring.SqlSessionFactoryBean#getObject 方法来获取  SqlSessionFactory.</p>
<p>spring.factories 文件内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;\</span><br><span class="line">org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration,\</span><br><span class="line">org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration</span><br></pre></td></tr></table></figure>



<p>最后从写的案例里面看, MyBatis 整合 SpringBoot 其实都是在 mybatis —&gt; MyBatis + Spring  等一步一步推导上来的，所以这里不难理解，好的技术都是在有需要和时间的沉淀下一步一步成长起来的.</p>
]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>Java源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring自定义(三)</title>
    <url>/2020/07/02/spring/Spring_Custom/</url>
    <content><![CDATA[<h4 id="题记"><a href="#题记" class="headerlink" title="题记"></a>题记</h4><p>​        前面讲到了这么多的什么BeanPostProcessor,事件什么的. 如果不写几下代码这里怕是很难弄清楚是个怎么回事. 所以只有看到代码跑,就大致可以看到其效果还是很明显的.</p>
<h4 id="BeanDefinitionRegistryPostProcessor"><a href="#BeanDefinitionRegistryPostProcessor" class="headerlink" title="BeanDefinitionRegistryPostProcessor"></a>BeanDefinitionRegistryPostProcessor</h4><p>​     先写一个类简单实现下  BeanDefinitionRegistryPostProcessor  这个接口 :</p>
<p>​     运行后的结果是可以很明显的看到我们的打印数据输出结果的.</p>
<p>​     程序是怎么运行到这个地方来的呢？</p>
<p>org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors(org.springframework.beans.factory.config.ConfigurableListableBeanFactory, java.util.List&lt;org.springframework.beans.factory.config.BeanFactoryPostProcessor&gt;) 走到这个方法的</p>
<p>beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class…..),从这个类中获取出来的postProcessorNames,就有包含我们的自己定义的一个.</p>
<p>由于我们自己扩展的这个类,是没有实现 PriorityOrdered/Ordered的,所以就放到最后来处理了.</p>
<p>也就是在这个方法,while (reiterate) { …  invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);}</p>
<p>走的这个方法的时候,才会去走到我们定义的类。</p>
<p>那是因为这个地方 Spring是有处理顺序的。 先处理 PriorityOrdered.class ,  再处理 Ordered.class , 最后处理既没有PriorityOrdered,也没有Ordered的.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GavinYangRegistryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GavinYangRegistryPostProcessor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"GavinYangRegistryPostProcessor 构造方法执行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用到 GavinYangRegistryPostProcessor#postProcessBeanDefinitionRegistry方法"</span>);</span><br><span class="line">        String[] beanDefinitionNames = registry.getBeanDefinitionNames();</span><br><span class="line">        String bdNamesString = Arrays.toString(beanDefinitionNames);</span><br><span class="line">        System.out.println(<span class="string">"GavinYangRegistryPostProcessor 类中"</span> + bdNamesString);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="BeanFactoryPostProcessor"><a href="#BeanFactoryPostProcessor" class="headerlink" title="BeanFactoryPostProcessor"></a>BeanFactoryPostProcessor</h4><p>​    简单实现一下 BeanFactoryPostProcessor  这个接口来看一下效果.</p>
<p>​    先写一个类 : 然后实现一下这个接口 BeanFactoryPostProcessor ,  我们这里就获取下beanFactory中的所有beanDefinitionNames的数组, 然后打印出来看下效果.  打印结果也是贴在下面的.  接着我们看下其源码是一个怎么样的走向.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GavinYangBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        String[] beanDefinitionNames = beanFactory.getBeanDefinitionNames();</span><br><span class="line">        System.out.println(Arrays.toString(beanDefinitionNames));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//[org.springframework.context.annotation.internalConfigurationAnnotationProcessor, org.springframework.context.annotation.internalAutowiredAnnotationProcessor, org.springframework.context.annotation.internalCommonAnnotationProcessor, org.springframework.context.event.internalEventListenerProcessor, org.springframework.context.event.internalEventListenerFactory, yangBeanOne, gavinYangBeanFactoryPostProcessor, yangBeanPostProcessor, gavinYangLifeImpl]</span></span><br></pre></td></tr></table></figure>



<p>直接看这个类的这个方法，我这里只截取了一部分代码,也就是和 BeanFactoryPostProcessor 有关的代码. </p>
<p>和它没关系的代码,这里就没有去截取了.</p>
<p>org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors(org.springframework.beans.factory.config.ConfigurableListableBeanFactory, java.util.List&lt;org.springframework.beans.factory.config.BeanFactoryPostProcessor&gt;) .</p>
<p>看源码看是如何调用到这个方法的,还是比较好理解。先是根据 BeanFactoryPostProcessor.class获取出beanName的集合,然后老规矩进行一些特定的排序,当然我这里什么都没做,也就是最后处理哦。</p>
<p>然后跟到invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);这个方法里面,可以看到它迭代这个集合的元素,当然了,我们只需要关注我们自己定义的哪个就可以了,然后就会走其postProcessBeanFactory方法,也就是走到了我们定义的类的这个方法上来了.</p>
<p>OK啦。大致流程就是这个样子的,还是比较好理解的.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line"><span class="comment">// uninitialized to let the bean factory post-processors apply to them!</span></span><br><span class="line"><span class="comment">// 这个地方获取出来的数组里面的值,就有我们想看到的.</span></span><br><span class="line"><span class="comment">//org.springframework.context.annotation.internalConfigurationAnnotationProcessor</span></span><br><span class="line"><span class="comment">//org.springframework.context.event.internalEventListenerProcessor</span></span><br><span class="line"><span class="comment">//gavinYangBeanFactoryPostProcessor</span></span><br><span class="line"><span class="comment">//当看到第三个是不是非常的熟悉.没错,这就是我们自己定义的.</span></span><br><span class="line">String[] postProcessorNames =</span><br><span class="line">      beanFactory.getBeanNamesForType(BeanFactoryPostProcessor<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,</span></span><br><span class="line"><span class="comment">// Ordered, and the rest.</span></span><br><span class="line">List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">// 然后先经过一轮排序,就可以看到 我们自己定义的就放入到了nonOrderedPostProcessorNames这个集合中,</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">   <span class="keyword">if</span> (processedBeans.contains(ppName)) &#123;</span><br><span class="line">      <span class="comment">// skip - already processed in first phase above</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">      priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">      orderedPostProcessorNames.add(ppName);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Next, invoke the BeanFactoryPostProcessors that implement Ordered.</span></span><br><span class="line">List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(orderedPostProcessorNames.size());</span><br><span class="line"><span class="keyword">for</span> (String postProcessorName : orderedPostProcessorNames) &#123;</span><br><span class="line">   orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">&#125;</span><br><span class="line">sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Finally, invoke all other BeanFactoryPostProcessors.</span></span><br><span class="line">List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(nonOrderedPostProcessorNames.size());</span><br><span class="line"><span class="keyword">for</span> (String postProcessorName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">   nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 然后我们直接看到处理nonOrderedPostProcessors这个集合的方法,</span></span><br><span class="line"><span class="comment">//因为这个方法也会走到我们自己定义的类中去</span></span><br><span class="line"><span class="comment">//方法里面对nonOrderedPostProcessors进行迭代,然后一次调用其postProcessBeanFactory方法,同时也传入了beanFactory到里面去.</span></span><br><span class="line">invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);</span><br></pre></td></tr></table></figure>



<h4 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h4><p>我们先写一个 Bean. 然后可以里面写一个属性,方便标识.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YangBeanOne</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无参构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">YangBeanOne</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"YangBeanOne无参数构造函数"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然后我们自定义一个BeanPostProcessor,其实现了BeanPostProcessor接口.</p>
<p>可以看到的是,我们在if中做了beanName的判断,如果是的话,那么我们就会强转,然后给name字段赋值上GavinYang的值.</p>
<p>我们给断点打到 if这里，然后看进来的堆栈信息,发现其是在初始化bean中,然后调用beanPostProcessor的postProcessAfterInitialization的方法才会走到这里,也就是在doCreateBean这个方法里面.</p>
<p>然后这个 YangBeanPostProcessor 是什么时候给添加到 beanFactory中去的呢？</p>
<p>org.springframework.context.support.PostProcessorRegistrationDelegate#registerBeanPostProcessors(org.springframework.beans.factory.config.ConfigurableListableBeanFactory, org.springframework.context.support.AbstractApplicationContext)在这个方法打上断点,然后你会发现其get出来的postProcessorNames数组,就有我们的这个YangBeanPostProcessor，然后走registerBeanPostProcessors方法的时候,就会给添加到beanFactory中去.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YangBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"yangBeanOne"</span>.equalsIgnoreCase(beanName))&#123;</span><br><span class="line">            ((YangBeanOne) bean).setName(<span class="string">"GavinYang"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>启动类 :</p>
<p>这就打印出来的结果就可以看到的是GavinYang,也就是说我们初始化这个bean之后,然后给其name属性赋值上了GavinYang这个值.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringStartMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(<span class="string">"com.iyang.spring"</span>);</span><br><span class="line">        YangBeanOne yangBeanOne = context.getBean(YangBeanOne<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(yangBeanOne.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Lifecycle-扩展"><a href="#Lifecycle-扩展" class="headerlink" title="Lifecycle 扩展"></a>Lifecycle 扩展</h4><p>Lifecycle 扩展要比起 BeanPostProcessor要好理解得多,因为你只用去实现这个接口(SmartLifecycle),然后在org.springframework.context.support.AbstractApplicationContext#finishRefresh到这个方法的时候,就会去调用实现这个接口的对用的方法.</p>
<p>这里我们自己写一个类,然后实现 SmartLifecycle 接口即可。</p>
<p>可以看到下面的打印参数.还是很清楚的明白.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GavinYangLifeImpl</span> <span class="keyword">implements</span> <span class="title">SmartLifecycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPhase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用到了GavinYangLifeImpl.start()方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//YangBeanOne无参数构造函数</span></span><br><span class="line"><span class="comment">//调用到了GavinYangLifeImpl.start()方法</span></span><br><span class="line"><span class="comment">//GavinYang</span></span><br></pre></td></tr></table></figure>



<p>然后我们再看下源码,为什么要实现 SmartLifecycle 这个接口呢？</p>
<p>org.springframework.context.support.DefaultLifecycleProcessor</p>
<p>这里我们先看到 phases ,也就是最底下的代码, 这个集合是有值的情况下先排序,然后再迭代,然后调用到 start()方法, 这个start方法是不是在我们的实现类中可以看到,是不是非常的熟悉感觉.</p>
<p>然后我们在看下,怎么样让这个集合能有值呢？</p>
<p>phases.put(phase, group); 可以看到 put方法这里, autoStartupOnly 是false 或者bean是SmartLifecycle的子类,并且其isAutoStartup方法的是true. 点到SmartLifecycle源码中去看,可以发现这个方法默认是返回的true.</p>
<p>接着在调用getPhase方法, 该方法也就是判断.最最关键的phases集合来了,先从里面get出数据,然后判断数据是不是null,如果是null的话,就先new一个Group出来,然后调用phases的put方法,也就是放入到这个集合中去了</p>
<p>所以这里就是我们为什么要实现 SmartLifecycle 这个接口,就会有启动的效果了的原因.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Internal helpers</span></span><br><span class="line"><span class="comment">// 传入进来的  autoStartupOnly 参数是true.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startBeans</span><span class="params">(<span class="keyword">boolean</span> autoStartupOnly)</span> </span>&#123;</span><br><span class="line">   Map&lt;String, Lifecycle&gt; lifecycleBeans = getLifecycleBeans();</span><br><span class="line">   Map&lt;Integer, LifecycleGroup&gt; phases = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">   lifecycleBeans.forEach((beanName, bean) -&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (!autoStartupOnly || (bean <span class="keyword">instanceof</span> SmartLifecycle &amp;&amp; ((SmartLifecycle) bean).isAutoStartup())) &#123;</span><br><span class="line">         <span class="keyword">int</span> phase = getPhase(bean);</span><br><span class="line">         LifecycleGroup group = phases.get(phase);</span><br><span class="line">         <span class="keyword">if</span> (group == <span class="keyword">null</span>) &#123;</span><br><span class="line">            group = <span class="keyword">new</span> LifecycleGroup(phase, <span class="keyword">this</span>.timeoutPerShutdownPhase, lifecycleBeans, autoStartupOnly);</span><br><span class="line">            phases.put(phase, group);</span><br><span class="line">         &#125;</span><br><span class="line">         group.add(beanName, bean);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">   <span class="keyword">if</span> (!phases.isEmpty()) &#123;</span><br><span class="line">      List&lt;Integer&gt; keys = <span class="keyword">new</span> ArrayList&lt;&gt;(phases.keySet());</span><br><span class="line">      Collections.sort(keys);</span><br><span class="line">      <span class="keyword">for</span> (Integer key : keys) &#123;</span><br><span class="line">         phases.get(key).start();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>  可以看到我们基于接口扩展的,还是很好理解的。 跟着源码中的初始化一些类,看哪个类是怎么写的，然后我们跟着写一个。 前提是,你要弄得明白 Spring 这个执行过程的.  不然你跟着写,不是很明白的话,就可能不是很容易看明白或者看懂你这个效果的.</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java源码</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring初始化(一)</title>
    <url>/2020/06/27/spring/Spring_Construction/</url>
    <content><![CDATA[<h4 id="阅读方法"><a href="#阅读方法" class="headerlink" title="阅读方法"></a>阅读方法</h4><p>   最简单的阅读方法,就是创建一个maven项目,让引入Spring的依赖.  然后写上一个main方法,来读取包下的内容,然后写一个bean,即可. 这个bean要在你扫描的包下.   于是我们直接在new的地方打上断点跟进去即可.</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SpringStartMain &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AnnotationConfigApplicationContext context &#x3D; new AnnotationConfigApplicationContext(&quot;com.iyang.spring&quot;);</span><br><span class="line">        YangBeanOne yangBeanOne &#x3D; context.getBean(YangBeanOne.class);</span><br><span class="line">        System.out.println(yangBeanOne.getClass().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p> 还有一种就是你去github上clone一个Spring的源码,然后倒入idea,当然你需要gradle环境来构建.然后成功的build一下, 如果成功了的话,就在源码的目录创建一个模块(x项目),然后像上面一样。这样做的好处是,你可以随便修改源码的代码, 你觉得它的哪个地方的代码写到不够好的话,也是可以去修改的.</p>
<h4 id="Debug阅读"><a href="#Debug阅读" class="headerlink" title="Debug阅读"></a>Debug阅读</h4><p>  开始debug进行代码的阅读 : </p>
<p>  debug就会进入到这个构造函数中, 这里我们先对 this() 和 scan(basePackages) 这二个方法进行阅读, refresh()里面涉及到内容比较多(BeanPostprocess,Aware,event等),不是一下子就能看明白的,是需要大量的时间去仔细阅读的.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new AnnotationConfigApplicationContext, scanning for components</span></span><br><span class="line"><span class="comment"> * in the given packages, registering bean definitions for those components,</span></span><br><span class="line"><span class="comment"> * and automatically refreshing the context.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> basePackages the packages to scan for component classes</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>();</span><br><span class="line">   scan(basePackages);</span><br><span class="line">   refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>this () 方法  </p>
<p> 可以看到this方法,基本是在做一些对环境初始化的操作.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new AnnotationConfigApplicationContext that needs to be populated</span></span><br><span class="line"><span class="comment"> * through &#123;<span class="doctag">@link</span> #register&#125; calls and then manually &#123;<span class="doctag">@linkplain</span> #refresh refreshed&#125;.</span></span><br><span class="line"><span class="comment"> 同时还会走到 : org.springframework.context.support.GenericApplicationContext#GenericApplicationContext()这个方法里面来.  this.beanFactory = new DefaultListableBeanFactory(); 可以看到这里是new了一个beanFactory的,也就是我们后面的refresh()方法,可以看到DefaultListableBeanFactroy这个类.</span></span><br><span class="line"><span class="comment"> 再往父类走 : org.springframework.context.support.AbstractApplicationContext#AbstractApplicationContext()就会走到这个类的这个方法来, this.resourcePatternResolver = getResourcePatternResolver(); 这里可以看到是初始化了 resourcePatternResolver.当然了,肯定还有一些new的全局变量的初始化也会进行初始化的.</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.reader = <span class="keyword">new</span> AnnotatedBeanDefinitionReader(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//这个方法对registry,environment和resourceLoader进行赋值,然后根据filter是true,添加了三个filter过滤器.可以看到这个方法虽然带了scanner名字,但是看每个走的方法,好像是没有扫描任何东西,都是对全局参数进行赋值等操作.</span></span><br><span class="line">   <span class="keyword">this</span>.scanner = <span class="keyword">new</span> ClassPathBeanDefinitionScanner(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---------------------------------</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create a new &#123;<span class="doctag">@code</span> AnnotatedBeanDefinitionReader&#125; for the given registry.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;If the registry is &#123;<span class="doctag">@link</span> EnvironmentCapable&#125;, e.g. is an &#123;<span class="doctag">@code</span> ApplicationContext&#125;,</span></span><br><span class="line"><span class="comment">	 * the &#123;<span class="doctag">@link</span> Environment&#125; will be inherited, otherwise a new</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> StandardEnvironment&#125; will be created and used.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> registry the &#123;<span class="doctag">@code</span> BeanFactory&#125; to load bean definitions into,</span></span><br><span class="line"><span class="comment">	 * in the form of a &#123;<span class="doctag">@code</span> BeanDefinitionRegistry&#125;</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #AnnotatedBeanDefinitionReader(BeanDefinitionRegistry, Environment)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #setEnvironment(Environment)</span></span><br><span class="line"><span class="comment">这里可以看到传入进来的registry是 this,也就是传入了AnnotationConfigApplicationContext它自己. </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">可以看到这个方法主要做的事情是,初始化Environment,然后new一个ConditionEvaluator对象,其保存了五个信息. 最后就分别添加五个 Processor到beanFactroy的beanDefinitionMap中来.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">AnnotatedBeanDefinitionReader</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// getOrCreateEnvironment()方法,先对registry进行非null的判断,如果是Null的话,就会抛出对应的异常.最后是new StandardEnvironment()了一个对象返回来. registry是满足EnvironmentCapable</span></span><br><span class="line"><span class="comment">// this()方法:先对传入进来的registry和environemnt进行非null的判断.this.registry = registry; 紧着new了一个ConditionEvaluator对象,其构造函数中,初始化了registry,beanFactory,environment,resourceLoader和classLoader这五个参数,是在内部类ConditionContextImpl中. 最后往beanFactory的beanDefinitionMap中添加了五个值,分别是:</span></span><br><span class="line"><span class="comment">//org.springframework.context.annotation.internalConfigurationAnnotationProcessor</span></span><br><span class="line"><span class="comment">//org.springframework.context.annotation.internalAutowiredAnnotationProcessor</span></span><br><span class="line"><span class="comment">//org.springframework.context.annotation.internalCommonAnnotationProcessor</span></span><br><span class="line"><span class="comment">//org.springframework.context.event.internalEventListenerProcessor</span></span><br><span class="line"><span class="comment">//org.springframework.context.event.internalEventListenerFactory  </span></span><br><span class="line"><span class="comment">//添加完,new AnnotatedBeanDefinitionReader()这个方法就走完了.        </span></span><br><span class="line">		<span class="keyword">this</span>(registry, getOrCreateEnvironment(registry));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">----------------------------------</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create a new &#123;<span class="doctag">@code</span> ClassPathBeanDefinitionScanner&#125; for the given bean factory.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> registry the &#123;<span class="doctag">@code</span> BeanFactory&#125; to load bean definitions into, in the form</span></span><br><span class="line"><span class="comment">	 * of a &#123;<span class="doctag">@code</span> BeanDefinitionRegistry&#125;</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ClassPathBeanDefinitionScanner</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>(registry, <span class="keyword">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ClassPathBeanDefinitionScanner</span><span class="params">(BeanDefinitionRegistry registry, <span class="keyword">boolean</span> useDefaultFilters)</span> </span>&#123;</span><br><span class="line"><span class="comment">//这里也有getOrCreateEnvironment()方法来获取环境,在上一步已经做了,所以这步是直接获取上一步的结果即可.      </span></span><br><span class="line">		<span class="keyword">this</span>(registry, useDefaultFilters, getOrCreateEnvironment(registry));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先对传入进来的 registry 进行非null的判断,</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ClassPathBeanDefinitionScanner</span><span class="params">(BeanDefinitionRegistry registry, <span class="keyword">boolean</span> useDefaultFilters,</span></span></span><br><span class="line"><span class="function"><span class="params">			Environment environment, @Nullable ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		Assert.notNull(registry, <span class="string">"BeanDefinitionRegistry must not be null"</span>);</span><br><span class="line">		<span class="keyword">this</span>.registry = registry;</span><br><span class="line">		<span class="comment">// 这里传入的是ture,也就是会走到这个if里面来.</span></span><br><span class="line">		<span class="keyword">if</span> (useDefaultFilters) &#123;</span><br><span class="line"><span class="comment">//org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#registerDefaultFilters, 往includeFilters 集合中添加Filter,这些添加的filter,点进去看即可.            </span></span><br><span class="line">			registerDefaultFilters();</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">// this.environment赋上传入进来的environment值.        </span></span><br><span class="line">		setEnvironment(environment);</span><br><span class="line"><span class="comment">// org.springframework.core.io.support.ResourcePatternUtils#getResourcePatternResolver进行判断,这里由于是ResourcePatternResolver,所以在第一个if就返回了.</span></span><br><span class="line"><span class="comment">//接着new一个CachingMetadataReaderFactory,传入进去resourceLoader,new这个类的内部也是可以看,就是对参数进行赋值,并没有做其他的什么事情了.      </span></span><br><span class="line"><span class="comment">//this.componentsIndex = CandidateComponentsIndexLoader.loadIndex(this.resourcePatternResolver.getClassLoader());获取出来的值Null.        </span></span><br><span class="line">		setResourceLoader(resourceLoader);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>





<p>scan(basePackages) 方法 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对传入进来的参数进行一个校验.</span></span><br><span class="line"><span class="comment">//scanner也是上面那步this.scanner = new ClassPathBeanDefinitionScanner(this)给new出来的.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">   Assert.notEmpty(basePackages, <span class="string">"At least one base package must be specified"</span>);</span><br><span class="line">   <span class="keyword">this</span>.scanner.scan(basePackages);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Perform a scan within the specified base packages.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> basePackages the packages to check for annotated classes</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> number of beans registered</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">scan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line"><span class="comment">// org.springframework.beans.factory.support.DefaultListableBeanFactory#getBeanDefinitionCount 走到这步来获取个数,还记得new AnnotatedBeanDefinitionReader(this)这个方法里面添加了五个processor吗?所以这里获取出来的beanCountAtScanStart大小就是5(默认对初始化做任何改动的情况下).</span></span><br><span class="line">	<span class="keyword">int</span> beanCountAtScanStart = <span class="keyword">this</span>.registry.getBeanDefinitionCount();</span><br><span class="line"><span class="comment">//从名字上看,这个方法是真正的做扫描的.其实Spring中,scan都算不做事的,doScan才是真的做事的。到后面还有getBean不是做事的,doGetBean才是做事的,createBean也是的. </span></span><br><span class="line"><span class="comment">//doScan做的事情可以看到,读取包下的类,然后根据filter条件来过滤,满足条件的话,就会封装成ScannedGenericBeanDefinition,最后是一个集合包装的该包下全部满足条件的. 然后就是接着对 sbd进行注解的处理,比如有些打入了Lazy等注解的,都要读取出来,存入bd的信息中.最后再检查一遍db,如果没问题的话,就会根据beanName和bd,new一个BeanDefinitionHolder出来,最后注册到beanFactory中去,也就是放入BeanFactory的beanDeifitionMap中去.    </span></span><br><span class="line">	doScan(basePackages);</span><br><span class="line">	<span class="comment">// Register annotation config processors, if necessary.</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.includeAnnotationConfig) &#123;</span><br><span class="line"><span class="comment">// 先获取出beanFactory,先调用beanFactory的getDependencyComparator和getAutowireCandidateResolver方法,如果满足条件的话,就会有对应的set方法.然后紧接着就是判断beanFactory中是否包含一些bd,如果是不包含的话,这里就会添加进去. 这里判断的值,再最初new reader()的时候已经有添加到BeanFactory的beanDifitionMap中去.        </span></span><br><span class="line">		AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="keyword">this</span>.registry);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 这里返回int参数,但是 this.scanner.scan(basePackages); 好像并没有使用到返回值.</span></span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">this</span>.registry.getBeanDefinitionCount() - beanCountAtScanStart);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Perform a scan within the specified base packages,</span></span><br><span class="line"><span class="comment">* returning the registered bean definitions.</span></span><br><span class="line"><span class="comment">* &lt;p&gt;This method does &lt;i&gt;not&lt;/i&gt; register an annotation config processor</span></span><br><span class="line"><span class="comment">* but rather leaves this up to the caller.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> basePackages the packages to check for annotated classes</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> set of beans registered if any for tooling registration purposes (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">doScan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先是对传入进来的参数进行检验.</span></span><br><span class="line">	Assert.notEmpty(basePackages, <span class="string">"At least one base package must be specified"</span>);</span><br><span class="line">    <span class="comment">// 存BeanDefinitionHolder的集合,也是最后要返回的.</span></span><br><span class="line">	Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">	<span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line"><span class="comment">//根据传入进去的包名字,读取出包名字下的所有文件,然后迭代这些文件,这些文件要有能读的权限,再走isCandidateComponent(metadataReader)这个方法,其中就有使用 excludeFilters和includeFilters,这二个filter来过滤进行一些判断操作. 返回ture,就会往下走,new一个ScannedGenericBeanDefinition,其中beanClass就是这个类的全限定名字.比如这里(com.iyang.spring.bean.YangBeanOne),我们的是这个.</span></span><br><span class="line"><span class="comment">//这就是这个方法,扫描,然后根据特定filter,如果是满足条件的话,就会new一个sbd,然后放入Set集合中,返回. </span></span><br><span class="line">		Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">for</span> (BeanDefinition candidate : candidates) &#123;</span><br><span class="line"><span class="comment">//org.springframework.context.annotation.AnnotationScopeMetadataResolver#resolveScopeMetadata,走的这个方法,因AnnotationConfigUtils.attributesFor(...)方法返回的是null,所以这个里面就仅仅只是new了一个ScopeMetadata对象返回了           </span></span><br><span class="line">			ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);</span><br><span class="line"><span class="comment">//scope的值是singletone.这不就是我们熟悉的单例嘛.            </span></span><br><span class="line">			candidate.setScope(scopeMetadata.getScopeName());</span><br><span class="line"><span class="comment">//获取出这个bean的名字            </span></span><br><span class="line">			String beanName = <span class="keyword">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="keyword">this</span>.registry);</span><br><span class="line"><span class="comment">// db是 AbstractBeanDefinition的话,这里肯定是,从AbstractBeanDefinition这个名字上看,是一个抽象的，也就是应该是父类.            </span></span><br><span class="line">			<span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line"><span class="comment">//beanDefinition.applyDefaults(this.beanDefinitionDefaults)该方法是对一些参数进行赋值操作. </span></span><br><span class="line"><span class="comment">//                </span></span><br><span class="line">				postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);</span><br><span class="line">			&#125;</span><br><span class="line"><span class="comment">// bd是AnnotatedBeanDefinition或者其子类.            </span></span><br><span class="line">			<span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line"><span class="comment">// 该方是对bd的Lazy.calss,Primary.class,DependsOn.class,Role.class,Description.class这些注解进行获取,如果有的话,就会调用bd对应的set方法给值set进去. 当然我们这里的bean没有这些属性.这里可自行加入一些注入,然后debug到这个地方进行看.</span></span><br><span class="line">                AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);</span><br><span class="line">				&#125;</span><br><span class="line"><span class="comment">// 检查registry中是否含有这个beanName,如果没包含的话,就直接返回ture.            </span></span><br><span class="line">			<span class="keyword">if</span> (checkCandidate(beanName, candidate)) &#123;</span><br><span class="line"><span class="comment">// 传入bean和beanName, new一个bean的Holder出来,也就是bean的持有者的意思.其实个人觉得这里是对bean进行一层封装,Holder更抽象地理解点.                </span></span><br><span class="line">				BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(candidate, beanName);</span><br><span class="line"><span class="comment">//scopeMetadata中获取出getScopedProxyMode,如果是No的话,就直接返回definitionHolder         </span></span><br><span class="line">				definitionHolder =</span><br><span class="line">							AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line"><span class="comment">// 添加到最外层的集合中                </span></span><br><span class="line">				beanDefinitions.add(definitionHolder);</span><br><span class="line"><span class="comment">//org.springframework.beans.factory.support.DefaultListableBeanFactory#registerBeanDefinition,最后走到了这里,该方法会先对传入进来的参数进行非null的判断,如果bd是AbstractBeanDefinition的话,就会强转调用其validate()方法,进行检验. 在从this.beanDefinitionMap中获取,根据beanName,第一次肯定是获取不到的,走到else.else中在判断hasBeanCreationStarted(),这里返回的是flase,也就是走到了else的else中去了,根据beanName和bean存入到this.beanDefinitionMap中,然后beanName添加到beanDefinitionNames集合中.  这就是这步根据beanName和bean放入beanFactory的beanDefinitionMap集合中.               </span></span><br><span class="line">				registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> beanDefinitions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li><p>this() 方法 :  该方法中主要是初始化了 this.reader 和 this.scanner这个参数,当然了,其中还有一些环境等信息   的初始化. this.reader的时候,是有往beanFactroy中添加五个默认要添加的bd,也就是添加到了 BeanFactory的BeanDefitionMap中.  this.scanner 也是对一些环境等信息初始化 , 然后下接来的方法就是使用  this.scanner来进扫描 class,然后满足条件的,就封装成bd,注册到beanFactory中去.</p>
</li>
<li><p>register() 方法里面调用 this.reader.register(componentClasses); 该方法就是读取包下的class信息,然后满足条件的就封装成bd,同时还会对注解@Lazy等也会读取,如果是有这些注解的话,就会调用bd对应的set方法,给赋值进去,最后将bd给注册到BeanFactory的beanDefitionMap中去即可.</p>
</li>
</ul>
<p>  可以看到 this() 方法 和 register()方法,主要是对环境的初始化和根据传入进来的包名来进行扫描获取class信息,满足条件的class信息就会转化为bd,然后注册到beanFactory中去.</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java源码</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring初始化(二)</title>
    <url>/2020/06/28/spring/Spring_Refresh/</url>
    <content><![CDATA[<h4 id="题记"><a href="#题记" class="headerlink" title="题记"></a>题记</h4><p>​    昨天记录了this()和 register() 这二个方法, 这二个方法都是为后面的做铺垫,也就是提前初始化了一些环境和读取class文件.  refresh() 这个方法才是最重要的,其中包含的内容是非常多的. 所以这里慢慢进行更新其方法的内容.</p>
<h4 id="refresh-方法"><a href="#refresh-方法" class="headerlink" title="refresh 方法"></a>refresh 方法</h4><p>这里可以看到的是, refresh()该方法里面,基本都是走了很多方法的. 所以挨个看方法,有些方法是留给子类的,也就是进行扩展的. 从synchronized这个关键字来看,这里只容许一次只有一个线程来执行这个方法.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">      <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">      prepareRefresh();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line"></span><br><span class="line">      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * org.springframework.beans.factory.support.DefaultListableBeanFactory</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">         postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">         invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">         registerBeanPostProcessors(beanFactory);</span><br><span class="line">         <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">         initMessageSource();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">         initApplicationEventMulticaster();</span><br><span class="line">         <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">         onRefresh();</span><br><span class="line">         <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">         registerListeners();</span><br><span class="line">         <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">         finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">         finishRefresh();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line">                  <span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">         destroyBeans();</span><br><span class="line">         <span class="comment">// Reset 'active' flag.</span></span><br><span class="line">         cancelRefresh(ex);</span><br><span class="line">         <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">// Reset common introspection caches in Spring's core, since we</span></span><br><span class="line">         <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">         resetCommonCaches();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="refresh-prepareRefresh-方法"><a href="#refresh-prepareRefresh-方法" class="headerlink" title="refresh.prepareRefresh() 方法"></a>refresh.prepareRefresh() 方法</h4><p> prepareRefresh() 方法:  可以看到该方法先是对closed/active参数进行设置,然后对Enviornment进行调用检验方法,接着判断this.earlyApplicationListeners是否有值来操作this.applicationListeners. 最后初始化earlyApplicationEvents这个集合.   这里大概还是进行一些初始化操作.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Prepare this context for refreshing, setting its startup date and</span></span><br><span class="line"><span class="comment"> * active flag as well as performing any initialization of property sources.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// Switch to active.</span></span><br><span class="line">   <span class="keyword">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line">  <span class="comment">// closed设置为false,active设置为true.  </span></span><br><span class="line">   <span class="keyword">this</span>.closed.set(<span class="keyword">false</span>);</span><br><span class="line">   <span class="keyword">this</span>.active.set(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 根据log级别来进行输出 </span></span><br><span class="line">   <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">      logger.info(<span class="string">"Refreshing "</span> + <span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Initialize any placeholder property sources in the context environment.</span></span><br><span class="line">   <span class="comment">// 目前该方法没有调用;目前没有做任何事情. 目测是应该留给子类之类的进行扩展的.</span></span><br><span class="line">   initPropertySources();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Validate that all properties marked as required are resolvable:</span></span><br><span class="line">   <span class="comment">// see ConfigurablePropertyResolver#setRequiredProperties</span></span><br><span class="line"><span class="comment">//先调用getEnvironment()获取this()方法中创建出来的Environment来,然后走validateRequiredProperties方法来进行一些检验,</span></span><br><span class="line"><span class="comment">//org.springframework.core.env.AbstractPropertyResolver#validateRequiredProperties</span></span><br><span class="line"><span class="comment">//最后是走到了这个方法,如果this.requiredProperties中是有值的话,那么这里就会抛出一个异常来    </span></span><br><span class="line">   getEnvironment().validateRequiredProperties();</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// Store pre-refresh ApplicationListeners...</span></span><br><span class="line"><span class="comment">// 这里是对 earlyApplicationListeners 进行判断,如果有值的话,就先会clear掉,然后再addAll</span></span><br><span class="line"><span class="comment">//如果是没有值的话,就会new一个集合,然后赋值给this.earlyApplicationListeners参数   </span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.earlyApplicationListeners == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.earlyApplicationListeners = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="keyword">this</span>.applicationListeners);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Reset local application listeners to pre-refresh state.</span></span><br><span class="line">      <span class="keyword">this</span>.applicationListeners.clear();</span><br><span class="line">      <span class="keyword">this</span>.applicationListeners.addAll(<span class="keyword">this</span>.earlyApplicationListeners);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Allow for the collection of early ApplicationEvents,</span></span><br><span class="line">   <span class="comment">// to be published once the multicaster is available...</span></span><br><span class="line"><span class="comment">// 最后初始化一下 this.earlyApplicationEvents 这个参数</span></span><br><span class="line">   <span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="refresh-obtainFreshBeanFactory-方法"><a href="#refresh-obtainFreshBeanFactory-方法" class="headerlink" title="refresh.obtainFreshBeanFactory()方法"></a>refresh.obtainFreshBeanFactory()方法</h4><p>这个方法是有方法一个BeanFactory回去的.   </p>
<p>该方法对beanFactory进行SerializationId,然后获取BeanFactory,最后返回这个BeanFactory.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line"><span class="comment"> *  告诉子类刷新内部Bean工厂</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the fresh BeanFactory instance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #refreshBeanFactory()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getBeanFactory()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//this.refreshed.compareAndSet(false, true)该方法如果返回的是false的话,就会有异常给抛出来</span></span><br><span class="line"><span class="comment">//不是false的话,接着就是对beanFactory设置SerializationId    </span></span><br><span class="line">   refreshBeanFactory();</span><br><span class="line"><span class="comment">// org.springframework.context.support.GenericApplicationContext#getBeanFactory</span></span><br><span class="line"><span class="comment">//该方法直接返回DefaultListableBeanFactory    </span></span><br><span class="line">   ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">"Bean factory for "</span> + getDisplayName() + <span class="string">": "</span> + beanFactory);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//返回获取的beanFactory.    </span></span><br><span class="line">   <span class="keyword">return</span> beanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="refresh-prepareBeanFactory-方法"><a href="#refresh-prepareBeanFactory-方法" class="headerlink" title="refresh.prepareBeanFactory() 方法"></a>refresh.prepareBeanFactory() 方法</h4><p>从这个方法来看,是对BeanFactory的准备. </p>
<p>该方法可以先是对classLoader,expressionResolver,propertyEditorRegistrar添加到beanFactory中去. 然后添加ApplicationContextAwareProcessor(BeanPostProcessor)到BeanFactory,然后忽略到一些接口的注入到beanFactory中去. </p>
<p>设置 BeanFactory , ResourceLoader , ApplicationEventPublisher, ApplicationContext等bean到BeanFactory中去.</p>
<p>最后就是一些environment,systemProperties,systemEnvironment等注入到BeanFactory中去.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Configure the factory's standard context characteristics,</span></span><br><span class="line"><span class="comment"> * such as the context's ClassLoader and post-processors.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanFactory the BeanFactory to configure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// Tell the internal bean factory to use the context's class loader etc.</span></span><br><span class="line"><span class="comment">//给beanFactory设置classLoader(加载bean) </span></span><br><span class="line">   beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line"><span class="comment">//这里根据classLoader来获取解析器,然后set到BeanFactory中去.(解析bean定义的表达式)</span></span><br><span class="line">   beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line"><span class="comment">//属性编辑注册器,set到BeanFactory中</span></span><br><span class="line">   beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> ResourceEditorRegistrar(<span class="keyword">this</span>, getEnvironment()));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Configure the bean factory with context callbacks.</span></span><br><span class="line"><span class="comment">//添加ApplicationContextAwareProcessor到BeanFactory中.该类是有实现BeanPostProcessor的</span></span><br><span class="line"><span class="comment">//BeanPostProcessor是在bean初始化完后,调用BeanPostProcessor进行扩展.</span></span><br><span class="line">   beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</span><br><span class="line"><span class="comment">//忽略掉EnvironmentAware/EmbeddedValueResolverAware....ApplicationContextAware</span></span><br><span class="line"><span class="comment">//这六个接口的注入(依赖). 因为ApplicationContextAwareProcessor中有做了这些事</span></span><br><span class="line">   beanFactory.ignoreDependencyInterface(EnvironmentAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ResourceLoaderAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   beanFactory.ignoreDependencyInterface(MessageSourceAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ApplicationContextAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// BeanFactory interface not registered as resolvable type in a plain factory.</span></span><br><span class="line">   <span class="comment">// MessageSource registered (and found for autowiring) as a bean.</span></span><br><span class="line"><span class="comment">// BeanFactory,ResourceLoader,ApplicationEventPublisher,ApplicationContext这四个接口</span></span><br><span class="line"><span class="comment">//对应的bean都set到beanFactory中去.    </span></span><br><span class="line">   beanFactory.registerResolvableDependency(BeanFactory<span class="class">.<span class="keyword">class</span>, <span class="title">beanFactory</span>)</span>;</span><br><span class="line">   beanFactory.registerResolvableDependency(ResourceLoader<span class="class">.<span class="keyword">class</span>, <span class="title">this</span>)</span>;</span><br><span class="line">   beanFactory.registerResolvableDependency(ApplicationEventPublisher<span class="class">.<span class="keyword">class</span>, <span class="title">this</span>)</span>;</span><br><span class="line">   beanFactory.registerResolvableDependency(ApplicationContext<span class="class">.<span class="keyword">class</span>, <span class="title">this</span>)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Register early post-processor for detecting inner beans as ApplicationListeners.</span></span><br><span class="line"><span class="comment">//添加ApplicationListenerDetector(BeanPostProcessor)到beanFactory中去.</span></span><br><span class="line">   beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found.</span></span><br><span class="line">   <span class="keyword">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">      <span class="comment">// Set a temporary ClassLoader for type matching.</span></span><br><span class="line">      beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Register default environment beans.</span></span><br><span class="line"><span class="comment">//如果beanFactory中没有ENVIRONMENT_BEAN_NAME这个bean的话,就注入一个进去</span></span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// SYSTEM_PROPERTIES_BEAN_NAME也是一样,注入到beanFactory中去</span></span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//SYSTEM_ENVIRONMENT_BEAN_NAME同上    </span></span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="refresh-postProcessBeanFactory-方法"><a href="#refresh-postProcessBeanFactory-方法" class="headerlink" title="refresh.postProcessBeanFactory() 方法"></a>refresh.postProcessBeanFactory() 方法</h4><p>该方法目前在单个 Spring中是没有做任何事情的。 等到看SpringBoot源码的时候,这里就会有代码走进来,是进行根据包来扫描来获取class等信息的. 满足条件的class,就会当为bd给注册到beanFactory中去.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Modify the application context's internal bean factory after its standard</span></span><br><span class="line"><span class="comment"> * initialization. All bean definitions will have been loaded, but no beans</span></span><br><span class="line"><span class="comment"> * will have been instantiated yet. This allows for registering special</span></span><br><span class="line"><span class="comment"> * BeanPostProcessors etc in certain ApplicationContext implementations.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanFactory the bean factory used by the application context</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="refresh-invokeBeanFactoryPostProcessors-方法"><a href="#refresh-invokeBeanFactoryPostProcessors-方法" class="headerlink" title="refresh.invokeBeanFactoryPostProcessors() 方法"></a>refresh.invokeBeanFactoryPostProcessors() 方法</h4><p>可以看到这个方法,借助PostProcessorRegistrationDelegate来对PostProcessor进行处理。</p>
<p>先是对BeanDefinitionRegistryPostProcessor进行从beanFactory中获取出相应的名字数组,然后迭代这个数组,然后处理PriorityOrdered—&gt;Ordered—&gt; 没有,这个顺序,最后还有一个while循环迭代来检查BeanDefinitionRegistryPostProcessor是否都处理完了.</p>
<p>再接着就是处理BeanFactoryPostProcessor,处理方式是和BeanDefinitionRegistryPostProcessor一样的,顺序也是一样的.</p>
<p>最后就是调用beanFactory.clearMetadataCache()清除.</p>
<p>当然,这个里面有些上面 PostProcessor等待阅读SpringBoot的时候给补上来,因为到时候SpringBoot这里会有很多PostProcessor,这里目前是没有的.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Instantiate and invoke all registered BeanFactoryPostProcessor beans,</span></span><br><span class="line"><span class="comment"> * respecting explicit order if given.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Must be called before singleton instantiation.</span></span><br><span class="line"><span class="comment">BeanFactoryPostProcessor: 用来修改Spring容器中已经存在的bean定义.</span></span><br><span class="line"><span class="comment">BeanDefinitionRegistryPostProcessor: 是BeanFactoryPostProcessor的子类,作用和父类是一样的,不同的是,该使用的是BeanDefinitionRegistry对bean进行处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"><span class="comment">//org.springframework.context.support.AbstractApplicationContext#getBeanFactoryPostProcessors,由于这里只是启动了单个Spring,返回的集合是没有值的.</span></span><br><span class="line">   List&lt;BeanFactoryPostProcessor&gt; postProcessorsList = getBeanFactoryPostProcessors();</span><br><span class="line">   <span class="comment">//System.out.println("postProcessorsList value ---&gt; " + postProcessorsList);</span></span><br><span class="line">   <span class="comment">// System.out.println("beanFactory  value 111111 ---&gt; " + beanFactory);</span></span><br><span class="line"><span class="comment">//借助PostProcessorRegistrationDelegate来处理PostProcessors.</span></span><br><span class="line"><span class="comment">//对传入postProcessorsList进行迭代,如果PostProcessor是BeanDefinitionRegistryPostProcessor的话,就会强转然后调用postProcessBeanDefinitionRegistry方法(传入参数是beanFacotry),添加到registryProcessors集合中.如果不是的话,就会添加到regularPostProcessors集合中.</span></span><br><span class="line"><span class="comment">//根据BeanDefinitionRegistryPostProcessor,从beanFactory中获取postProcessorNames,</span></span><br><span class="line"><span class="comment">//进行迭代,如果是有PriorityOrdered接口的子类的话,就会从beanFactory中根据bean名字,类.class来获取BeanDefinitionRegistryPostProcessor,并且添加到currentRegistryProcessors集合中,ppName(名字的值)也会添加到processedBeans该集合中</span></span><br><span class="line"><span class="comment">//对currentRegistryProcessors进行排序,全部添加到registryProcessors集合中,invokeBeanDefinitionRegistryPostProcessors()该方法是调用BeanDefinitionRegistryPostProcessors的,调用完了然后清空currentRegistryProcessors这个集合.</span></span><br><span class="line"><span class="comment">//同样方法获取postProcessorNames,processedBeans集合中不包含并且是Ordered的子类,然后添加到currentRegistryProcessors集合中,ppName也会添加到processedBeans集合中,同样的排序方式,添加到registryProcessors中,再调用invokeBeanDefinitionRegistryPostProcessors()方法,currentRegistryProcessors清空该集合.</span></span><br><span class="line"><span class="comment">// 也就是到这里,可以看出来,处理的顺序,先是处理PriorityOrdered,再处理Ordered.</span></span><br><span class="line"><span class="comment">// 然后使用一个while循环,继续获取BeanDefinitionRegistryPostProcessor对应的postProcessorNames,这个地方是为了防止有些没有调用到的,并且是processedBeans集合中不包含的,然后就会放入到currentRegistryProcessors这个集合中,排序currentRegistryProcessors集合,全部添加到registryProcessors中,调用invokeBeanDefinitionRegistryPostProcessors,也就是调用具体的PostProcessors.</span></span><br><span class="line"><span class="comment">//invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);</span></span><br><span class="line"><span class="comment">//invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);</span></span><br><span class="line"><span class="comment">// 之前的二个集合,registryProcessors和regularPostProcessors,在这里还是会继续调用.</span></span><br><span class="line"><span class="comment">//然后根据BeanFactoryPostProcessor.class获取postProcessorNames数组,与上面的也是同样的方法,</span></span><br><span class="line"><span class="comment">//对postProcessorNames进行迭代,如果是processedBeans(上面装的名字)如果包含了,就会跳过.</span></span><br><span class="line"><span class="comment">/** 如果ppName,也就是迭代的值,是有PriorityOrdered的子类的话,就会从走beanFactory.getBean(ppName, BeanFactoryPostProcessor.class)获取出BeanFactoryPostProcessor放入到priorityOrderedPostProcessors集合中.  如果是Ordered的子类,就将名字放入到orderedPostProcessorNames集合中,如果上面三种都不满足的话,就会放入到nonOrderedPostProcessorNames集合中.</span></span><br><span class="line"><span class="comment">然后先排序priorityOrderedPostProcessors,再走invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);</span></span><br><span class="line"><span class="comment">接着迭代orderedPostProcessorNames集合,然后从beanFactory中获取BeanFactoryPostProcessor,再就做与priorityOrderedPostProcessors一样的操作.</span></span><br><span class="line"><span class="comment">最后在做nonOrderedPostProcessors这个集合的,操作是与orderedPostProcessorNames一摸一样的.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">最后在调用一个beanFactory的clearMetadataCache方法.</span></span><br><span class="line"><span class="comment">可以看到这个方法是先对BeanDefinitionRegistryPostProcessor.class进行处理,然后根据顺序PriorityOrdered--&gt;Ordered---&gt;没有, 这样的顺序执行的.</span></span><br><span class="line"><span class="comment">然后再处理BeanFactoryPostProcessor.class,处理方式是和BeanDefinitionRegistryPostProcessor.class也是一样的,根据顺序来进行处理.</span></span><br><span class="line"><span class="comment">*/</span>    </span><br><span class="line">   PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, postProcessorsList);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime</span></span><br><span class="line">   <span class="comment">// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)</span></span><br><span class="line"><span class="comment">// 获取beanFactory的tempClassLoader加载,并且beanFactory是包含了loadTimeWeaver这个bean的,</span></span><br><span class="line"><span class="comment">//就会走if方法,可以看到是添加LoadTimeWeaverAwareProcessor到beanFactory的postProcessor中,</span></span><br><span class="line"><span class="comment">//然后添加一个ClassLoader到beanFactory中   </span></span><br><span class="line">   <span class="keyword">if</span> (beanFactory.getTempClassLoader() == <span class="keyword">null</span> &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">      beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="refresh-registerBeanPostProcessors-方法"><a href="#refresh-registerBeanPostProcessors-方法" class="headerlink" title="refresh.registerBeanPostProcessors() 方法"></a>refresh.registerBeanPostProcessors() 方法</h4><p>仔细看中这个方法,其实和上一个方法走的逻辑好像是有点类似的. 也是借助PostProcessorRegistrationDelegate来完成其逻辑的.</p>
<p>先是从BeanFactory中获取BeanPostProcessor对用的postProcessorNames数组。</p>
<p>然后分为 PriorityOrdered –&gt; Ordered –&gt; 既不是PriorityOrdered ,也不是Ordered  –&gt; MergedBeanDefinitionPostProcessor子类,  这样的先后顺序,走registerBeanPostProcessors,这个是将PostProcessros注册到Spring的beanFactory中(Spring容器).</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Instantiate and register all BeanPostProcessor beans,</span></span><br><span class="line"><span class="comment"> * respecting explicit order if given.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Must be called before any instantiation of application beans.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">   PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-------------------</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先是根据BeanPostProcessor获取出postProcessorNames数组,这个根据和上面的方法很相似.    </span></span><br><span class="line">		String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">				<span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Register BeanPostProcessorChecker that logs an info message when</span></span><br><span class="line">		<span class="comment">// a bean is created during BeanPostProcessor instantiation, i.e. when</span></span><br><span class="line">		<span class="comment">// a bean is not eligible for getting processed by all BeanPostProcessors.</span></span><br><span class="line"><span class="comment">//然后从beanFactory中获取出个数 + postProcessorNames数组长度再加上一个1.     </span></span><br><span class="line">		<span class="keyword">int</span> beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + <span class="number">1</span> + postProcessorNames.length;</span><br><span class="line"><span class="comment">//添加一个BeanPostProcessorChecker到beanFactory中.从名字上来,这个PostProcessor应该是进行检查的操作.</span></span><br><span class="line">		beanFactory.addBeanPostProcessor(<span class="keyword">new</span> BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Separate between BeanPostProcessors that implement PriorityOrdered,</span></span><br><span class="line">		<span class="comment">// Ordered, and the rest.</span></span><br><span class="line">		List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		List&lt;BeanPostProcessor&gt; internalPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 对 postProcessorNames 进行遍历;同时使用不同类型的集合来存储数据</span></span><br><span class="line"><span class="comment">//主要是根据是否是PriorityOrdered的子类,是的话就会放入到priorityOrderedPostProcessors集合中,接着在判断是否是MergedBeanDefinitionPostProcessor,如果是的话,就会放入到internalPostProcessors集合中</span></span><br><span class="line"><span class="comment">//是不是orderd的子类,是的话,就会放入到orderedPostProcessorNames集合中,</span></span><br><span class="line"><span class="comment">//如果上面二者都不的话,就会放入到nonOrderedPostProcessorNames集合中  </span></span><br><span class="line">		<span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">			<span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">				BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">				priorityOrderedPostProcessors.add(pp);</span><br><span class="line">				<span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">					internalPostProcessors.add(pp);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">				orderedPostProcessorNames.add(ppName);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// First, register the BeanPostProcessors that implement PriorityOrdered.</span></span><br><span class="line"><span class="comment">//先处理priorityOrderedPostProcessors这个集合中的数据.先排序,然后调用registerBeanPostPtocessors方法.</span></span><br><span class="line">		sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">		registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Next, register the BeanPostProcessors that implement Ordered.</span></span><br><span class="line"><span class="comment">//在处理orderedPostProcessorNames集合中的数据,发现如果也是MergedBeanDefinitionPostProcessor或者其子类的话,也就放入到internalPostProcessors集合中,也就是这里先不处理.</span></span><br><span class="line">		List&lt;BeanPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (String ppName : orderedPostProcessorNames) &#123;</span><br><span class="line">			BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">			orderedPostProcessors.add(pp);</span><br><span class="line">			<span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">				internalPostProcessors.add(pp);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//排序,处理上面不是MergedBeanDefinitionPostProcessor的或其子类,并且是 orderedPostProcessorNames集合中的数据</span></span><br><span class="line">		sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">		registerBeanPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Now, register all regular BeanPostProcessors.</span></span><br><span class="line"><span class="comment">//最后就处理既不是PriorityOrdered,也不是Ordered的,如果也是MergedBeanDefinitionPostProcessor或者其子类的话,这里也会放入到internalPostProcessors集合中 </span></span><br><span class="line">		List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (String ppName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">			BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">			nonOrderedPostProcessors.add(pp);</span><br><span class="line">			<span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">				internalPostProcessors.add(pp);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//这里先处理nonOrderedPostProcessorNames中的数据并且不是 MergedBeanDefinitionPostProcessor的子类.</span></span><br><span class="line">		registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Finally, re-register all internal BeanPostProcessors.</span></span><br><span class="line"><span class="comment">//最后排序下 MergedBeanDefinitionPostProcessor子类的集合,调用registerBeanPostProcessors方法,注册到BeanFactory中去.   </span></span><br><span class="line">		sortPostProcessors(internalPostProcessors, beanFactory);</span><br><span class="line">		registerBeanPostProcessors(beanFactory, internalPostProcessors);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Re-register post-processor for detecting inner beans as ApplicationListeners,</span></span><br><span class="line">		<span class="comment">// moving it to the end of the processor chain (for picking up proxies etc).</span></span><br><span class="line"><span class="comment">//最后添加一个ApplicationListenerDetector到beanFactory中去,并且ApplicationListenerDetector是有实现MergedBeanDefinitionPostProcessor接口的.</span></span><br><span class="line">		beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(applicationContext));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h4 id="refersh-initMessageSource-方法"><a href="#refersh-initMessageSource-方法" class="headerlink" title="refersh.initMessageSource() 方法"></a>refersh.initMessageSource() 方法</h4><p>  这个方法主要是对 MESSAGE_SOURCE_BEAN_NAME 是否在beanFactory中进行判断.如果已经在了的话,就会判断是不是HierarchicalMessageSource类型,继续判断其ParentMessageSource是不是null,如果是null的话,就会getInternalParentMessageSource调用初始化获取一些值给赋值进去.</p>
<p>  如果beanFactory中没有的话,就会先new一个,然后也会setParentMessageSource值进去,最后注册到beanFactory中去.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize the MessageSource.</span></span><br><span class="line"><span class="comment"> * Use parent's if none defined in this context.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initMessageSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//先获取BeanFactory.  </span></span><br><span class="line">   ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line"><span class="comment">// beanFactory中包含MESSAGE_SOURCE_BEAN_NAME</span></span><br><span class="line">   <span class="keyword">if</span> (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) &#123;</span><br><span class="line"> <span class="comment">//获取出出来的bean赋值给this.messageSource      </span></span><br><span class="line">      <span class="keyword">this</span>.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      <span class="comment">// Make MessageSource aware of parent MessageSource.</span></span><br><span class="line"><span class="comment">//this.parent不是null并且bean是HierarchicalMessageSource</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.parent != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.messageSource <span class="keyword">instanceof</span> HierarchicalMessageSource) &#123;</span><br><span class="line">        <span class="comment">//强转  </span></span><br><span class="line">         HierarchicalMessageSource hms = (HierarchicalMessageSource) <span class="keyword">this</span>.messageSource;</span><br><span class="line">  <span class="comment">// hms获取出来的parentMessageSource是null情况下,getInternalParentMessageSource()返回的值赋值给hms的ParentMessageSource属性  </span></span><br><span class="line">         <span class="keyword">if</span> (hms.getParentMessageSource() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Only set parent context as parent MessageSource if no parent MessageSource</span></span><br><span class="line">            <span class="comment">// registered already.</span></span><br><span class="line">            hms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">         logger.debug(<span class="string">"Using MessageSource ["</span> + <span class="keyword">this</span>.messageSource + <span class="string">"]"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// beanFactory中不包含MESSAGE_SOURCE_BEAN_NAME    </span></span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Use empty MessageSource to be able to accept getMessage calls.</span></span><br><span class="line"><span class="comment">//自己new一个DelegatingMessageSource,dms    </span></span><br><span class="line">      DelegatingMessageSource dms = <span class="keyword">new</span> DelegatingMessageSource();</span><br><span class="line"><span class="comment">//调用getInternalParentMessageSource()方法的返回值给set进去.  </span></span><br><span class="line">      dms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line">      <span class="keyword">this</span>.messageSource = dms;</span><br><span class="line"><span class="comment">// 注入到 beanFactroy中去       </span></span><br><span class="line">      beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, <span class="keyword">this</span>.messageSource);</span><br><span class="line"><span class="comment">// 根据log的级别来打印.       </span></span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">         logger.debug(<span class="string">"Unable to locate MessageSource with name '"</span> + MESSAGE_SOURCE_BEAN_NAME +</span><br><span class="line">               <span class="string">"': using default ["</span> + <span class="keyword">this</span>.messageSource + <span class="string">"]"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="refresh-initApplicationEventMulticaster-方法"><a href="#refresh-initApplicationEventMulticaster-方法" class="headerlink" title="refresh.initApplicationEventMulticaster() 方法"></a>refresh.initApplicationEventMulticaster() 方法</h4><p>  该方法可以看到也是对APPLICATION_EVENT_MULTICASTER_BEAN_NAME是否在bean的判断，如果有的话,就会get出来,没有的话,就会new一个出来,然后注册到beanFactory中去.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize the ApplicationEventMulticaster.</span></span><br><span class="line"><span class="comment"> * Uses SimpleApplicationEventMulticaster if none defined in the context.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.context.event.SimpleApplicationEventMulticaster</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initApplicationEventMulticaster</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 先获取beanFactory   </span></span><br><span class="line">   ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line"> <span class="comment">//判断beanFactory是不是有APPLICATION_EVENT_MULTICASTER_BEAN_NAME这个bean,</span></span><br><span class="line"> <span class="comment">//如果是有的话,就会获取出来.然后进行log的级别,判断要不要打印</span></span><br><span class="line">   <span class="keyword">if</span> (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.applicationEventMulticaster =</span><br><span class="line">            beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">         logger.debug(<span class="string">"Using ApplicationEventMulticaster ["</span> + <span class="keyword">this</span>.applicationEventMulticaster + <span class="string">"]"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="comment">//如果beanFactory是不包含的话,那么久new一个SimpleApplicationEventMulticaster出来,</span></span><br><span class="line"> <span class="comment">//然后注册到beanFactory中去,最后根据log的级别来判断打印</span></span><br><span class="line">  </span><br><span class="line">      <span class="keyword">this</span>.applicationEventMulticaster = <span class="keyword">new</span> SimpleApplicationEventMulticaster(beanFactory);</span><br><span class="line">      beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, <span class="keyword">this</span>.applicationEventMulticaster);</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">         logger.debug(<span class="string">"Unable to locate ApplicationEventMulticaster with name '"</span> +</span><br><span class="line">               APPLICATION_EVENT_MULTICASTER_BEAN_NAME +</span><br><span class="line">               <span class="string">"': using default ["</span> + <span class="keyword">this</span>.applicationEventMulticaster + <span class="string">"]"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="refresh-onRefresh-方法"><a href="#refresh-onRefresh-方法" class="headerlink" title="refresh.onRefresh() 方法"></a>refresh.onRefresh() 方法</h4><p> 该方法时留给子类的。 如果是SpringBoot启动的话,这里就会去new Tomcat,然后启动web相应的环境. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Template method which can be overridden to add context-specific refresh work.</span></span><br><span class="line"><span class="comment"> * Called on initialization of special beans, before instantiation of singletons.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This implementation is empty.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeansException in case of errors</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #refresh()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">   <span class="comment">// For subclasses: do nothing by default.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="refresh-registerListeners-方法"><a href="#refresh-registerListeners-方法" class="headerlink" title="refresh.registerListeners() 方法"></a>refresh.registerListeners() 方法</h4><p> 该方法是先获取 ApplicationListeners,如果是有值的话,就会添加到AbstractApplicationEventMulticaster的ListenerRetriever的applicationListeners集合中去.</p>
<p>根据ApplicationListener.class获取对应的bean信息,然后迭代,最后会添加到AbstractApplicationEventMulticaster的ListenerRetriever的applicationListenerBeans属性中去</p>
<p>最后是对this.earlyApplicationEvents中的事件进行发布</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add beans that implement ApplicationListener as listeners.</span></span><br><span class="line"><span class="comment"> * Doesn't affect other listeners, which can be added without being beans.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerListeners</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// Register statically specified listeners first.</span></span><br><span class="line"><span class="comment">//getApplicationListeners()获取AbstractApplicationContext中的applicationListeners</span></span><br><span class="line"><span class="comment">//getApplicationEventMulticaster()方法获取的applicationEventMulticaster,是在</span></span><br><span class="line"><span class="comment">//initApplicationEventMulticaster方法中有初始化的.    </span></span><br><span class="line"><span class="comment">//org.springframework.context.event.AbstractApplicationEventMulticaster#addApplicationListener,最后是走到了这里, </span></span><br><span class="line"><span class="comment">//this.defaultRetriever.applicationListeners.add(listener);最后listener是添加到</span></span><br><span class="line"><span class="comment">//其内部内ListenerRetriever的applicationListeners参数中去了.    </span></span><br><span class="line">   <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123;</span><br><span class="line">      getApplicationEventMulticaster().addApplicationListener(listener);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">   <span class="comment">// uninitialized to let post-processors apply to them!</span></span><br><span class="line"><span class="comment">//根据ApplicationListener获取相应的beanNames数组,这里可以看到和之前获取PostProcessor是一样的</span></span><br><span class="line">   String[] listenerBeanNames = getBeanNamesForType(ApplicationListener<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line"><span class="comment">//然后迭代, getApplicationListenerBean是走到了</span></span><br><span class="line"><span class="comment">//org.springframework.context.event.AbstractApplicationEventMulticaster#addApplicationListenerBean,也就是添加到了其内部类ListenerRetriever的applicationListenerBeans属性里面    </span></span><br><span class="line">   <span class="keyword">for</span> (String listenerBeanName : listenerBeanNames) &#123;</span><br><span class="line">      getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Publish early application events now that we finally have a multicaster...</span></span><br><span class="line"><span class="comment">//使用this.earlyApplicationEvents的集合的值,赋值给变量earlyEventsToProcess,</span></span><br><span class="line"><span class="comment">//然后给this.earlyApplicationEvents重置为null   </span></span><br><span class="line">   Set&lt;ApplicationEvent&gt; earlyEventsToProcess = <span class="keyword">this</span>.earlyApplicationEvents;</span><br><span class="line">   <span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">null</span>;</span><br><span class="line"> <span class="comment">//集合不是null并且是有值的话,   </span></span><br><span class="line">   <span class="keyword">if</span> (earlyEventsToProcess != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (ApplicationEvent earlyEvent : earlyEventsToProcess) &#123;</span><br><span class="line">  <span class="comment">//org.springframework.context.event.SimpleApplicationEventMulticaster#invokeListener,这里是走到了这里,可以看到是对这个事件进行发布.</span></span><br><span class="line"> <span class="comment">// 然后会根据ApplicationListener去走onApplicationEvent方法         </span></span><br><span class="line">         getApplicationEventMulticaster().multicastEvent(earlyEvent);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="refresh-finishBeanFactoryInitialization-方法"><a href="#refresh-finishBeanFactoryInitialization-方法" class="headerlink" title="refresh.finishBeanFactoryInitialization() 方法"></a>refresh.finishBeanFactoryInitialization() 方法</h4><p>该方法从名字上来,就是结束beanFactory的初始化,也就是我们前面准备的bd,postProcessor等信息,在这里都会使用到的.</p>
<p>可以看到该方法就是真正的实例化bean的方法。 大致就是getBean往下走,getBean如果是没有的话,就会走createBean,也就是没有就去创建嘛，就是这个意思。然后其创建的条件,是走各种beanPostProcessors来进行扩展bean. </p>
<p> beanFactory.preInstantiateSingletons() 是需要去阅读很多遍的. 不是一遍或者简单的几遍就ok了的.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Finish the initialization of this context's bean factory,</span></span><br><span class="line"><span class="comment"> * initializing all remaining singleton beans.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// Initialize conversion service for this context.</span></span><br><span class="line"><span class="comment">//如果beanFactory包含CONVERSION_SERVICE_BEAN_NAME,并且该CONVERSION_SERVICE_BEAN_NAME是</span></span><br><span class="line"><span class="comment">//ConversionService的子类的话,久满足条件,然后先从beanFactory中获取出bean,set给beanFactory中的conversionService属性    </span></span><br><span class="line">   <span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">         beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">      beanFactory.setConversionService(</span><br><span class="line">            beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Register a default embedded value resolver if no bean post-processor</span></span><br><span class="line">   <span class="comment">// (such as a PropertyPlaceholderConfigurer bean) registered any before:</span></span><br><span class="line">   <span class="comment">// at this point, primarily for resolution in annotation attribute values.</span></span><br><span class="line"><span class="comment">// beanFactory中没有EmbeddedValueResolver,也就是该方法返回的是false,然后就从environment中获取出来一个给add到beanFactory中去.    </span></span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">      beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span></span><br><span class="line"><span class="comment">//根据LoadTimeWeaverAware获取出对用的names数组</span></span><br><span class="line">   String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">         <span class="title">false</span>, <span class="title">false</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//然后迭代上面获取出来的数组,挨个调用getBean方法    </span></span><br><span class="line">   <span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;      </span><br><span class="line">      getBean(weaverAwareName);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Stop using the temporary ClassLoader for type matching.</span></span><br><span class="line"><span class="comment">// tempClassLoader,temp的ClassLoader设置为null    </span></span><br><span class="line">   beanFactory.setTempClassLoader(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Allow for caching all bean definition metadata, not expecting further changes.</span></span><br><span class="line"><span class="comment">//org.springframework.beans.factory.support.DefaultListableBeanFactory#freezeConfiguration,该方法时走的这里. 其中可以看到是给configurationFrozen设置为true,然后beanName的集合转化为数组,并且赋值给this.frozenBeanDefinitionNames这个数组    </span></span><br><span class="line">   beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line"><span class="comment">//这里面初始化bean,简单说一下逻辑. org.springframework.beans.factory.support.AbstractBeanFactory#getBean(java.lang.String)</span></span><br><span class="line"><span class="comment">//getBean() ---&gt; doGetBean() ---&gt;   createBean() ---&gt;  doCreateBean() </span></span><br><span class="line"><span class="comment">//然后再createBean和doCreateBean()方法之中,会根据条件上面的,获取BeanPostProcessors,然后判断走哦不走其各种BeanPostProceesors提供的方法.满足条件就会走,不满足也就自然不会走了.</span></span><br><span class="line"><span class="comment">//当然了这个方法的复杂程度是比较高的，是需要好好理解的。不是这个简简单单的几句话,还需要自己去读.</span></span><br><span class="line"><span class="comment">//起大致打代码走向就是这样,然后其中会走很多调用bean扩展的BeanPostProcessors，还有实现Init...接口后提供的afterS...等方法.    </span></span><br><span class="line">   beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="refresh-finishRefresh-方法"><a href="#refresh-finishRefresh-方法" class="headerlink" title="refresh.finishRefresh() 方法"></a>refresh.finishRefresh() 方法</h4><p>可以看到这个方法是清除了资源缓存, 然后 实现Lifecycle接口的子类,这里就会启动其start方法</p>
<p>发送一个ContextRefreshedEvent事件出去</p>
<p>最后将当前的 AbstractApplicationContext 添加到 LiveBeansView的applicationContexts集合中来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Finish the refresh of this context, invoking the LifecycleProcessor's</span></span><br><span class="line"><span class="comment"> * onRefresh() method and publishing the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.context.event.ContextRefreshedEvent&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// Clear context-level resource caches (such as ASM metadata from scanning).</span></span><br><span class="line">  <span class="comment">//清除资源缓存  </span></span><br><span class="line">   clearResourceCaches();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Initialize lifecycle processor for this context.</span></span><br><span class="line"><span class="comment">// 这个方法就会调用实现了 Lifecycle 接口的子类,并且执行其start方法    </span></span><br><span class="line">   initLifecycleProcessor();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Propagate refresh to lifecycle processor first.</span></span><br><span class="line">   getLifecycleProcessor().onRefresh();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Publish the final event.</span></span><br><span class="line"> <span class="comment">//发送一个刷新上下文的Event出去   </span></span><br><span class="line">   publishEvent(<span class="keyword">new</span> ContextRefreshedEvent(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Participate in LiveBeansView MBean, if active.</span></span><br><span class="line"><span class="comment">//org.springframework.context.support.LiveBeansView#applicationContexts</span></span><br><span class="line"><span class="comment">//将AbstractApplicationContext添加到liveBean的applicationContexts集合中    </span></span><br><span class="line">   LiveBeansView.registerApplicationContext(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="refresh-resetCommonCaches"><a href="#refresh-resetCommonCaches" class="headerlink" title="refresh.resetCommonCaches()"></a>refresh.resetCommonCaches()</h4><p>可以看到这个方法才是真正的清除各种集合缓存啥的操作. 是在finally代码快中,也就是说是必须要执行的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Reset Spring's common reflection metadata caches, in particular the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ReflectionUtils&#125;, &#123;<span class="doctag">@link</span> AnnotationUtils&#125;, &#123;<span class="doctag">@link</span> ResolvableType&#125;</span></span><br><span class="line"><span class="comment"> * and &#123;<span class="doctag">@link</span> CachedIntrospectionResults&#125; caches.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 4.2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ReflectionUtils#clearCache()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> AnnotationUtils#clearCache()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ResolvableType#clearCache()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> CachedIntrospectionResults#clearClassLoader(ClassLoader)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">resetCommonCaches</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   ReflectionUtils.clearCache();</span><br><span class="line">   AnnotationUtils.clearCache();</span><br><span class="line">   ResolvableType.clearCache();</span><br><span class="line">   CachedIntrospectionResults.clearClassLoader(getClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java源码</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis-mapper-xml-read</title>
    <url>/2020/12/25/mybatis/mybatis-mapper-xml-read/</url>
    <content><![CDATA[<h4 id="题记"><a href="#题记" class="headerlink" title="题记"></a>题记</h4><p> MyBatis是如何对 Mapper 文件中的sql进行处理呢？ 虽然上篇解析 mybatis-config.xml 是有进行说明的, 但是应该拿出来单独仔细解析下. 因为这个里面涉及到动态sql, 加上mapper文件自身也有很多标签内容,然后MyBatis是怎么读取出这些内容的呢？读取出来后,又是做了怎么样的处理, 然后达到了sql那种执行效果的呢？</p>
<p> 意思也就是,Mapper + 动态sql , 内容还是有点多的, 并且也很重要, 是非常有必要拿出来单独的仔细讲解下的.</p>
<h4 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h4><p> 在之前对标签的进行解析的时候,是有对 标签进行一个初步的解析. 然后里面其实是很多内容还没填补很详细,所以特意记录下对 详细操作的. 那么，下文就开始操作吧.</p>
<p> <strong>org.apache.ibatis.builder.xml.XMLMapperBuilder#parse</strong></p>
<p>主要来看这段解析的代码 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void parse() &#123;</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F; 利用 org.apache.ibatis.session.Configuration 的 loadedResources</span><br><span class="line">&#x2F;&#x2F; 来判断是不是已经加载过了的.    </span><br><span class="line">  if (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line">    configurationElement(parser.evalNode(&quot;&#x2F;mapper&quot;));</span><br><span class="line">&#x2F;&#x2F; 这里添加到 loadedResources 中来,也就是用来控制是不是已经解析过了的.      </span><br><span class="line">    configuration.addLoadedResource(resource);</span><br><span class="line">    bindMapperForNamespace();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这三个方法给我一种好像解析那种没有还没解析完的 ? 这个地方有待完善.    </span><br><span class="line">  parsePendingResultMaps();</span><br><span class="line">  parsePendingCacheRefs();</span><br><span class="line">  parsePendingStatements();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; configurationElement 方法,</span><br><span class="line">&#x2F;&#x2F; 可以看到这个方法中,很多标签(namespace&#x2F;parameterMa&#x2F;resultMap&#x2F;sql)</span><br><span class="line">&#x2F;&#x2F; 还有下面的select&#x2F;insert&#x2F;update&#x2F;delete</span><br><span class="line">&#x2F;&#x2F; 这些熟悉的标签</span><br><span class="line">  private void configurationElement(XNode context) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      String namespace &#x3D; context.getStringAttribute(&quot;namespace&quot;);</span><br><span class="line">      if (namespace &#x3D;&#x3D; null || namespace.equals(&quot;&quot;)) &#123;</span><br><span class="line">        throw new BuilderException(&quot;Mapper&#39;s namespace cannot be empty&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">&#x2F;&#x2F; 将 namespace 赋值进去,也就是当前正在解析的 namespace.        </span><br><span class="line">      builderAssistant.setCurrentNamespace(namespace);</span><br><span class="line">        </span><br><span class="line">&#x2F;&#x2F; 这里是对缓存标签进行解析.        </span><br><span class="line">      cacheRefElement(context.evalNode(&quot;cache-ref&quot;));</span><br><span class="line">      cacheElement(context.evalNode(&quot;cache&quot;));</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 解析 parameterMap标签        </span><br><span class="line">      parameterMapElement(context.evalNodes(&quot;&#x2F;mapper&#x2F;parameterMap&quot;));</span><br><span class="line">        </span><br><span class="line">&#x2F;&#x2F;         </span><br><span class="line">      resultMapElements(context.evalNodes(&quot;&#x2F;mapper&#x2F;resultMap&quot;));</span><br><span class="line">      sqlElement(context.evalNodes(&quot;&#x2F;mapper&#x2F;sql&quot;));</span><br><span class="line">      buildStatementFromContext(context.evalNodes(&quot;select|insert|update|delete&quot;));</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      throw new BuilderException(&quot;Error parsing Mapper XML. The XML location is &#39;&quot; + resource + &quot;&#39;. Cause: &quot; + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p> <strong>resultMapElements 方法 :</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 这里的 list 是 xml 文件中的所有 &lt;resultMap&gt; 标签文件.</span><br><span class="line">private void resultMapElements(List&lt;XNode&gt; list) &#123;</span><br><span class="line">  for (XNode resultMapNode : list) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">&#x2F;&#x2F;  有点好奇,该方法返回的 ResultMap 这边好像并没有参数,有点尴尬.</span><br><span class="line">&#x2F;&#x2F;  不过是已经存储在 org.apache.ibatis.session.Configuration#resultMaps 中.       </span><br><span class="line">      resultMapElement(resultMapNode);</span><br><span class="line">    &#125; catch (IncompleteElementException e) &#123;</span><br><span class="line">      &#x2F;&#x2F; ignore, it will be retried</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">----------</span><br><span class="line">&#x2F;&#x2F; 最后跟进到这个方法中来.</span><br><span class="line">  private ResultMap resultMapElement(XNode resultMapNode, List&lt;ResultMapping&gt; additionalResultMappings, Class&lt;?&gt; enclosingType) &#123;</span><br><span class="line">    ErrorContext.instance().activity(&quot;processing &quot; + resultMapNode.getValueBasedIdentifier());</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 获取出 type , 这里我们获取出来的 type 是 TbBlog.    </span><br><span class="line">    String type &#x3D; resultMapNode.getStringAttribute(&quot;type&quot;,</span><br><span class="line">        resultMapNode.getStringAttribute(&quot;ofType&quot;,</span><br><span class="line">            resultMapNode.getStringAttribute(&quot;resultType&quot;,</span><br><span class="line">                resultMapNode.getStringAttribute(&quot;javaType&quot;))));</span><br><span class="line">&#x2F;&#x2F; 先判断 org.apache.ibatis.type.TypeAliasRegistry#typeAliases 中有没有,</span><br><span class="line">&#x2F;&#x2F; 如果没有的话,就会自己new一个出来.    </span><br><span class="line">    Class&lt;?&gt; typeClass &#x3D; resolveClass(type);</span><br><span class="line">    if (typeClass &#x3D;&#x3D; null) &#123;</span><br><span class="line">&#x2F;&#x2F; TODO,如果没有话?        </span><br><span class="line">      typeClass &#x3D; inheritEnclosingType(resultMapNode, enclosingType);</span><br><span class="line">    &#125;</span><br><span class="line">    Discriminator discriminator &#x3D; null;</span><br><span class="line">    List&lt;ResultMapping&gt; resultMappings &#x3D; new ArrayList&lt;&gt;(additionalResultMappings);</span><br><span class="line">    </span><br><span class="line"> &#x2F;&#x2F; 获取该 &lt;resultMap&gt; 下的子标签</span><br><span class="line">&#x2F;&#x2F; 那么这里也就是获取 &lt;id&gt; 和 &lt;result&gt; 这二个.    </span><br><span class="line">    List&lt;XNode&gt; resultChildren &#x3D; resultMapNode.getChildren();</span><br><span class="line">    for (XNode resultChild : resultChildren) &#123;</span><br><span class="line">&#x2F;&#x2F; 分为 constructor &#x2F; discriminator &#x2F; 其他 这三类情况        </span><br><span class="line">      if (&quot;constructor&quot;.equals(resultChild.getName())) &#123;</span><br><span class="line">        processConstructorElement(resultChild, typeClass, resultMappings);</span><br><span class="line">      &#125; else if (&quot;discriminator&quot;.equals(resultChild.getName())) &#123;</span><br><span class="line">        discriminator &#x3D; processDiscriminatorElement(resultChild, typeClass, resultMappings);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line"> &#x2F;&#x2F; 非前二者情况.         </span><br><span class="line">        List&lt;ResultFlag&gt; flags &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        if (&quot;id&quot;.equals(resultChild.getName())) &#123;</span><br><span class="line">         &#x2F;&#x2F; 如果标签是id的话,就会给flags添加ResultFlag.ID.</span><br><span class="line">          flags.add(ResultFlag.ID);</span><br><span class="line">        &#125;</span><br><span class="line">  &#x2F;&#x2F;  将返回回来的 ResultMapping 添加进来.       </span><br><span class="line">        resultMappings.add(buildResultMappingFromContext(resultChild, typeClass, flags));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F; 这里获取的是 &lt;resultMap&gt; 标签的 id 字段.    </span><br><span class="line">    String id &#x3D; resultMapNode.getStringAttribute(&quot;id&quot;,</span><br><span class="line">            resultMapNode.getValueBasedIdentifier());</span><br><span class="line">&#x2F;&#x2F; 这里还可以使用 extends 属性, 不是看到这里, 都好奇还有这种标签.    </span><br><span class="line">    String extend &#x3D; resultMapNode.getStringAttribute(&quot;extends&quot;);</span><br><span class="line">    Boolean autoMapping &#x3D; resultMapNode.getBooleanAttribute(&quot;autoMapping&quot;);</span><br><span class="line">&#x2F;&#x2F; 这里 new 了一个 ResultMapResolver 对象.   </span><br><span class="line">    ResultMapResolver resultMapResolver &#x3D; new ResultMapResolver(builderAssistant, id, typeClass, extend, discriminator, resultMappings, autoMapping);</span><br><span class="line">    try &#123;</span><br><span class="line">&#x2F;&#x2F; 这里最后就是 new 了一个 ResultMap 对象, 该对象的 id 是 namespace + 方法ID 拼接.</span><br><span class="line">&#x2F;&#x2F; 然后将该对象给添加到  org.apache.ibatis.session.Configuration#resultMaps 中来,</span><br><span class="line">&#x2F;&#x2F; key 就是其id, 最后就是根据 local &#x2F; global 来分别进行二种情况检查.        </span><br><span class="line">      return resultMapResolver.resolve();</span><br><span class="line">    &#125; catch (IncompleteElementException  e) &#123;</span><br><span class="line">      configuration.addIncompleteResultMap(resultMapResolver);</span><br><span class="line">      throw e;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;  buildResultMappingFromContext 方法</span><br><span class="line">&#x2F;&#x2F; 该方法是对 resultMap 中的字段进行解析.</span><br><span class="line">  private ResultMapping buildResultMappingFromContext(XNode context, Class&lt;?&gt; resultType, List&lt;ResultFlag&gt; flags) &#123;</span><br><span class="line">    String property;</span><br><span class="line">    if (flags.contains(ResultFlag.CONSTRUCTOR)) &#123;</span><br><span class="line">      property &#x3D; context.getStringAttribute(&quot;name&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      property &#x3D; context.getStringAttribute(&quot;property&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    String column &#x3D; context.getStringAttribute(&quot;column&quot;);</span><br><span class="line">    String javaType &#x3D; context.getStringAttribute(&quot;javaType&quot;);</span><br><span class="line">    String jdbcType &#x3D; context.getStringAttribute(&quot;jdbcType&quot;);</span><br><span class="line">    String nestedSelect &#x3D; context.getStringAttribute(&quot;select&quot;);</span><br><span class="line">    String nestedResultMap &#x3D; context.getStringAttribute(&quot;resultMap&quot;, () -&gt;</span><br><span class="line">      processNestedResultMappings(context, Collections.emptyList(), resultType));</span><br><span class="line">    String notNullColumn &#x3D; context.getStringAttribute(&quot;notNullColumn&quot;);</span><br><span class="line">    String columnPrefix &#x3D; context.getStringAttribute(&quot;columnPrefix&quot;);</span><br><span class="line">    String typeHandler &#x3D; context.getStringAttribute(&quot;typeHandler&quot;);</span><br><span class="line">    String resultSet &#x3D; context.getStringAttribute(&quot;resultSet&quot;);</span><br><span class="line">    String foreignColumn &#x3D; context.getStringAttribute(&quot;foreignColumn&quot;);</span><br><span class="line">    boolean lazy &#x3D; &quot;lazy&quot;.equals(context.getStringAttribute(&quot;fetchType&quot;, configuration.isLazyLoadingEnabled() ? &quot;lazy&quot; : &quot;eager&quot;));</span><br><span class="line">      </span><br><span class="line">&#x2F;&#x2F; 获取 javaType , typeHandler , jdbcType 等对象.      </span><br><span class="line">    Class&lt;?&gt; javaTypeClass &#x3D; resolveClass(javaType);</span><br><span class="line">    Class&lt;? extends TypeHandler&lt;?&gt;&gt; typeHandlerClass &#x3D; resolveClass(typeHandler);</span><br><span class="line">    JdbcType jdbcTypeEnum &#x3D; resolveJdbcType(jdbcType);</span><br><span class="line">&#x2F;&#x2F; org.apache.ibatis.builder.MapperBuilderAssistant#buildResultMapping(java.lang.Class&lt;?&gt;, java.lang.String, java.lang.String, java.lang.Class&lt;?&gt;, org.apache.ibatis.type.JdbcType, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.Class&lt;? extends org.apache.ibatis.type.TypeHandler&lt;?&gt;&gt;, java.util.List&lt;org.apache.ibatis.mapping.ResultFlag&gt;, java.lang.String, java.lang.String, boolean)</span><br><span class="line">&#x2F;&#x2F; 可以看到这里传递进来的参数还是很多的.</span><br><span class="line">&#x2F;&#x2F; 最后返回 ResultMapping 对象,也就是说这么多参数&amp;buildResultMapping方法中的参数,</span><br><span class="line">&#x2F;&#x2F;都设置到该对象中来了.     </span><br><span class="line">    return builderAssistant.buildResultMapping(resultType, property, column, javaTypeClass, jdbcTypeEnum, nestedSelect, nestedResultMap, notNullColumn, columnPrefix, typeHandlerClass, flags, resultSet, foreignColumn, lazy);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>SqlElement 方法</strong></p>
<p>该方法可以很明显的感受到是对 标签进行解析的.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void sqlElement(List&lt;XNode&gt; list) &#123;</span><br><span class="line"> &#x2F;&#x2F; configuration 获取出来 dataBaseId是null,跳过此方法  </span><br><span class="line">  if (configuration.getDatabaseId() !&#x3D; null) &#123;</span><br><span class="line">    sqlElement(list, configuration.getDatabaseId());</span><br><span class="line">  &#125;</span><br><span class="line">&#x2F;&#x2F;    </span><br><span class="line">  sqlElement(list, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 有点好奇写代码风格:  sqlElement(list,configuration.getDatabaseId());</span><br><span class="line">------------------------</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;  sqlElement 方法</span><br><span class="line">  private void sqlElement(List&lt;XNode&gt; list, String requiredDatabaseId) &#123;</span><br><span class="line">    for (XNode context : list) &#123;</span><br><span class="line">        </span><br><span class="line"> &#x2F;&#x2F; 获取 databaseId 和 id 这二个属性的值.       </span><br><span class="line">      String databaseId &#x3D; context.getStringAttribute(&quot;databaseId&quot;);</span><br><span class="line">      String id &#x3D; context.getStringAttribute(&quot;id&quot;);</span><br><span class="line"> &#x2F;&#x2F;  org.apache.ibatis.builder.MapperBuilderAssistant#applyCurrentNamespace   </span><br><span class="line"> &#x2F;&#x2F; 该方法最后返回的id的值是: namespace + id       </span><br><span class="line">      id &#x3D; builderAssistant.applyCurrentNamespace(id, false);</span><br><span class="line">&#x2F;&#x2F;sqlFragments 不包含该id就返回true,也就说该Map是确定是否已经解析过了的.         </span><br><span class="line">      if (databaseIdMatchesCurrent(id, databaseId, requiredDatabaseId)) &#123;</span><br><span class="line">&#x2F;&#x2F; 添加到 org.apache.ibatis.builder.xml.XMLMapperBuilder#sqlFragments 中来.          </span><br><span class="line">        sqlFragments.put(id, context);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p> 最后 解析后的值,是使用 namespace + id 存放在 org.apache.ibatis.builder.xml.XMLMapperBuilder#sqlFragments 的属性中的.</p>
<p><strong>buildStatementFromContext() 方法 :</strong></p>
<p> 这里是对 select / insert / update / delete 标签进行解析.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">buildStatementFromContext(context.evalNodes(&quot;select|insert|update|delete&quot;));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 可以看到 databaseId 的获取与 sql 标签是一样的操作</span><br><span class="line">private void buildStatementFromContext(List&lt;XNode&gt; list) &#123;</span><br><span class="line">  if (configuration.getDatabaseId() !&#x3D; null) &#123;</span><br><span class="line">    buildStatementFromContext(list, configuration.getDatabaseId());</span><br><span class="line">  &#125;</span><br><span class="line">  buildStatementFromContext(list, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 所以我们可以跟进到这个方法来.</span><br><span class="line">  private void buildStatementFromContext(List&lt;XNode&gt; list, String requiredDatabaseId) &#123;</span><br><span class="line">    for (XNode context : list) &#123;</span><br><span class="line">&#x2F;&#x2F; 先 new 了一个 XMLStatementBuilder 对象, 紧接着就调用该对象的 解析 方法.        </span><br><span class="line">      final XMLStatementBuilder statementParser &#x3D; new XMLStatementBuilder(configuration, builderAssistant, context, requiredDatabaseId);</span><br><span class="line">      try &#123;</span><br><span class="line">        statementParser.parseStatementNode();</span><br><span class="line">      &#125; catch (IncompleteElementException e) &#123;</span><br><span class="line">        configuration.addIncompleteStatement(statementParser);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 解析方法</span><br><span class="line">  public void parseStatementNode() &#123;</span><br><span class="line">    String id &#x3D; context.getStringAttribute(&quot;id&quot;);</span><br><span class="line">    String databaseId &#x3D; context.getStringAttribute(&quot;databaseId&quot;);</span><br><span class="line">&#x2F;&#x2F; 用 namespace + id 组合为 id</span><br><span class="line">&#x2F;&#x2F; org.apache.ibatis.session.Configuration#mappedStatements</span><br><span class="line">&#x2F;&#x2F; 接着就是判断在 mappedStatements 中是不是有该id,如果不存在就返回ture,</span><br><span class="line">&#x2F;&#x2F; 存在就返回false,这里也就会直接return出去,也就是不会往后面执行了.      </span><br><span class="line">    if (!databaseIdMatchesCurrent(id, databaseId, this.requiredDatabaseId)) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F; 获取标签名字,  select &#x2F; insert&#x2F; update &#x2F;delete.</span><br><span class="line">    String nodeName &#x3D; context.getNode().getNodeName();</span><br><span class="line">&#x2F;&#x2F; 转化为大写的 SELECT      </span><br><span class="line">    SqlCommandType sqlCommandType &#x3D; SqlCommandType.valueOf(nodeName.toUpperCase(Locale.ENGLISH));</span><br><span class="line">    boolean isSelect &#x3D; sqlCommandType &#x3D;&#x3D; SqlCommandType.SELECT;</span><br><span class="line">&#x2F;&#x2F; 是否刷新 cache,也就是select是不刷新的,那么其他的就应该是要刷新的.      </span><br><span class="line">    boolean flushCache &#x3D; context.getBooleanAttribute(&quot;flushCache&quot;, !isSelect);</span><br><span class="line">&#x2F;&#x2F; 使用使用 cache,这里应该是一级缓存，默认开启的.      </span><br><span class="line">    boolean useCache &#x3D; context.getBooleanAttribute(&quot;useCache&quot;, isSelect);</span><br><span class="line">&#x2F;&#x2F; 结果排序, 如果没有配置的话,默认就是false.      </span><br><span class="line">    boolean resultOrdered &#x3D; context.getBooleanAttribute(&quot;resultOrdered&quot;, false);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Include Fragments before parsing</span><br><span class="line">&#x2F;&#x2F; 创建了一个 XMLIncludeTransformer 对象,该对象应该是进行转化的.      </span><br><span class="line">    XMLIncludeTransformer includeParser &#x3D; new XMLIncludeTransformer(configuration, builderAssistant);</span><br><span class="line"> &#x2F;&#x2F;  TODO ? 该方法有待更新     </span><br><span class="line">    includeParser.applyIncludes(context.getNode());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取 parameterType 属性,如果有的话,也会获取出该属性对应的 Class.    </span><br><span class="line">    String parameterType &#x3D; context.getStringAttribute(&quot;parameterType&quot;);</span><br><span class="line">    Class&lt;?&gt; parameterTypeClass &#x3D; resolveClass(parameterType);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; lang : null,这里是没有设置的.      </span><br><span class="line">    String lang &#x3D; context.getStringAttribute(&quot;lang&quot;);</span><br><span class="line">    LanguageDriver langDriver &#x3D; getLanguageDriver(lang);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Parse selectKey after includes and remove them.</span><br><span class="line">&#x2F;&#x2F; 这里对是否有 selectKey 进行处理.我们这里目前没有使用 selectKey</span><br><span class="line">    processSelectKeyNodes(id, parameterTypeClass, langDriver);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Parse the SQL (pre: &lt;selectKey&gt; and &lt;include&gt; were parsed and removed)</span><br><span class="line">    KeyGenerator keyGenerator;</span><br><span class="line"> &#x2F;&#x2F; selectBlog!selectKey     </span><br><span class="line">    String keyStatementId &#x3D; id + SelectKeyGenerator.SELECT_KEY_SUFFIX;</span><br><span class="line">&#x2F;&#x2F; 这里拼接上 namespace :  com.iyang.mybatis.mapper.BlogMapper.selectBlog!selectKey      </span><br><span class="line">    keyStatementId &#x3D; builderAssistant.applyCurrentNamespace(keyStatementId, true);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这里是判断是否有 主键自动生成. 这里是查询语句,应该是没有的. </span><br><span class="line">    if (configuration.hasKeyGenerator(keyStatementId)) &#123;</span><br><span class="line">      keyGenerator &#x3D; configuration.getKeyGenerator(keyStatementId);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      keyGenerator &#x3D; context.getBooleanAttribute(&quot;useGeneratedKeys&quot;,</span><br><span class="line">          configuration.isUseGeneratedKeys() &amp;&amp; SqlCommandType.INSERT.equals(sqlCommandType))</span><br><span class="line">          ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建一个 XMLScriptBuilder 对象,使用该对象的parseScriptNode方法来解析</span><br><span class="line">&#x2F;&#x2F; org.apache.ibatis.scripting.xmltags.XMLScriptBuilder#parseScriptNode</span><br><span class="line">&#x2F;&#x2F; 获取出sql, 有个 isDynamic 参数,来判断是不是动态sql语句.</span><br><span class="line">&#x2F;&#x2F; 这里不是动态sql,最后new了一个RawSqlSource.</span><br><span class="line">&#x2F;&#x2F; org.apache.ibatis.builder.SqlSourceBuilder#parse,我们的#&#123;id&#125; 替换成 ? 就是在</span><br><span class="line">&#x2F;&#x2F; 这里进行替换的.</span><br><span class="line">&#x2F;&#x2F; 如果是动态 sql 的话,就会创建出 DynamicSqlSource 该对象来.</span><br><span class="line">&#x2F;&#x2F; 可以看到 SqlSource 下面是有 四个实现类的.</span><br><span class="line">&#x2F;&#x2F; 这里返回的 SqlSource里面有sql语句的,和返回类型的.      </span><br><span class="line">    SqlSource sqlSource &#x3D; langDriver.createSqlSource(configuration, context, parameterTypeClass);</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 获取属性.      </span><br><span class="line">    StatementType statementType &#x3D; StatementType.valueOf(context.getStringAttribute(&quot;statementType&quot;, StatementType.PREPARED.toString()));</span><br><span class="line">    Integer fetchSize &#x3D; context.getIntAttribute(&quot;fetchSize&quot;);</span><br><span class="line">    Integer timeout &#x3D; context.getIntAttribute(&quot;timeout&quot;);</span><br><span class="line">    String parameterMap &#x3D; context.getStringAttribute(&quot;parameterMap&quot;);</span><br><span class="line">&#x2F;&#x2F; 获取返回类型. 获取出来的 resultTypeClass 是 class com.iyang.mybatis.pojo.TbBlog      </span><br><span class="line">    String resultType &#x3D; context.getStringAttribute(&quot;resultType&quot;);</span><br><span class="line">    Class&lt;?&gt; resultTypeClass &#x3D; resolveClass(resultType);</span><br><span class="line">    String resultMap &#x3D; context.getStringAttribute(&quot;resultMap&quot;);      </span><br><span class="line">    String resultSetType &#x3D; context.getStringAttribute(&quot;resultSetType&quot;);</span><br><span class="line">    ResultSetType resultSetTypeEnum &#x3D; resolveResultSetType(resultSetType);</span><br><span class="line">    if (resultSetTypeEnum &#x3D;&#x3D; null) &#123;</span><br><span class="line">      resultSetTypeEnum &#x3D; configuration.getDefaultResultSetType();</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F; 获取属性的值      </span><br><span class="line">    String keyProperty &#x3D; context.getStringAttribute(&quot;keyProperty&quot;);</span><br><span class="line">    String keyColumn &#x3D; context.getStringAttribute(&quot;keyColumn&quot;);</span><br><span class="line">    String resultSets &#x3D; context.getStringAttribute(&quot;resultSets&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建一个 MappedStatement.Builder 对象出来.</span><br><span class="line">&#x2F;&#x2F; 再通过 builder 构建出一个 MappedStatement 对象来.</span><br><span class="line">&#x2F;&#x2F; 最后放入到 org.apache.ibatis.session.Configuration#mappedStatements 中来.      </span><br><span class="line">    builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType,</span><br><span class="line">        fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass,</span><br><span class="line">        resultSetTypeEnum, flushCache, useCache, resultOrdered,</span><br><span class="line">        keyGenerator, keyProperty, keyColumn, databaseId, langDriver, resultSets);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private void processSelectKeyNodes(String id, Class&lt;?&gt; parameterTypeClass, LanguageDriver langDriver) &#123;</span><br><span class="line">    List&lt;XNode&gt; selectKeyNodes &#x3D; context.evalNodes(&quot;selectKey&quot;);</span><br><span class="line">    if (configuration.getDatabaseId() !&#x3D; null) &#123;</span><br><span class="line">      parseSelectKeyNodes(id, selectKeyNodes, parameterTypeClass, langDriver, configuration.getDatabaseId());</span><br><span class="line">    &#125;</span><br><span class="line">    parseSelectKeyNodes(id, selectKeyNodes, parameterTypeClass, langDriver, null);</span><br><span class="line">    removeSelectKeyNodes(selectKeyNodes);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p> 总结下 MyBatis 解析 Mapper的xml 文件流程。 可以感受到,对于Mybatis处理Mapper,对其字段属性都是挨个解析的,还是下了很大的功夫.</p>
<p> 先是有一个集合来控制是否已经解析过了,算是一种是否解析的开关配置. 可以看到其先后的解析顺序,</p>
<p>namespace –&gt; cache-ref –&gt; cache —&gt; mapper/parameterMap —&gt; mapper/resultMap —&gt; mapper/sql —&gt; select/insert/update/detele.</p>
<p> 当解析这些标签的时候, 又会对标签里面的属性进行解析. 这里,主要看下我们平常使用到最多的标签, MyBatis 对这些标签解析了后,其后有是怎么利用的呢？可以看到目前MyBatis是存放在一些configuration等类信息里面,那么等到真正去查询sql语句的时候, MyBatis 又是怎么用上的呢？ 这里目前只讲了如何解析.</p>
<p> 解析完了，没异常，那就是解析都ok了，剩下的就是看当 MyBatis 去查询的时候, 是怎么利用上这些资源的呢？所以看接下来的更新.</p>
]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>Java源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反射学习</title>
    <url>/2020/07/01/java_reflect_other/java_reflect_1/</url>
    <content><![CDATA[<h4 id="题记"><a href="#题记" class="headerlink" title="题记"></a>题记</h4><p>​     最近在看Spring源码的时候, 可以看到在加载类等的时候,都是大量使用的反射。估摸着MyBatis这种框架,其内部也是会大量的使用反射。所以看得出来反射在第三方的框架中使用是非常多的,于是说学习反射技术是很有必要的，不论是你写代码造轮子还是去理解第三方框架的底层实现.</p>
<p>​    话不多bb,直接上代码看看是个什么操作.</p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>我们这里写一个简单的pojo类,也就是我们经常使用的.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">public</span> String age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(Integer id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"User说"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然后接着在写一个启动的Main类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserClazzMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User u = <span class="keyword">new</span> User();</span><br><span class="line">        <span class="comment">// 获取类的所有的构造方法</span></span><br><span class="line">        Constructor&lt;?&gt;[] constructors = u.getClass().getConstructors();</span><br><span class="line">        System.out.println(Arrays.asList(constructors).toString());</span><br><span class="line">        <span class="comment">// 根据传入进去的参数类型,获取出类的构造方法.</span></span><br><span class="line">        Constructor&lt;? extends User&gt; constructor = u.getClass().getConstructor(Integer<span class="class">.<span class="keyword">class</span>, <span class="title">String</span>.<span class="title">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印结果:[public com.iyang.bootbasicio.pojo.User(), public com.iyang.bootbasicio.pojo.User(java.lang.Integer,java.lang.String)],</span></span><br><span class="line"><span class="comment">//可以看到这是一个获取类的构造方法的.</span></span><br></pre></td></tr></table></figure>



<p>调用反射获取方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserClazzMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        User u = <span class="keyword">new</span> User();</span><br><span class="line">        <span class="comment">// 可以看到获取出来的全部方法,不仅仅包含我们写的,还有Object中的notify等方法.</span></span><br><span class="line">        Method[] methods = u.getClass().getMethods();</span><br><span class="line">        System.out.println(Arrays.asList(methods).toString());</span><br><span class="line">        <span class="comment">// 根据方法的名字来过去我们特定的方法.</span></span><br><span class="line">        Method method = u.getClass().getMethod(<span class="string">"say"</span>);</span><br><span class="line">        System.out.println(method.toString());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//getDeclaredMethods方法仅仅只获取除了我们这个类里面的方法,并没有获取全部的方法(也就是不包括Object的).</span></span><br><span class="line">        Method[] declaredMethods = u.getClass().getDeclaredMethods();</span><br><span class="line">        System.out.println(Arrays.asList(declaredMethods).toString());</span><br><span class="line">        <span class="comment">// 这里依然是获取我们自己写的方法</span></span><br><span class="line">        Method say = u.getClass().getDeclaredMethod(<span class="string">"say"</span>);</span><br><span class="line">        System.out.println(say.toString());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这样我们就可以调用了user的say方法</span></span><br><span class="line">        Method say = u.getClass().getDeclaredMethod(<span class="string">"say"</span>);</span><br><span class="line">        say.invoke(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">[<span class="keyword">public</span> <span class="keyword">void</span> com.iyang.bootbasicio.pojo.User.setId(java.lang.Integer), <span class="keyword">public</span> <span class="keyword">void</span> com.iyang.bootbasicio.pojo.User.say(), <span class="keyword">public</span> java.lang.String com.iyang.bootbasicio.pojo.User.getName(), <span class="keyword">public</span> <span class="keyword">void</span> com.iyang.bootbasicio.pojo.User.setName(java.lang.String), <span class="keyword">public</span> java.lang.Integer com.iyang.bootbasicio.pojo.User.getId(), <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> java.lang.Object.wait(<span class="keyword">long</span>,<span class="keyword">int</span>) <span class="keyword">throws</span> java.lang.InterruptedException, <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> java.lang.Object.wait(<span class="keyword">long</span>) <span class="keyword">throws</span> java.lang.InterruptedException, <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> java.lang.Object.wait() <span class="keyword">throws</span> java.lang.InterruptedException, <span class="keyword">public</span> <span class="keyword">boolean</span> java.lang.Object.equals(java.lang.Object), <span class="keyword">public</span> java.lang.String java.lang.Object.toString(), <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> java.lang.Object.hashCode(), <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> java.lang.Class java.lang.Object.getClass(), <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> java.lang.Object.notify(), <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> java.lang.Object.notifyAll()]</span><br><span class="line">----------------------------</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> com.iyang.bootbasicio.pojo.User.say()</span><br></pre></td></tr></table></figure>



<p> 调用获取字段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserClazzMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        User u = <span class="keyword">new</span> User();</span><br><span class="line">        <span class="comment">//获取全部的字段,是public修饰的字段,private修饰的是获取不到的.</span></span><br><span class="line">        Field[] fields = u.getClass().getFields();</span><br><span class="line">        System.out.println(Arrays.asList(fields).toString());</span><br><span class="line">        <span class="comment">//获取字段,私有的不能获取,会抛出异常,只能获取public修饰的字段.</span></span><br><span class="line">        Field field = u.getClass().getField(<span class="string">"age"</span>);</span><br><span class="line">        System.out.println(field.toString());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取全部的字段,private修饰的也是可以获取出来的</span></span><br><span class="line">        Field[] declaredFields = u.getClass().getDeclaredFields();</span><br><span class="line">        System.out.println(Arrays.asList(declaredFields).toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据字段的名字获取字段,不管什么修饰的,都是可以获取出来的.</span></span><br><span class="line">        Field name = u.getClass().getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">        System.out.println(name.toString());</span><br><span class="line">       &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<p>获取注解:</p>
<p>我们先定义二个注解, 然后记得加在User类上. GavinYang 和 PeterWong 这二个注解是可以加在类上的, GavinYangFiledAnno是加在字段上面的.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> GavinYang &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">lwf</span><span class="params">()</span> <span class="keyword">default</span> "lwf"</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> PeterWong &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> "peterWong"</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.FIELD&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> GavinYangFiledAnno &#123;</span><br><span class="line">    <span class="function">String <span class="title">desc</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// 从结果来看,获取注解还是蛮顺利的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        User u = <span class="keyword">new</span> User();</span><br><span class="line">        <span class="comment">// 获取这个类上面的注解</span></span><br><span class="line">        Annotation[] annotations = u.getClass().getAnnotations();</span><br><span class="line">        System.out.println(Arrays.asList(annotations).toString());</span><br><span class="line">        <span class="comment">// 根据注解名字获取,可以看到返回的也直接是注解的Obejct了</span></span><br><span class="line">        GavinYang gavinYang = u.getClass().getAnnotation(GavinYang<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(gavinYang.toString());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取字段上面使用的注解.</span></span><br><span class="line">        Field field = u.getClass().getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">        Annotation[] fieldAnnotations = field.getAnnotations();</span><br><span class="line">        System.out.println(Arrays.asList(fieldAnnotations).toString());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">[<span class="meta">@com</span>.iyang.bootbasicio.pojo.GavinYang(lwf=baoyang), <span class="meta">@com</span>.iyang.bootbasicio.pojo.PeterWong(name=gavinyang)]</span><br><span class="line"><span class="meta">@com</span>.iyang.bootbasicio.pojo.GavinYang(lwf=baoyang)     </span><br><span class="line">[<span class="meta">@com</span>.iyang.bootbasicio.pojo.GavinYangFiledAnno(desc=秒啊)]</span><br></pre></td></tr></table></figure>



<h4 id="小站一下"><a href="#小站一下" class="headerlink" title="小站一下"></a>小站一下</h4><p>UserService 无参构造方法 User说使用依赖注入完成一个简单的注入</p>
<p>认一下Spring写一个差不多的注入注解. 在写一个虚假的 UserService,当然了,我们这里先不使用扫描,就使用简单的UserServcie去操作即可.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.FIELD&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> GavinYangAutowired &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">alias</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GavinYangAutowired</span></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"UserService 无参构造方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        user.say();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>UserClassMain 类来启动发车 , 这里看结果是可以成功的启动 UserService 并且也是用hello方法来调用user的say,都是成功. 但是真实的框架复杂程度不是这几行就可以ok了的. 这只是一个简单易学的demo.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserClazzMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        UserService u  = <span class="keyword">new</span> UserService();</span><br><span class="line">        Field[] fields = u.getClass().getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span>(Field f : fields)&#123;</span><br><span class="line">            GavinYangAutowired autowired = f.getDeclaredAnnotation(GavinYangAutowired<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span>(autowired != <span class="keyword">null</span>)&#123;</span><br><span class="line">                Class&lt;?&gt; fType = f.getType();</span><br><span class="line">                Constructor&lt;?&gt; typeConstructor = fType.getConstructor();</span><br><span class="line">                Object instance = typeConstructor.newInstance();</span><br><span class="line"></span><br><span class="line">                f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                f.set(u,instance);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        u.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserService 无参构造方法</span></span><br><span class="line"><span class="comment">// User说</span></span><br></pre></td></tr></table></figure>



<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>可以看到反射的功能还是蛮强大的, 但是项目里面一般是CRUD,目前也没有什么特别的地方看到使用反射的情况比较多.就是最近一直看Spring源码中,是可以看到有大量使用反射的情况.</p>
]]></content>
      <categories>
        <category>Java源码</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>docker学习笔记</title>
    <url>/2020/04/23/linux&amp;docker&amp;k8s/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h3><blockquote>
<p><strong>Docker</strong> 是个好东西，所以你得学习。 进公司是一直都有使用docker来发布项目的,之前对docker也是有多多少少的学习。最近想学习一下k8s，所以也顺路安装一下docker.</p>
</blockquote>
<hr>
<h3 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a>Docker 安装</h3><blockquote>
<p>这里笔者安装的环境就是 VM 上跑的 Centos 来进行安装的</p>
</blockquote>
<ol>
<li><p>卸载旧版本</p>
<p>[root@localhost ~]# sudo yum remove docker \</p>
<blockquote>
<pre><code>docker-client \
docker-client-latest \
docker-common \
docker-latest \
docker-latest-logrotate \
docker-logrotate \
docker-engine
已加载插件：fastestmirror
参数 docker 没有匹配
参数 docker-client 没有匹配
参数 docker-client-latest 没有匹配
参数 docker-common 没有匹配
参数 docker-latest 没有匹配
参数 docker-latest-logrotate 没有匹配
参数 docker-logrotate 没有匹配
参数 docker-engine 没有匹配
不删除任何软件包</code></pre></blockquote>
</li>
<li><p>安装所需要的依赖包</p>
<blockquote>
<p><strong>sudo</strong> <strong>yum install</strong> -y yum-utils <br> device-mapper-persistent-data <br> lvm2</p>
</blockquote>
</li>
<li><p>设置稳定的仓库</p>
<blockquote>
<p><strong>sudo</strong> yum-config-manager <br>  –add-repo <br>  https:<strong>//</strong>download.docker.com<strong>/</strong>linux<strong>/</strong>centos<strong>/</strong>docker-ce.repo</p>
</blockquote>
</li>
<li><p>安装最新的Docker Engine-Community</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;sudo yum install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
<hr>
<p> 感觉 正常的安装 docker 还是很慢的</p>
<p>Step 1 : 安装必要的一些系统工具</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure>



<p>Step 2 : 添加软件信息</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager --<span class="keyword">add</span><span class="bash">-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span></span><br></pre></td></tr></table></figure>



<p>Step 3 :  更新并且安装 docker-ce</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line">sudo yum makecache fast</span><br></pre></td></tr></table></figure>



<p>Step 4 : 开启Docker服务</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line">sudo service docker start</span><br></pre></td></tr></table></figure>



<p>Step 5 (非必要),配置加速</p>
<p>/etc/docker/daemon.json (如果没有这个文件的话,就去创建一个)</p>
<p>{</p>
<p>“registry-mirrors”: [“<a href="http://hub-mirror.c.163.com&quot;]">http://hub-mirror.c.163.com&quot;]</a></p>
<p>}</p>
<p>Step 6 重启指令</p>
<p>   systemctl daemon-reload</p>
<p>   systemctl restart docker</p>
<hr>
<p>现在VM上安装一台Centos 7 , 安装好docker , 然后使用克隆来克隆一台即可。最好的镜像加速也要配置下.</p>
<p>Linux : Centos 7</p>
<table>
<thead>
<tr>
<th>主机名</th>
<th>ip</th>
<th><strong>kubelet</strong>/<strong>kubeadm</strong>/<strong>kubectl</strong></th>
<th>flannel version</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>master</td>
<td>192.168.247.131</td>
<td>V1.14.2</td>
<td>V0.11.0</td>
<td>主节点</td>
</tr>
<tr>
<td>node</td>
<td>192.168.247.132</td>
<td>V1.14.2</td>
<td>V0.11.0</td>
<td>node节点</td>
</tr>
</tbody></table>
<h3 id="主机名"><a href="#主机名" class="headerlink" title="主机名"></a>主机名</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hostnamectl set-hostname master</span><br><span class="line">hostnamectl set-hostname node</span><br></pre></td></tr></table></figure>



<p> 修改/etc/hosts ; 即可</p>
<p> [root@localhost ~]# cat /etc/hosts<br>127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4<br>::1         localhost localhost.localdomain localhost6 localhost6.localdomain6<br>192.168.247.131 master<br>192.168.247.132 node</p>
<hr>
<p>零时禁用Swap : </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">swapoff -a</span><br></pre></td></tr></table></figure>



<p>永久禁用:</p>
<p>  sed -i.bak ‘/swap/s/^/#/‘ /etc/fstab</p>
<hr>
<p>内核参数修改 :</p>
<p>   零时修改 :</p>
<p>​        sysctl net.bridge.bridge-nf-call-iptables=1</p>
<p>​       sysctl net.bridge.bridge-nf-call-ip6tables=1</p>
<p>   永久修改 :</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt;  /etc/sysctl.d/k8s.conf</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<p>   sysctl -p /etc/sysctl.d/k8s.conf</p>
<p>Notes  :  如果遇见了下面这个错误</p>
<p>sysctl: cannot stat /proc/sys/net/bridge/bridge-nf-call-iptables: No such file or directory<br>sysctl: cannot stat /proc/sys/net/bridge/bridge-nf-call-ip6tables: No such file or directory</p>
<p>执行 modprobe br_netfilter 即可.</p>
<hr>
<p>修改 Cgroup Driver  –&gt; 修改daemon.json</p>
<p> 在 /etc/docker/daemon.json中新加</p>
<p>“exec-opts”: [“native.cgroupdriver=systemd”</p>
<p>[root@localhost ~]# cat /etc/docker/daemon.json<br>{<br>  “registry-mirrors”: [“<a href="http://hub-mirror.c.163.com&quot;]">http://hub-mirror.c.163.com&quot;]</a>,<br>  “exec-opts”: [“native.cgroupdriver=systemd”]<br>}</p>
<p>这样的效果即可.</p>
<p>配置了后记得重启下docker即可</p>
<hr>
<p>设置 k8s 源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>



<blockquote>
<ol>
<li>[] 中括号中的是repository id，唯一，用来标识不同仓库</li>
<li>name 仓库名称，自定义</li>
<li>baseurl 仓库地址</li>
<li>enable 是否启用该仓库，默认为1表示启用</li>
<li>gpgcheck 是否验证从该仓库获得程序包的合法性，1为验证</li>
<li>repo_gpgcheck 是否验证元数据的合法性 元数据就是程序包列表，1为验证</li>
<li>gpgkey=URL 数字签名的公钥文件所在位置，如果gpgcheck值为1，此处就需要指定gpgkey文件的位置，如果gpgcheck值为0就不需要此项了</li>
</ol>
</blockquote>
<p>更新下缓存 :</p>
<p> yum clean all</p>
<p> yum -y makecache</p>
<hr>
<h3 id="Master节点安装"><a href="#Master节点安装" class="headerlink" title="Master节点安装"></a>Master节点安装</h3><p> 如果不指定的话,那么就默认是安装最新的</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line">yum install -y kubelet-<span class="number">1.14</span>.<span class="number">2</span> kubeadm-<span class="number">1.14</span>.<span class="number">2</span> kubectl-<span class="number">1.14</span>.<span class="number">2</span></span><br></pre></td></tr></table></figure>



<p>启动kubelet 并且设置为开机自动启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> kubelet &amp;&amp; systemctl start kubelet</span><br></pre></td></tr></table></figure>



<p>kubelet命令补全</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"source &lt;(kubectl completion bash)"</span> &gt;&gt; ~/.bash_profile</span><br><span class="line"><span class="built_in">source</span> .bash_profile</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h3><p>vi image.sh</p>
<p> 往 sh 脚本里面写入 下面的内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">url=registry.cn-hangzhou.aliyuncs.com/google_containers</span><br><span class="line">version=v1.14.2</span><br><span class="line">images=(`kubeadm config images list --kubernetes-version=<span class="variable">$version</span>|awk -F <span class="string">'/'</span> <span class="string">'&#123;print $2&#125;'</span>`)</span><br><span class="line"><span class="keyword">for</span> imagename <span class="keyword">in</span> <span class="variable">$&#123;images[@]&#125;</span> ; <span class="keyword">do</span></span><br><span class="line">  docker pull <span class="variable">$url</span>/<span class="variable">$imagename</span></span><br><span class="line">  docker tag <span class="variable">$url</span>/<span class="variable">$imagename</span> k8s.gcr.io/<span class="variable">$imagename</span></span><br><span class="line">  docker rmi -f <span class="variable">$url</span>/<span class="variable">$imagename</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>



<p>给权限 chmod u+x image.sh</p>
<p>启动 ./image.sh</p>
<hr>
<h3 id="初始化-Master"><a href="#初始化-Master" class="headerlink" title="初始化 Master"></a>初始化 Master</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubeadm init --apiserver-advertise-address 192.168.247.131 --pod-network-cidr=10.244.0.0/16</span><br></pre></td></tr></table></figure>

<p> 这里启动ok了后会有 node加入节点的信息</p>
<p>加载环境变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"export KUBECONFIG=/etc/kubernetes/admin.conf"</span> &gt;&gt; ~/.bash_profile</span><br><span class="line"><span class="built_in">source</span> .bash_profile</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">cp -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">chown $(id -u):$(id -g) <span class="variable">$HOME</span>/.kube/config</span><br></pre></td></tr></table></figure>



<hr>
<p>安装pod 网络</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br></pre></td></tr></table></figure>

<p>如果 kube-flannel.yml 访问不了的话，就创建一个,然后copy进去</p>
<h2 id="root-localhost-cat-kube-flannel-yml"><a href="#root-localhost-cat-kube-flannel-yml" class="headerlink" title="[root@localhost ~]# cat kube-flannel.yml "></a>[root@localhost ~]# cat kube-flannel.yml </h2><p>apiVersion: policy/v1beta1<br>kind: PodSecurityPolicy<br>metadata:<br>  name: psp.flannel.unprivileged<br>  annotations:<br>    seccomp.security.alpha.kubernetes.io/allowedProfileNames: docker/default<br>    seccomp.security.alpha.kubernetes.io/defaultProfileName: docker/default<br>    apparmor.security.beta.kubernetes.io/allowedProfileNames: runtime/default<br>    apparmor.security.beta.kubernetes.io/defaultProfileName: runtime/default<br>spec:<br>  privileged: false<br>  volumes:<br>    - configMap<br>    - secret<br>    - emptyDir<br>    - hostPath<br>  allowedHostPaths:<br>    - pathPrefix: “/etc/cni/net.d”<br>    - pathPrefix: “/etc/kube-flannel”<br>    - pathPrefix: “/run/flannel”<br>  readOnlyRootFilesystem: false</p>
<h1 id="Users-and-groups"><a href="#Users-and-groups" class="headerlink" title="Users and groups"></a>Users and groups</h1><p>  runAsUser:<br>    rule: RunAsAny<br>  supplementalGroups:<br>    rule: RunAsAny<br>  fsGroup:<br>    rule: RunAsAny</p>
<h1 id="Privilege-Escalation"><a href="#Privilege-Escalation" class="headerlink" title="Privilege Escalation"></a>Privilege Escalation</h1><p>  allowPrivilegeEscalation: false<br>  defaultAllowPrivilegeEscalation: false</p>
<h1 id="Capabilities"><a href="#Capabilities" class="headerlink" title="Capabilities"></a>Capabilities</h1><p>  allowedCapabilities: [‘NET_ADMIN’]<br>  defaultAddCapabilities: []<br>  requiredDropCapabilities: []</p>
<h1 id="Host-namespaces"><a href="#Host-namespaces" class="headerlink" title="Host namespaces"></a>Host namespaces</h1><p>  hostPID: false<br>  hostIPC: false<br>  hostNetwork: true<br>  hostPorts:</p>
<ul>
<li>min: 0<br>max: 65535<h1 id="SELinux"><a href="#SELinux" class="headerlink" title="SELinux"></a>SELinux</h1>seLinux:<h1 id="SELinux-is-unused-in-CaaSP"><a href="#SELinux-is-unused-in-CaaSP" class="headerlink" title="SELinux is unused in CaaSP"></a>SELinux is unused in CaaSP</h1>rule: ‘RunAsAny’</li>
</ul>
<hr>
<p>kind: ClusterRole<br>apiVersion: rbac.authorization.k8s.io/v1beta1<br>metadata:<br>  name: flannel<br>rules:</p>
<ul>
<li>apiGroups: [‘extensions’]<br>resources: [‘podsecuritypolicies’]<br>verbs: [‘use’]<br>resourceNames: [‘psp.flannel.unprivileged’]</li>
<li>apiGroups:<ul>
<li>“”<br>resources:</li>
<li>pods<br>verbs:</li>
<li>get</li>
</ul>
</li>
<li>apiGroups:<ul>
<li>“”<br>resources:</li>
<li>nodes<br>verbs:</li>
<li>list</li>
<li>watch</li>
</ul>
</li>
<li>apiGroups:<ul>
<li>“”<br>resources:</li>
<li>nodes/status<br>verbs:</li>
<li>patch</li>
</ul>
</li>
</ul>
<hr>
<p>kind: ClusterRoleBinding<br>apiVersion: rbac.authorization.k8s.io/v1beta1<br>metadata:<br>  name: flannel<br>roleRef:<br>  apiGroup: rbac.authorization.k8s.io<br>  kind: ClusterRole<br>  name: flannel<br>subjects:</p>
<ul>
<li>kind: ServiceAccount<br>name: flannel<br>namespace: kube-system</li>
</ul>
<hr>
<p>apiVersion: v1<br>kind: ServiceAccount<br>metadata:<br>  name: flannel<br>  namespace: kube-system</p>
<hr>
<p>kind: ConfigMap<br>apiVersion: v1<br>metadata:<br>  name: kube-flannel-cfg<br>  namespace: kube-system<br>  labels:<br>    tier: node<br>    app: flannel<br>data:<br>  cni-conf.json: |<br>    {<br>      “name”: “cbr0”,<br>      “cniVersion”: “0.3.1”,<br>      “plugins”: [<br>        {<br>          “type”: “flannel”,<br>          “delegate”: {<br>            “hairpinMode”: true,<br>            “isDefaultGateway”: true<br>          }<br>        },<br>        {<br>          “type”: “portmap”,<br>          “capabilities”: {<br>            “portMappings”: true<br>          }<br>        }<br>      ]<br>    }<br>  net-conf.json: |<br>    {<br>      “Network”: “10.244.0.0/16”,<br>      “Backend”: {<br>        “Type”: “vxlan”<br>      }<br>    }</p>
<hr>
<p>apiVersion: apps/v1<br>kind: DaemonSet<br>metadata:<br>  name: kube-flannel-ds-amd64<br>  namespace: kube-system<br>  labels:<br>    tier: node<br>    app: flannel<br>spec:<br>  selector:<br>    matchLabels:<br>      app: flannel<br>  template:<br>    metadata:<br>      labels:<br>        tier: node<br>        app: flannel<br>    spec:<br>      affinity:<br>        nodeAffinity:<br>          requiredDuringSchedulingIgnoredDuringExecution:<br>            nodeSelectorTerms:<br>              - matchExpressions:<br>                  - key: kubernetes.io/os<br>                    operator: In<br>                    values:<br>                      - linux<br>                  - key: kubernetes.io/arch<br>                    operator: In<br>                    values:<br>                      - amd64<br>      hostNetwork: true<br>      tolerations:<br>      - operator: Exists<br>        effect: NoSchedule<br>      serviceAccountName: flannel<br>      initContainers:<br>      - name: install-cni<br>        image: quay.io/coreos/flannel:v0.12.0-amd64<br>        command:<br>        - cp<br>        args:<br>        - -f<br>        - /etc/kube-flannel/cni-conf.json<br>        - /etc/cni/net.d/10-flannel.conflist<br>        volumeMounts:<br>        - name: cni<br>          mountPath: /etc/cni/net.d<br>        - name: flannel-cfg<br>          mountPath: /etc/kube-flannel/<br>      containers:<br>      - name: kube-flannel<br>        image: quay.io/coreos/flannel:v0.12.0-amd64<br>        command:<br>        - /opt/bin/flanneld<br>        args:<br>        - –ip-masq<br>        - –kube-subnet-mgr<br>        resources:<br>          requests:<br>            cpu: “100m”<br>            memory: “50Mi”<br>          limits:<br>            cpu: “100m”<br>            memory: “50Mi”<br>        securityContext:<br>          privileged: false<br>          capabilities:<br>            add: [“NET_ADMIN”]<br>        env:<br>        - name: POD_NAME<br>          valueFrom:<br>            fieldRef:<br>              fieldPath: metadata.name<br>        - name: POD_NAMESPACE<br>          valueFrom:<br>            fieldRef:<br>              fieldPath: metadata.namespace<br>        volumeMounts:<br>        - name: run<br>          mountPath: /run/flannel<br>        - name: flannel-cfg<br>          mountPath: /etc/kube-flannel/<br>      volumes:<br>        - name: run<br>          hostPath:<br>            path: /run/flannel<br>        - name: cni<br>          hostPath:<br>            path: /etc/cni/net.d<br>        - name: flannel-cfg<br>          configMap:<br>            name: kube-flannel-cfg</p>
<hr>
<p>apiVersion: apps/v1<br>kind: DaemonSet<br>metadata:<br>  name: kube-flannel-ds-arm64<br>  namespace: kube-system<br>  labels:<br>    tier: node<br>    app: flannel<br>spec:<br>  selector:<br>    matchLabels:<br>      app: flannel<br>  template:<br>    metadata:<br>      labels:<br>        tier: node<br>        app: flannel<br>    spec:<br>      affinity:<br>        nodeAffinity:<br>          requiredDuringSchedulingIgnoredDuringExecution:<br>            nodeSelectorTerms:<br>              - matchExpressions:<br>                  - key: kubernetes.io/os<br>                    operator: In<br>                    values:<br>                      - linux<br>                  - key: kubernetes.io/arch<br>                    operator: In<br>                    values:<br>                      - arm64<br>      hostNetwork: true<br>      tolerations:<br>      - operator: Exists<br>        effect: NoSchedule<br>      serviceAccountName: flannel<br>      initContainers:<br>      - name: install-cni<br>        image: quay.io/coreos/flannel:v0.12.0-arm64<br>        command:<br>        - cp<br>        args:<br>        - -f<br>        - /etc/kube-flannel/cni-conf.json<br>        - /etc/cni/net.d/10-flannel.conflist<br>        volumeMounts:<br>        - name: cni<br>          mountPath: /etc/cni/net.d<br>        - name: flannel-cfg<br>          mountPath: /etc/kube-flannel/<br>      containers:<br>      - name: kube-flannel<br>        image: quay.io/coreos/flannel:v0.12.0-arm64<br>        command:<br>        - /opt/bin/flanneld<br>        args:<br>        - –ip-masq<br>        - –kube-subnet-mgr<br>        resources:<br>          requests:<br>            cpu: “100m”<br>            memory: “50Mi”<br>          limits:<br>            cpu: “100m”<br>            memory: “50Mi”<br>        securityContext:<br>          privileged: false<br>          capabilities:<br>             add: [“NET_ADMIN”]<br>        env:<br>        - name: POD_NAME<br>          valueFrom:<br>            fieldRef:<br>              fieldPath: metadata.name<br>        - name: POD_NAMESPACE<br>          valueFrom:<br>            fieldRef:<br>              fieldPath: metadata.namespace<br>        volumeMounts:<br>        - name: run<br>          mountPath: /run/flannel<br>        - name: flannel-cfg<br>          mountPath: /etc/kube-flannel/<br>      volumes:<br>        - name: run<br>          hostPath:<br>            path: /run/flannel<br>        - name: cni<br>          hostPath:<br>            path: /etc/cni/net.d<br>        - name: flannel-cfg<br>          configMap:<br>            name: kube-flannel-cfg</p>
<hr>
<p>apiVersion: apps/v1<br>kind: DaemonSet<br>metadata:<br>  name: kube-flannel-ds-arm<br>  namespace: kube-system<br>  labels:<br>    tier: node<br>    app: flannel<br>spec:<br>  selector:<br>    matchLabels:<br>      app: flannel<br>  template:<br>    metadata:<br>      labels:<br>        tier: node<br>        app: flannel<br>    spec:<br>      affinity:<br>        nodeAffinity:<br>          requiredDuringSchedulingIgnoredDuringExecution:<br>            nodeSelectorTerms:<br>              - matchExpressions:<br>                  - key: kubernetes.io/os<br>                    operator: In<br>                    values:<br>                      - linux<br>                  - key: kubernetes.io/arch<br>                    operator: In<br>                    values:<br>                      - arm<br>      hostNetwork: true<br>      tolerations:<br>      - operator: Exists<br>        effect: NoSchedule<br>      serviceAccountName: flannel<br>      initContainers:<br>      - name: install-cni<br>        image: quay.io/coreos/flannel:v0.12.0-arm<br>        command:<br>        - cp<br>        args:<br>        - -f<br>        - /etc/kube-flannel/cni-conf.json<br>        - /etc/cni/net.d/10-flannel.conflist<br>        volumeMounts:<br>        - name: cni<br>          mountPath: /etc/cni/net.d<br>        - name: flannel-cfg<br>          mountPath: /etc/kube-flannel/<br>      containers:<br>      - name: kube-flannel<br>        image: quay.io/coreos/flannel:v0.12.0-arm<br>        command:<br>        - /opt/bin/flanneld<br>        args:<br>        - –ip-masq<br>        - –kube-subnet-mgr<br>        resources:<br>          requests:<br>            cpu: “100m”<br>            memory: “50Mi”<br>          limits:<br>            cpu: “100m”<br>            memory: “50Mi”<br>        securityContext:<br>          privileged: false<br>          capabilities:<br>             add: [“NET_ADMIN”]<br>        env:<br>        - name: POD_NAME<br>          valueFrom:<br>            fieldRef:<br>              fieldPath: metadata.name<br>        - name: POD_NAMESPACE<br>          valueFrom:<br>            fieldRef:<br>              fieldPath: metadata.namespace<br>        volumeMounts:<br>        - name: run<br>          mountPath: /run/flannel<br>        - name: flannel-cfg<br>          mountPath: /etc/kube-flannel/<br>      volumes:<br>        - name: run<br>          hostPath:<br>            path: /run/flannel<br>        - name: cni<br>          hostPath:<br>            path: /etc/cni/net.d<br>        - name: flannel-cfg<br>          configMap:<br>            name: kube-flannel-cfg</p>
<hr>
<p>apiVersion: apps/v1<br>kind: DaemonSet<br>metadata:<br>  name: kube-flannel-ds-ppc64le<br>  namespace: kube-system<br>  labels:<br>    tier: node<br>    app: flannel<br>spec:<br>  selector:<br>    matchLabels:<br>      app: flannel<br>  template:<br>    metadata:<br>      labels:<br>        tier: node<br>        app: flannel<br>    spec:<br>      affinity:<br>        nodeAffinity:<br>          requiredDuringSchedulingIgnoredDuringExecution:<br>            nodeSelectorTerms:<br>              - matchExpressions:<br>                  - key: kubernetes.io/os<br>                    operator: In<br>                    values:<br>                      - linux<br>                  - key: kubernetes.io/arch<br>                    operator: In<br>                    values:<br>                      - ppc64le<br>      hostNetwork: true<br>      tolerations:<br>      - operator: Exists<br>        effect: NoSchedule<br>      serviceAccountName: flannel<br>      initContainers:<br>      - name: install-cni<br>        image: quay.io/coreos/flannel:v0.12.0-ppc64le<br>        command:<br>        - cp<br>        args:<br>        - -f<br>        - /etc/kube-flannel/cni-conf.json<br>        - /etc/cni/net.d/10-flannel.conflist<br>        volumeMounts:<br>        - name: cni<br>          mountPath: /etc/cni/net.d<br>        - name: flannel-cfg<br>          mountPath: /etc/kube-flannel/<br>      containers:<br>      - name: kube-flannel<br>        image: quay.io/coreos/flannel:v0.12.0-ppc64le<br>        command:<br>        - /opt/bin/flanneld<br>        args:<br>        - –ip-masq<br>        - –kube-subnet-mgr<br>        resources:<br>          requests:<br>            cpu: “100m”<br>            memory: “50Mi”<br>          limits:<br>            cpu: “100m”<br>            memory: “50Mi”<br>        securityContext:<br>          privileged: false<br>          capabilities:<br>             add: [“NET_ADMIN”]<br>        env:<br>        - name: POD_NAME<br>          valueFrom:<br>            fieldRef:<br>              fieldPath: metadata.name<br>        - name: POD_NAMESPACE<br>          valueFrom:<br>            fieldRef:<br>              fieldPath: metadata.namespace<br>        volumeMounts:<br>        - name: run<br>          mountPath: /run/flannel<br>        - name: flannel-cfg<br>          mountPath: /etc/kube-flannel/<br>      volumes:<br>        - name: run<br>          hostPath:<br>            path: /run/flannel<br>        - name: cni<br>          hostPath:<br>            path: /etc/cni/net.d<br>        - name: flannel-cfg<br>          configMap:<br>            name: kube-flannel-cfg</p>
<hr>
<p>apiVersion: apps/v1<br>kind: DaemonSet<br>metadata:<br>  name: kube-flannel-ds-s390x<br>  namespace: kube-system<br>  labels:<br>    tier: node<br>    app: flannel<br>spec:<br>  selector:<br>    matchLabels:<br>      app: flannel<br>  template:<br>    metadata:<br>      labels:<br>        tier: node<br>        app: flannel<br>    spec:<br>      affinity:<br>        nodeAffinity:<br>          requiredDuringSchedulingIgnoredDuringExecution:<br>            nodeSelectorTerms:<br>              - matchExpressions:<br>                  - key: kubernetes.io/os<br>                    operator: In<br>                    values:<br>                      - linux<br>                  - key: kubernetes.io/arch<br>                    operator: In<br>                    values:<br>                      - s390x<br>            hostNetwork: true<br>            tolerations:<br>            - operator: Exists<br>                effect: NoSchedule<br>            serviceAccountName: flannel<br>            initContainers:<br>            - name: install-cni<br>                image: quay.io/coreos/flannel:v0.12.0-s390x<br>                command:<br>                - cp<br>                args:<br>                - -f<br>                - /etc/kube-flannel/cni-conf.json<br>                - /etc/cni/net.d/10-flannel.conflist<br>                volumeMounts:<br>                - name: cni<br>                    mountPath: /etc/cni/net.d<br>                - name: flannel-cfg<br>                    mountPath: /etc/kube-flannel/<br>            containers:<br>            - name: kube-flannel<br>                image: quay.io/coreos/flannel:v0.12.0-s390x<br>                command:<br>                - /opt/bin/flanneld<br>                args:<br>                - –ip-masq<br>                - –kube-subnet-mgr<br>                resources:<br>                    requests:<br>                        cpu: “100m”<br>                        memory: “50Mi”<br>                    limits:<br>                        cpu: “100m”<br>                        memory: “50Mi”<br>                securityContext:<br>                    privileged: false<br>                    capabilities:<br>                          add: [“NET_ADMIN”]<br>                env:<br>                - name: POD_NAME<br>                    valueFrom:<br>                        fieldRef:<br>                            fieldPath: metadata.name<br>                - name: POD_NAMESPACE<br>                    valueFrom:<br>                        fieldRef:<br>                            fieldPath: metadata.namespace<br>                volumeMounts:<br>                - name: run<br>                    mountPath: /run/flannel<br>                - name: flannel-cfg<br>                    mountPath: /etc/kube-flannel/<br>            volumes:<br>                - name: run<br>                    hostPath:<br>                        path: /run/flannel<br>                - name: cni<br>                    hostPath:<br>                        path: /etc/cni/net.d<br>                - name: flannel-cfg<br>                    configMap:<br>                        name: kube-flannel-cfg</p>
<p>然后执行 kubectl apply -f kube-flannel.yml 即可</p>
<hr>
<p>Node 节点执行加入的指令即可</p>
<p>安装 K8s 过程中如果出现错误的话.</p>
<blockquote>
<p>error execution phase preflight: [preflight] Some fatal errors occurred:<br>[ERROR ImagePull]: failed to pull image k8s.gcr.io/kube-apiserver:v1.18.0: output: Error response from daemon: Get <a href="https://k8s.gcr.io/v2/" target="_blank" rel="noopener">https://k8s.gcr.io/v2/</a>: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)<br>, error: exit status 1<br>   [ERROR ImagePull]: failed to pull image k8s.gcr.io/kube-controller-manager:v1.18.0: output: Error response from daemon: Get <a href="https://k8s.gcr.io/v2/" target="_blank" rel="noopener">https://k8s.gcr.io/v2/</a>: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)<br>, error: exit status 1<br>   [ERROR ImagePull]: failed to pull image k8s.gcr.io/kube-scheduler:v1.18.0: output: Error response from daemon: Get <a href="https://k8s.gcr.io/v2/" target="_blank" rel="noopener">https://k8s.gcr.io/v2/</a>: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)<br>, error: exit status 1<br>   [ERROR ImagePull]: failed to pull image k8s.gcr.io/kube-proxy:v1.18.0: output: Error response from daemon: Get <a href="https://k8s.gcr.io/v2/" target="_blank" rel="noopener">https://k8s.gcr.io/v2/</a>: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)<br>, error: exit status 1<br>   [ERROR ImagePull]: failed to pull image k8s.gcr.io/pause:3.2: output: Error response from daemon: Get <a href="https://k8s.gcr.io/v2/" target="_blank" rel="noopener">https://k8s.gcr.io/v2/</a>: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)<br>, error: exit status 1<br>   [ERROR ImagePull]: failed to pull image k8s.gcr.io/etcd:3.4.3-0: output: Error response from daemon: Get <a href="https://k8s.gcr.io/v2/" target="_blank" rel="noopener">https://k8s.gcr.io/v2/</a>: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)<br>, error: exit status 1<br>   [ERROR ImagePull]: failed to pull image k8s.gcr.io/coredns:1.6.7: output: Error response from daemon: Get <a href="https://k8s.gcr.io/v2/" target="_blank" rel="noopener">https://k8s.gcr.io/v2/</a>: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)<br>, error: exit status 1docker tag docker.io/mirrorgooglecontainers/kube-apiserver:v1.14.0</p>
</blockquote>
<p>Helm 安装</p>
<blockquote>
<p>这里的v2.14.1 版本是可以选择的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;curl -O https:&#x2F;&#x2F;get.helm.sh&#x2F;helm-v2.14.1-linux-amd64.tar.gz</span><br></pre></td></tr></table></figure>


</blockquote>
<p>Helm 卸载 tiller 操作</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;kubectl get -n kube-system secrets,sa,clusterrolebinding -o name|grep tiller|xargs kubectl -n kube-system delete</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;kubectl get all -n kube-system -l app&#x3D;helm -o name|xargs kubectl delete -n kube-system</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>https://www.cnblogs.com/jackluo/p/10345266.html</code> 参考地址</p>
<p>低版本Helm 的 tiller 处理方法</p>
<p><code>helm init --upgrade --tiller-image cnych/tiller:v2.10.0</code></p>
<blockquote>
<p><a href="https://www.jianshu.com/p/f43f07361398https://www.jianshu.com/p/f43f07361398" target="_blank" rel="noopener">https://www.jianshu.com/p/f43f07361398https://www.jianshu.com/p/f43f07361398</a> 参考地址</p>
</blockquote>
<p>错误:</p>
<blockquote>
<p>[root@node1 ~]# helm install stable/nginx-ingress -n nginx-ingress –namespace kube-system  -f ingress-nginx.yaml<br>Error: release nginx-ingress failed: namespaces “kube-system” is forbidden: User “system:serviceaccount:kube-system:default” cannot get resource “namespaces” in API group “” in the namespace “kube-system”<br>[root@node1 ~]# </p>
</blockquote>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis-work-flow-read</title>
    <url>/2020/12/25/mybatis/mybatis-work-flow-read/</url>
    <content><![CDATA[<h4 id="MyBatis-的工程流程分析"><a href="#MyBatis-的工程流程分析" class="headerlink" title="MyBatis 的工程流程分析"></a>MyBatis 的工程流程分析</h4><p>​    MyBatis 是我们在学习Java框架，也就是学习完JavaWeb的知识后,要学习到的一个ORM的框架. 我也是学习&amp;使用过后，再次对源码进行阅读的. 所以这篇文章记录 MyBatis 的一个 work flow.</p>
<p>​    先放上项目地址 : <a href="https://github.com/baoyang23/mybtatis-analysis/tree/master/mybatis-work-flow" target="_blank" rel="noopener">https://github.com/baoyang23/mybtatis-analysis/tree/master/mybatis-work-flow</a> </p>
<p>​    有兴趣的同学,可以clone下来看看.</p>
<h4 id="案例代码"><a href="#案例代码" class="headerlink" title="案例代码"></a>案例代码</h4><p>先放上案列的代码, 然后我们可以挨个的分析.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitHelloMyBatis</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 读取配置文件.</span></span><br><span class="line">        InputStream mybatisInputStream = Resources.getResourceAsStream(<span class="string">"mybatis-config.xml"</span>);</span><br><span class="line">        <span class="comment">// 传入读取配置文件的流,使用SqlSessionFactoryBuilder来</span></span><br><span class="line">        <span class="comment">// 构建 SqlSessionFactory.</span></span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(mybatisInputStream);</span><br><span class="line">        <span class="comment">// 从 SqlSessionFactory 中获取SqlSession会话.</span></span><br><span class="line">        SqlSession session = sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从会话中获取 Mapper.</span></span><br><span class="line">        BlogMapper blogMapper = session.getMapper(BlogMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用查询方法.</span></span><br><span class="line">        TbBlog tbBlog = blogMapper.selectBlog(<span class="number">1</span>);</span><br><span class="line">        System.out.println(tbBlog);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里说下大致流程 : </p>
<ul>
<li>使用 Resources 来读取 mybatis-config.xml配置文件, 如果该文件不存在或者读取出来 InputStream 是 null 的话,程序就会抛出 IOException 的错误来.</li>
<li>读取配置没有问题,来到 new SqlSessionFactoryBuilder().build(io) 来构建出一个 SqlSessionFactory 来, 这里构建出来的 SqlSessionFactory 肯定是有已经讲配置文件给全部加载进去了的.</li>
<li>SqlSessionFactory.openSession() 从 SqlSessionFactory 中获取一次会话, 然后可以从会话中获取出接口(BlogMapper)来,这里是不是有点好奇,明明这就是一个接口,也没有实现类,怎么就可以get出一个接口对象来?获取出接口来,然后就可以调用接口中的方法, 根据id查询出数据来.</li>
</ul>
<p>可以看到,根据从官网写的一个列子,从表面来看,代码量并不是很多. 所以接下来点去源码,去跟进源码中的每个方法,到底做了些什么事情.</p>
<p><strong>读取配置文件</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">InputStream mybatisInputStream &#x3D; Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br></pre></td></tr></table></figure>

<p>org.apache.ibatis.io.Resources (Class).</p>
<p>可以看到MyBatis源码还写了一个 ClassLoader的包装类，通过ClassLoaderWrapper包装类来讲配置文件转化为InputSream.</p>
<p>如果返回的InputStream是null，就会抛出IOException来.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Returns a resource on the classpath as a Stream object</span><br><span class="line"> *</span><br><span class="line"> * @param loader   The classloader used to fetch the resource</span><br><span class="line"> * @param resource The resource to find</span><br><span class="line"> * @return The resource</span><br><span class="line"> * @throws java.io.IOException If the resource cannot be found or read</span><br><span class="line"> *&#x2F;</span><br><span class="line">private static ClassLoaderWrapper classLoaderWrapper &#x3D; new ClassLoaderWrapper();</span><br><span class="line"></span><br><span class="line">public static InputStream getResourceAsStream(ClassLoader loader, String resource) throws IOException &#123;</span><br><span class="line">  &#x2F;&#x2F; 利用 ClasssLoaderWrapper.  </span><br><span class="line">  InputStream in &#x3D; classLoaderWrapper.getResourceAsStream(resource, loader);</span><br><span class="line">  if (in &#x3D;&#x3D; null) &#123;</span><br><span class="line">    throw new IOException(&quot;Could not find resource &quot; + resource);</span><br><span class="line">  &#125;</span><br><span class="line">  return in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>于是我们接着看 ClassLoaderWrapper 是怎么 读取配置文件 &amp; 转化为 InputStream 流的.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 这里返回的是 ClassLoader的数组,如果对ClassLoader不是很了解的话,可以先去百度了解下.</span><br><span class="line">ClassLoader[] getClassLoaders(ClassLoader classLoader) &#123;</span><br><span class="line">  return new ClassLoader[]&#123;</span><br><span class="line">      &#x2F;&#x2F; 传递进来的 </span><br><span class="line">      classLoader,</span><br><span class="line">      &#x2F;&#x2F; 默认的 ClassLoader</span><br><span class="line">      defaultClassLoader,</span><br><span class="line">      &#x2F;&#x2F; 根据当前线程获取出来的</span><br><span class="line">      Thread.currentThread().getContextClassLoader(),</span><br><span class="line">      &#x2F;&#x2F; 根据当前 Class 获取出来的.</span><br><span class="line">      getClass().getClassLoader(),</span><br><span class="line">      &#x2F;&#x2F; 系统的ClassLoader.</span><br><span class="line">      systemClassLoader&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取到了 classLoader的数组,然后对其进行迭代.</span><br><span class="line">&#x2F;&#x2F; 也就是使用 ClassLoader的  getResourceAsStream 方法,来讲 mybatis-config.xml</span><br><span class="line">&#x2F;&#x2F; 配置文件转化为 InputStream.</span><br><span class="line">&#x2F;&#x2F; 最后如果获取到InputStream都是null的话,那么返回的也就是null了.</span><br><span class="line">&#x2F;&#x2F; 根据上面的说法,返回的如果是null的话,就会出 IOException来.</span><br><span class="line">InputStream getResourceAsStream(String resource, ClassLoader[] classLoader) &#123;</span><br><span class="line">    for (ClassLoader cl : classLoader) &#123;</span><br><span class="line">      if (null !&#x3D; cl) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; try to find the resource as passed</span><br><span class="line">        InputStream returnValue &#x3D; cl.getResourceAsStream(resource);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; now, some class loaders want this leading &quot;&#x2F;&quot;, so we&#39;ll add it and try again if we didn&#39;t find the resource</span><br><span class="line">        if (null &#x3D;&#x3D; returnValue) &#123;</span><br><span class="line">          returnValue &#x3D; cl.getResourceAsStream(&quot;&#x2F;&quot; + resource);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (null !&#x3D; returnValue) &#123;</span><br><span class="line">          return returnValue;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>至此,MyBatis读取 mybatis-config.xml 配置文件也就是解析完毕,可以看到采用了自己写的 ClassLoaderWrapper来操作的, 传递一种 ClassLoader进来,其默认的&amp;系统&amp;线程的,加一起也是有四种. 最后挨个进来迭代，满足条件的会读取文件转化为InputStream,如果都是null的话,也会返回null.</strong></p>
<hr>
<p><strong>获取SqlSessionFactory &amp; 解析配置文件</strong></p>
<p>new SqlSessionFactoryBuilder() 也是new了一个 SqlSessionFactoryBuild,个人理解 SqlSessionFactoryBuilder 就是专程用来构建出 SqlSessionFactory 来的,毕竟其后面有一个 build 方法.</p>
<p>Problem ? 这里有个问题,为什么不将 SqlSessionFactoryBuilder 的build 方法,修改为静态的 ? 如果修改为静态的话，那就不用new了,就可以直接 SqlSessionFactoryBuilder.build(mybatisInputStream);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SqlSessionFactory sqlSessionFactory &#x3D; new                     SqlSessionFactoryBuilder().build(mybatisInputStream);</span><br></pre></td></tr></table></figure>

<p> <strong>SqlSessionFactory</strong></p>
<p> 接着我们来到 SqlSessionFactory 的 build 方法.</p>
<p> 这里在 finnaly 中, 可以看到 ErrorContext 利用了 ThreadLocal , 刚好这周出了 ThreadLocal 的视频.</p>
<p> 视频地址 : <a href="https://www.bilibili.com/video/BV1Ga4y1W72w" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Ga4y1W72w</a></p>
<p> 有兴趣&amp;乐于学习&amp;分享的,可以共同进步.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    &#x2F;&#x2F; 利用传入进来的参数,new出来了一个 XMLConfigBuilder.</span><br><span class="line">    XMLConfigBuilder parser &#x3D; new XMLConfigBuilder(inputStream, environment, properties);</span><br><span class="line">    return build(parser.parse());</span><br><span class="line">  &#125; catch (Exception e) &#123;</span><br><span class="line">    throw ExceptionFactory.wrapException(&quot;Error building SqlSession.&quot;, e);</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    &#x2F;&#x2F; 这里对 ThreadLocal 中进行 remove() 操作   </span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F; 关闭流.  </span><br><span class="line">      inputStream.close();</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">      &#x2F;&#x2F; Intentionally ignore. Prefer previous error.</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>new XmlConfigBuilder() 方法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public XMLConfigBuilder(InputStream inputStream, String environment, Properties props) &#123;</span><br><span class="line">  &#x2F;&#x2F; 先new一个XMLMapperEntityResolver,再new一个XPathParser,然后就走到下面的构造函数.</span><br><span class="line">  this(new XPathParser(inputStream, true, props, new XMLMapperEntityResolver()), environment, props);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 最后还是走到这个构造方法中来.</span><br><span class="line">private XMLConfigBuilder(XPathParser parser, String environment, Properties props) &#123;</span><br><span class="line">  super(new Configuration());</span><br><span class="line">  ErrorContext.instance().resource(&quot;SQL Mapper Configuration&quot;);</span><br><span class="line">  this.configuration.setVariables(props);</span><br><span class="line">  this.parsed &#x3D; false;</span><br><span class="line">  this.environment &#x3D; environment;</span><br><span class="line">  this.parser &#x3D; parser;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----------------------------------------</span><br><span class="line">&#x2F;&#x2F; new XPathParser代码:</span><br><span class="line">    </span><br><span class="line">  public XPathParser(InputStream inputStream, boolean validation, Properties variables, EntityResolver entityResolver) &#123;</span><br><span class="line">    &#x2F;&#x2F; 普通的构造方法.</span><br><span class="line">    &#x2F;&#x2F; 对 XPathParser的validation&#x2F;entityResolver&#x2F;variables&#x2F;xpath</span><br><span class="line">    &#x2F;&#x2F; 的属性进行赋值操作.</span><br><span class="line">    commonConstructor(validation, variables, entityResolver);</span><br><span class="line">    this.document &#x3D; createDocument(new InputSource(inputStream));</span><br><span class="line">  &#125;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; createDocument 方法</span><br><span class="line">  private Document createDocument(InputSource inputSource) &#123;</span><br><span class="line">    &#x2F;&#x2F; important: this must only be called AFTER common constructor</span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F; 这里通过debug看,返回的对象是DocumentBuilderFactoryImpl</span><br><span class="line">      &#x2F;&#x2F; 也就是其实现类.  </span><br><span class="line">      DocumentBuilderFactory factory &#x3D; DocumentBuilderFactory.newInstance();</span><br><span class="line">     &#x2F;&#x2F; 对 factory 的 features(HashMap) 添加值,   </span><br><span class="line">      factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);</span><br><span class="line">     &#x2F;&#x2F; 对 factory 的 validating 进行赋值  </span><br><span class="line">      factory.setValidating(validation);</span><br><span class="line">	 &#x2F;&#x2F; 这下面都是对 factory的属性进行赋值操作.	</span><br><span class="line">      factory.setNamespaceAware(false);</span><br><span class="line">      factory.setIgnoringComments(true);</span><br><span class="line">      factory.setIgnoringElementContentWhitespace(false);</span><br><span class="line">      factory.setCoalescing(false);</span><br><span class="line">      factory.setExpandEntityReferences(true);</span><br><span class="line">		</span><br><span class="line">      &#x2F;&#x2F; 可以看到 return new DocumentBuilderImpl</span><br><span class="line">      &#x2F;&#x2F; 最后返回的也是其实现类. </span><br><span class="line">      DocumentBuilder builder &#x3D; factory.newDocumentBuilder();</span><br><span class="line">      builder.setEntityResolver(entityResolver);</span><br><span class="line">      &#x2F;&#x2F; 设置错误的handler,可以看到ErrorHandler是接口,这里是匿名实现的</span><br><span class="line">      &#x2F;&#x2F; 也就是直接new了接口,然后重写其方法.  </span><br><span class="line">      builder.setErrorHandler(new ErrorHandler() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void error(SAXParseException exception) throws SAXException &#123;</span><br><span class="line">          throw exception;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void fatalError(SAXParseException exception) throws SAXException &#123;</span><br><span class="line">          throw exception;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void warning(SAXParseException exception) throws SAXException &#123;</span><br><span class="line">          &#x2F;&#x2F; NOP</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      &#x2F;&#x2F;   DocumentBuilderImpl 的 parse 解析方法</span><br><span class="line">      return builder.parse(inputSource);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      throw new BuilderException(&quot;Error creating document instance.  Cause: &quot; + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">-------------</span><br><span class="line">&#x2F;&#x2F;   builder.parse(inputSource)</span><br><span class="line"></span><br><span class="line">    public Document parse(InputSource is) throws SAXException, IOException &#123;</span><br><span class="line">        if (is &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(</span><br><span class="line">                DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN,</span><br><span class="line">                &quot;jaxp-null-input-source&quot;, null));</span><br><span class="line">        &#125;</span><br><span class="line">    &#x2F;&#x2F; fSchemaValidator 是 null ,跳过.</span><br><span class="line">        if (fSchemaValidator !&#x3D; null) &#123;</span><br><span class="line">            if (fSchemaValidationManager !&#x3D; null) &#123;</span><br><span class="line">                fSchemaValidationManager.reset();</span><br><span class="line">                fUnparsedEntityHandler.reset();</span><br><span class="line">            &#125;</span><br><span class="line">            resetSchemaValidator();</span><br><span class="line">        &#125;</span><br><span class="line">  &#x2F;&#x2F; 使用 xml 的相关类对 is 进行解析  </span><br><span class="line">        domParser.parse(is);</span><br><span class="line"> &#x2F;&#x2F;  ?   </span><br><span class="line">        Document doc &#x3D; domParser.getDocument();</span><br><span class="line"> &#x2F;&#x2F; ? 这些解析 Document 的地方.....   </span><br><span class="line">        domParser.dropDocumentReferences();</span><br><span class="line">        return doc;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------------</span><br><span class="line">&#x2F;&#x2F; 最后看到 this 构造函数.</span><br><span class="line"></span><br><span class="line">  private XMLConfigBuilder(XPathParser parser, String environment, Properties props) &#123;</span><br><span class="line">    &#x2F;** new Configuration() 中,TypeAliasRegistry typeAliasRegistry中的 typeAliases,</span><br><span class="line">    *   在初始化这个对象的时候,就默认设置了一些别名配置.</span><br><span class="line">    *   初始化的时候,还有对 LanguageDriverRegistry 的 LANGUAGE_DRIVER_MAP 赋值.</span><br><span class="line">    *  父类 :  BaseBuilder抽象类.</span><br><span class="line">    *  然后调用super方法,将configuration赋值父类的configuration</span><br><span class="line">    *  同时将 configuration的typeAliasRegistry和typeHandlerRegistry也赋值</span><br><span class="line">    *  给当前的这个对象.</span><br><span class="line">    *   </span><br><span class="line">    *&#x2F;</span><br><span class="line">    super(new Configuration());</span><br><span class="line">    &#x2F;&#x2F; instance() 方法是往 ThreadLocal里面去set了一个ErrorContext</span><br><span class="line">    &#x2F;&#x2F; 最后会在finnaly中进行remove掉.</span><br><span class="line">    ErrorContext.instance().resource(&quot;SQL Mapper Configuration&quot;);</span><br><span class="line">    &#x2F;&#x2F; 将 props 赋值到 configuration 的 variable 参数.</span><br><span class="line">    this.configuration.setVariables(props);</span><br><span class="line">    &#x2F;&#x2F; 表示还没有被解析</span><br><span class="line">    this.parsed &#x3D; false;</span><br><span class="line">    this.environment &#x3D; environment;</span><br><span class="line">    this.parser &#x3D; parser;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>到这里,就可以看到 this构造方法以及其之前还有new对象的方法,都已经走完了. 这上面的方法,基本都是再为后面的解析xml文件做准备, 并且还有一些初始化数据的赋值操作.</p>
<p><strong>Note</strong> : 注意这里的 BaseBuilder是抽象类,其实现类是有好几个的. 这种写法,其实是将子类的一些common的方法,写入到 BaseBuilder父类中,然后不同的方法,需要子类自己去重写这个方法实现自己的业务逻辑. 当然一些参数也是可以放在抽象类中.</p>
<p><strong>build(parser.parse())</strong> : 解析代码.</p>
<p> parser.parse() 方法 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Configuration parse() &#123;</span><br><span class="line">  &#x2F;&#x2F; 用 parsed 来控制是否解析过,如果已经解析过了,那就抛出异常.  </span><br><span class="line">  if (parsed) &#123;</span><br><span class="line">    throw new BuilderException(&quot;Each XMLConfigBuilder can only be used once.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  parsed &#x3D; true;</span><br><span class="line">  &#x2F;&#x2F;   </span><br><span class="line">  parseConfiguration(parser.evalNode(&quot;&#x2F;configuration&quot;));</span><br><span class="line">  return configuration;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------------------------------</span><br><span class="line">&#x2F;&#x2F; parseConfiguration</span><br><span class="line">&#x2F;&#x2F; 这里 debug 可以看到 root 是 configuration 的配置文件信息.   </span><br><span class="line">&#x2F;&#x2F; 这里可以初步看到实对 我们的配置文件mybatis-config.xml进行解析,并且加载到 configuration中.</span><br><span class="line">&#x2F;&#x2F; 后面我们跟着官网文档一步一步的阅读,会有专门对解析配置的源码进行分析.    </span><br><span class="line">  private void parseConfiguration(XNode root) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F;issue #117 read properties first</span><br><span class="line">      &#x2F;&#x2F;   </span><br><span class="line">      propertiesElement(root.evalNode(&quot;properties&quot;));</span><br><span class="line">      Properties settings &#x3D; settingsAsProperties(root.evalNode(&quot;settings&quot;));</span><br><span class="line">      loadCustomVfs(settings);</span><br><span class="line">      loadCustomLogImpl(settings);</span><br><span class="line">      typeAliasesElement(root.evalNode(&quot;typeAliases&quot;));</span><br><span class="line">      pluginElement(root.evalNode(&quot;plugins&quot;));</span><br><span class="line">      objectFactoryElement(root.evalNode(&quot;objectFactory&quot;));</span><br><span class="line">      objectWrapperFactoryElement(root.evalNode(&quot;objectWrapperFactory&quot;));</span><br><span class="line">      reflectorFactoryElement(root.evalNode(&quot;reflectorFactory&quot;));</span><br><span class="line">      settingsElement(settings);</span><br><span class="line">      &#x2F;&#x2F; read it after objectFactory and objectWrapperFactory issue #631</span><br><span class="line">      environmentsElement(root.evalNode(&quot;environments&quot;));</span><br><span class="line">      databaseIdProviderElement(root.evalNode(&quot;databaseIdProvider&quot;));</span><br><span class="line">      typeHandlerElement(root.evalNode(&quot;typeHandlers&quot;));</span><br><span class="line">      mapperElement(root.evalNode(&quot;mappers&quot;));</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      throw new BuilderException(&quot;Error parsing SQL Mapper Configuration. Cause: &quot; + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>build(parser.parse()) 方法</strong></p>
<p>这里是对 parser.parse() 调用玩返回的 Configuration 传入到新创建的 DefaultSqlSessionFactory 对象中.</p>
<p>也就是说,我们拿到的 SqlSessionFactory 是 DefaultSqlSessionFactory.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public SqlSessionFactory build(Configuration config) &#123;</span><br><span class="line">  return new DefaultSqlSessionFactory(config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>获取 SqlSession</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SqlSession session &#x3D; sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; org.apache.ibatis.session.defaults.DefaultSqlSessionFactory#openSessionFromDataSource</span><br><span class="line">&#x2F;&#x2F; 看到这个方法,直接跟进到这个方法来.</span><br><span class="line"></span><br><span class="line">  private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) &#123;</span><br><span class="line">    Transaction tx &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">        </span><br><span class="line">&#x2F;&#x2F; 从 configuration中获取出environment来,这里的 getEnvironment对应的是</span><br><span class="line">&#x2F;&#x2F; 标签的 &lt;environment&gt;  里面的内容</span><br><span class="line">&#x2F;&#x2F; org.apache.ibatis.mapping.Environment</span><br><span class="line">&#x2F;&#x2F; 可以看到这个对象,id对应mybatis-config.xml中的environment id</span><br><span class="line">&#x2F;&#x2F; datasource 对应  environment &gt; dataSource 字段.</span><br><span class="line">      final Environment environment &#x3D; configuration.getEnvironment();</span><br><span class="line">&#x2F;&#x2F; 根据    environment 来获取 TransactionFactory,也就是MyBatis的事务工厂.</span><br><span class="line">&#x2F;&#x2F; debug 是可以看到  environment 中是有一个JdbcTransactionFactory的,</span><br><span class="line">&#x2F;&#x2F; 如果没用的话,就会自己new一个 ManagedTransactionFactory 来.        </span><br><span class="line">      final TransactionFactory transactionFactory &#x3D; getTransactionFactoryFromEnvironment(environment);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在 JdbcTransactionFactory 中new出了一个 JdbcTransaction</span><br><span class="line">&#x2F;&#x2F; 也就是new了一个JDBC事务.</span><br><span class="line">&#x2F;&#x2F; org.apache.ibatis.transaction.jdbc.JdbcTransaction,</span><br><span class="line">&#x2F;&#x2F; 可以看到 JdbcTransaction 中有commit &#x2F; rollback的方法,</span><br><span class="line">&#x2F;&#x2F; 也就是说这个地方就是对事务进行操作的地方        </span><br><span class="line">      tx &#x3D; transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">&#x2F;&#x2F; 这里是获取是执行器,</span><br><span class="line">&#x2F;&#x2F; 具体代码: org.apache.ibatis.session.Configuration#newExecutor(org.apache.ibatis.transaction.Transaction, org.apache.ibatis.session.ExecutorType)</span><br><span class="line">&#x2F;&#x2F; 这里有 SIMPLE, REUSE, BATCH ,CachingExecutor 还可以在 plugin 中自己定义.</span><br><span class="line">&#x2F;&#x2F;executor &#x3D; (Executor) interceptorChain.pluginAll(executor); 从这行代码可以看到,</span><br><span class="line">&#x2F;&#x2F; 其实还是可以自己扩展的.        </span><br><span class="line">&#x2F;&#x2F;org.apache.ibatis.plugin.InterceptorChain        </span><br><span class="line">      final Executor executor &#x3D; configuration.newExecutor(tx, execType);</span><br><span class="line">&#x2F;&#x2F; 最后 new 出了一个默认的 SqlSession 会话.</span><br><span class="line">&#x2F;&#x2F; 该会话中存有 configuration &#x2F; executor 等核心东西.        </span><br><span class="line">      return new DefaultSqlSession(configuration, executor, autoCommit);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      closeTransaction(tx); &#x2F;&#x2F; may have fetched a connection so lets call close()</span><br><span class="line">      throw ExceptionFactory.wrapException(&quot;Error opening session.  Cause: &quot; + e, e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">&#x2F;&#x2F; 最后还是不忘记对使用过的ThreadLocal 进行remove 操作.        </span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>至此, 可以看到 MyBatis 从SqlSessionFactory中获取出来SqlSession会话, 也可以理解为几个步骤.</p>
<p>首先获取事务工厂, 然后再从事务工厂中获取一个事务来, JdbcTransaction 有兴趣的同学可以看下这个类,里面也是封装了写 commit / rollback等方法. 再接着获取出 执行器(Executor),这里从代码哪里看,执行器还是有几种类型的,也执行自定义. 最后new了一个 DefaultSqlSession 回去.</p>
<p><strong>session.getMapper(BlogMapper.class);</strong></p>
<p>接着看,上一步返回的session,是怎么获取到我们写的Mapper接口文件(Mapper这种文件,在解析配置文件的时候,其实就已经解析到MyBatis的configuration里面去了).</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) &#123;</span><br><span class="line"> &#x2F;&#x2F; knownMappers  中 key 是我们定义接口的Class,value是MapperProxyFactory,</span><br><span class="line">&#x2F;&#x2F; MapperProxyFactory中的mapperInterface中存放了我们的接口class    </span><br><span class="line">  final MapperProxyFactory&lt;T&gt; mapperProxyFactory &#x3D; (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F; 如果获取出来的是null,那么MyBatis就认为你传入进来的接口是不存在的,就会抛出异常来.    </span><br><span class="line">  if (mapperProxyFactory &#x3D;&#x3D; null) &#123;</span><br><span class="line">    throw new BindingException(&quot;Type &quot; + type + &quot; is not known to the MapperRegistry.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  try &#123;</span><br><span class="line">&#x2F;&#x2F; 满足条件的话,调用newInstance方法,从方法名字上看,是创建一个instance的实例.      </span><br><span class="line">    return mapperProxyFactory.newInstance(sqlSession);</span><br><span class="line">  &#125; catch (Exception e) &#123;</span><br><span class="line">    throw new BindingException(&quot;Error getting mapper instance. Cause: &quot; + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line">&#x2F;&#x2F; mapperProxyFactory.newInstance(sqlSession) 代码</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">  public T newInstance(SqlSession sqlSession) &#123;</span><br><span class="line">    &#x2F;&#x2F; new 了一个 MapperProxy对象.</span><br><span class="line">    final MapperProxy&lt;T&gt; mapperProxy &#x3D; new MapperProxy&lt;&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">    return newInstance(mapperProxy);</span><br><span class="line">  &#125;    </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 最后可以看到使用 Proxy.newProxyInstance方法来创建的一个对象.</span><br><span class="line">  @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">  protected T newInstance(MapperProxy&lt;T&gt; mapperProxy) &#123;</span><br><span class="line">    return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-------</span><br><span class="line">&#x2F;&#x2F; 如果你是debug模式的话,那么你可以看到BlogMapper的对象地址池在 debug 中显示的值.</span><br><span class="line">&#x2F;&#x2F; org.apache.ibatis.binding.MapperProxy@ef9296d    </span><br><span class="line">BlogMapper blogMapper &#x3D; session.getMapper(BlogMapper.class);</span><br></pre></td></tr></table></figure>

<p>从SqlSession 中获取 BlogMapper我们写的mapper流程, 先从 knownMappers 中根据key获取出来之前加载配置已经加载完毕的信息,如果没用的话,就会抛出没有的异常. 最后使用 Proxy.newProxyIntsance来生成的一个类似接口实现类的代码,不同的是, 在 new MapperProxy 的时候,就已经将接下来需要的信息全部传入进去.</p>
<p><strong>blogMapper.selectBlog(1) 方法</strong></p>
<p>竟然 BlogMapper是通过Proxy.newInstance获取出来的,那它是怎么查询的数据库? 又是怎么将字段给映射到 Object一一对应的呢 ?</p>
<p> debug会走到 MapperProxy的invoke方法来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    if (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">      return method.invoke(this, args);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return cachedInvoker(method).invoke(proxy, method, args, sqlSession);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; catch (Throwable t) &#123;</span><br><span class="line">    throw ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------------</span><br><span class="line">&#x2F;&#x2F; 通过 invoke 方法, 走 mapperMethod的execute方法,来到了这里.</span><br><span class="line">&#x2F;&#x2F; switch 有 INSERT&#x2F;UPDATE&#x2F;DELETE&#x2F;SELECT&#x2F;FLUSH,如果这几种没有匹配到的话,就会抛出异常来.    </span><br><span class="line">  public Object execute(SqlSession sqlSession, Object[] args) &#123;</span><br><span class="line">    Object result;</span><br><span class="line">    switch (command.getType()) &#123;</span><br><span class="line">            </span><br><span class="line">&#x2F;&#x2F; 不难看到 INSERT&#x2F;UPDATE&#x2F;DELETE都是先调用 convertArgsToSqlCommandParam 方法,</span><br><span class="line">&#x2F;&#x2F; 也就是先将参数转化为sql,然后将执行的结果 赋值 给 result 参数.            </span><br><span class="line">      case INSERT: &#123;</span><br><span class="line">        Object param &#x3D; method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result &#x3D; rowCountResult(sqlSession.insert(command.getName(), param));</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">      case UPDATE: &#123;</span><br><span class="line">        Object param &#x3D; method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result &#x3D; rowCountResult(sqlSession.update(command.getName(), param));</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">      case DELETE: &#123;</span><br><span class="line">        Object param &#x3D; method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result &#x3D; rowCountResult(sqlSession.delete(command.getName(), param));</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">&#x2F;&#x2F; 如果是 select 语句,可以根据返回值来分类,如果是void&amp;&amp;method.hasResultHandler,就会返回null</span><br><span class="line">&#x2F;&#x2F; 多个 &#x2F; Map类型  &#x2F;    Cursor 类型   &#x2F;  最后查询一个        </span><br><span class="line">      case SELECT:</span><br><span class="line">        if (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;</span><br><span class="line">          executeWithResultHandler(sqlSession, args);</span><br><span class="line">          result &#x3D; null;</span><br><span class="line">        &#125; else if (method.returnsMany()) &#123;</span><br><span class="line">          result &#x3D; executeForMany(sqlSession, args);</span><br><span class="line">        &#125; else if (method.returnsMap()) &#123;</span><br><span class="line">          result &#x3D; executeForMap(sqlSession, args);</span><br><span class="line">        &#125; else if (method.returnsCursor()) &#123;</span><br><span class="line">          result &#x3D; executeForCursor(sqlSession, args);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          Object param &#x3D; method.convertArgsToSqlCommandParam(args);</span><br><span class="line">          result &#x3D; sqlSession.selectOne(command.getName(), param);</span><br><span class="line">          if (method.returnsOptional()</span><br><span class="line">              &amp;&amp; (result &#x3D;&#x3D; null || !method.getReturnType().equals(result.getClass()))) &#123;</span><br><span class="line">            result &#x3D; Optional.ofNullable(result);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line"> &#x2F;&#x2F; 刷新会话.           </span><br><span class="line">      case FLUSH:</span><br><span class="line">        result &#x3D; sqlSession.flushStatements();</span><br><span class="line">        break;</span><br><span class="line">      default:</span><br><span class="line">        throw new BindingException(&quot;Unknown execution method for: &quot; + command.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F; 如果result 是 null, 方法返回的修饰符是private并且 返回值不是void的话,就会抛出异常.    </span><br><span class="line">    if (result &#x3D;&#x3D; null &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123;</span><br><span class="line">      throw new BindingException(&quot;Mapper method &#39;&quot; + command.getName()</span><br><span class="line">          + &quot; attempted to return null from a method with a primitive return type (&quot; + method.getReturnType() + &quot;).&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看到,先是对 INSERT / UPDATE / DELETE / SELECT 进行分类处理, 然后对再分别根据不同的类型进行处理. 都是先有转化为sql,然后将执行结果赋值给result.</p>
<p>至于里面详细的查询执行sql,还有动态sql,每次会话缓存等,后面看到详细的情况再一一说明. 这里只是对MyBatis的基本工作进行了一个梳理. 然后后面再根据基础梳理,再来挨个击碎他们.</p>
<p>至此, MyBatis的入门分析流程是结束的. 理解起来,应该还不是那么难.</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>根据 com.iyang.mybatis.InitHelloMyBatis , 也就是入门的demo来梳理下流程.</p>
<ol>
<li>读取配置文件,也就是将配置文件读取,转化为inptStream流.</li>
<li>利用 SqlSessionFactoryBuilder 来 解析流, 起内部又利用 BaseBuilder(其又很多实现类,这里用的XMLConfigBuilder)也解析xml配置文件. Configuration configuration 该类中是保存着xml配置文件的很多信息. 然后 DefaultSqlSessionFactory 中有configuration字段,也就是属性.</li>
<li>然后从 DefaultSqlSessionFactory 中获取 SqlSession来, 并且也会是否开启事务(参考:org.apache.ibatis.transaction.jdbc.JdbcTransaction)类,然后获取 Executor,Executor也是有几种种类的,也可以自己自定义,最后返回一个 DefaultSqlSession 来.</li>
<li>然后从 SqlSession 中获取我们的接口Mapper, 最后也是利用 Proxy.newProxyInstance 来生成的接口,也就是代理(这里打印出地址池或者debug看地址池,就会很明显的看到是代理对象).</li>
<li>最后走查询的方法, 也就是走到了 MapperProxy 来. 可以看到MapperProxy里面是有sqlSession的,而SqlSession是有 Executor/configuration/autoCommit等信息的, 有了sqlSession,就剩下执行sql和映射sql查询出来的结果来了(这里是 mapperMethod.execute(sqlSession, args) —&gt; org.apache.ibatis.binding.MapperMethod#execute 走到这里来了,这里之后就会分类进行处理,然后映射sql语句).</li>
<li>至此,一个 MyBatis 的 HelloWorld分析流程是完毕的.</li>
</ol>
]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>Java源码</tag>
      </tags>
  </entry>
  <entry>
    <title>spring_refresh_work_flow</title>
    <url>/2020/12/29/spring/spring-refresh-work-flow/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>  这里是相对上一次再次的阅读和记录,比上次有了更深入的理解.</p>
<p>   这里是再次整理的阅读 Spring 的源码, 相对比上次的阅读，我希望这次可以更清晰&amp;更深刻的理解Spring,也不仅仅会从一个案例来进行分析，会结合多方面的知识来进行整理分析.</p>
<p>​    这里放上之前阅读的比例 :    <a href="https://github.com/baoyang23/source-notes/tree/master/java/spring_bean" target="_blank" rel="noopener">https://github.com/baoyang23/source-notes/tree/master/java/spring_bean</a></p>
<p>​    该目录下面有 :  bean/get/extend  三个主要地方的分析. </p>
<p>​    此模块还是讲述 整体的 flow,后面会对单个进行分析&amp;Spring提供怎么样的扩展方式来进行增强扩展等.</p>
<p> 案例入门操作的话,可以参考之前的博客.</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>​    这里我们先不忙这其他类型的bean分析, 就对我们作为 config 的 bean 进行分析. 先单个分析容易理解些.</p>
<p>​    入口类 : </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitWorkFlowSpring</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        AnnotationConfigApplicationContext context =</span><br><span class="line">                <span class="keyword">new</span> AnnotationConfigApplicationContext(YangBeanScannerConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        YangBeanScannerConfig yangBeanScannerConfig = context.getBean(YangBeanScannerConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        yangBeanScannerConfig.say();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>​    配置类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span>(basePackages = <span class="string">"com.iyang.spring"</span>)</span><br><span class="line"><span class="meta">@Description</span>(value = <span class="string">"This is GavinYang DemoWorld."</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YangBeanScannerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">YangBeanScannerConfig</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"配置扫描初始化打印"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是从Spring容器中获取出来的"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，当我们启动 main 方法的时候，是可以看到 YangBeanScannerConfig 中构造函数打印的内容和调用say方法打印出来的内容.</p>
<p>基于这个基础上,我们debug一层一层的走进去看,Spring做了什么事情.</p>
<p>先进入到我们new出来的AnnotationConfigApplicationContext中来</p>
<p>调用自身的无参构造函数</p>
<p>调用 register 注册方法</p>
<p>最后调用一个 refresh, refresh 方法中是做了很多事的.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>();</span><br><span class="line">   register(componentClasses);</span><br><span class="line">   refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么有了入口，我们就根据这些方法来一个一个的分析.</p>
<h4 id="this-方法-—-gt-org-springframework-context-annotation-AnnotationConfigApplicationContext-AnnotationConfigApplicationContext"><a href="#this-方法-—-gt-org-springframework-context-annotation-AnnotationConfigApplicationContext-AnnotationConfigApplicationContext" class="headerlink" title="this() 方法 —&gt;  org.springframework.context.annotation.AnnotationConfigApplicationContext#AnnotationConfigApplicationContext()"></a>this() 方法 —&gt;  org.springframework.context.annotation.AnnotationConfigApplicationContext#AnnotationConfigApplicationContext()</h4><p>先来看 this 方法做了什么事情.</p>
<p>创建了二个对象，分别是 注解bd读取/类路口db扫描.</p>
<p>比如有意思的是,传入this(AnnotationConfigApplicationContext), 然后返回来的reader/scanner又属于this.也是相互之间各自都持有各自的引用.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.reader = <span class="keyword">new</span> AnnotatedBeanDefinitionReader(<span class="keyword">this</span>);</span><br><span class="line">   <span class="keyword">this</span>.scanner = <span class="keyword">new</span> ClassPathBeanDefinitionScanner(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="new-AnnotatedBeanDefinitionReader"><a href="#new-AnnotatedBeanDefinitionReader" class="headerlink" title="new AnnotatedBeanDefinitionReader"></a>new AnnotatedBeanDefinitionReader</h5><p>来，看下new一个对象做了什么事情.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotatedBeanDefinitionReader</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 这里的 getOrCreateEnvironment 方法中,AnnotationConfigApplicationContext是EnvironmentCapable的子类,</span></span><br><span class="line"><span class="comment">// 所以Environment也是从AnnotationConfigApplicationContext中获取出来的.    </span></span><br><span class="line">   <span class="keyword">this</span>(registry, getOrCreateEnvironment(registry));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--------------</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotatedBeanDefinitionReader</span><span class="params">(BeanDefinitionRegistry registry, Environment environment)</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 检验 registry/environment都不能为null.   </span></span><br><span class="line">		Assert.notNull(registry, <span class="string">"BeanDefinitionRegistry must not be null"</span>);</span><br><span class="line">		Assert.notNull(environment, <span class="string">"Environment must not be null"</span>);</span><br><span class="line">		<span class="keyword">this</span>.registry = registry;</span><br><span class="line"><span class="comment">// 这里将 registry/environment 给传入构造到 org.springframework.context.annotation.ConditionEvaluator 中来.</span></span><br><span class="line"><span class="comment">// ConditionEvaluator又借助org.springframework.context.annotation.ConditionEvaluator.ConditionContextImpl#ConditionContextImpl 来存储这些信息,所以这里最后的信息是在ConditionContextImpl中来了.    </span></span><br><span class="line">		<span class="keyword">this</span>.conditionEvaluator = <span class="keyword">new</span> ConditionEvaluator(registry, environment, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// org.springframework.context.annotation.AnnotationConfigUtils#registerAnnotationConfigProcessors(org.springframework.beans.factory.support.BeanDefinitionRegistry, java.lang.Object)</span></span><br><span class="line"><span class="comment">// 从该方法的名字上看,是对注册注解配置进行处理.    </span></span><br><span class="line">		AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="keyword">this</span>.registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="org-springframework-context-annotation-AnnotationConfigUtils-registerAnnotationConfigProcessors-org-springframework-beans-factory-support-BeanDefinitionRegistry-java-lang-Object-分析"><a href="#org-springframework-context-annotation-AnnotationConfigUtils-registerAnnotationConfigProcessors-org-springframework-beans-factory-support-BeanDefinitionRegistry-java-lang-Object-分析" class="headerlink" title="org.springframework.context.annotation.AnnotationConfigUtils#registerAnnotationConfigProcessors(org.springframework.beans.factory.support.BeanDefinitionRegistry, java.lang.Object) 分析"></a>org.springframework.context.annotation.AnnotationConfigUtils#registerAnnotationConfigProcessors(org.springframework.beans.factory.support.BeanDefinitionRegistry, java.lang.Object) 分析</h6><p>这里根据我们的案列，传入进来的source是null.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">registerAnnotationConfigProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      BeanDefinitionRegistry registry, @Nullable Object source)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 根据 registry 的类型来获取 DefaultListableBeanFactory.</span></span><br><span class="line"><span class="comment">// 这里的registry属于GenericApplicationContext,调用其getDefaultListableBeanFactory来获取.    </span></span><br><span class="line">   DefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);</span><br><span class="line">   <span class="keyword">if</span> (beanFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// beanFactory.getDependencyComparator() 返回的是null,满足条件.       </span></span><br><span class="line">      <span class="keyword">if</span> (!(beanFactory.getDependencyComparator() <span class="keyword">instanceof</span> AnnotationAwareOrderComparator)) &#123;</span><br><span class="line"><span class="comment">// 设置 AnnotationAwareOrderComparator 到beanFactory中来          </span></span><br><span class="line">         beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// get方法获取出来的是SimpleAutowireCandidateResolver,       </span></span><br><span class="line">      <span class="keyword">if</span> (!(beanFactory.getAutowireCandidateResolver() <span class="keyword">instanceof</span> ContextAnnotationAutowireCandidateResolver)) &#123;</span><br><span class="line"><span class="comment">// 设置ContextAnnotationAutowireCandidateResolver到beanFactory中来.          </span></span><br><span class="line">         beanFactory.setAutowireCandidateResolver(<span class="keyword">new</span> ContextAnnotationAutowireCandidateResolver());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Set&lt;BeanDefinitionHolder&gt; beanDefs = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以看到每个都有 internal 来特意表明内部的意思.    </span></span><br><span class="line"><span class="comment">// org.springframework.context.annotation.internalConfigurationAnnotationProcessor ---&gt;  ConfigurationClassPostProcessor</span></span><br><span class="line"><span class="comment">// org.springframework.context.annotation.internalAutowiredAnnotationProcessor  --&gt; AutowiredAnnotationBeanPostProcessor</span></span><br><span class="line"><span class="comment">// org.springframework.context.annotation.internalCommonAnnotationProcessor   ---&gt; CommonAnnotationBeanPostProcessor </span></span><br><span class="line"><span class="comment">// org.springframework.context.annotation.internalPersistenceAnnotationProcessor  ---&gt; PersistenceAnnotationBeanPostProcessor</span></span><br><span class="line"><span class="comment">// org.springframework.context.event.internalEventListenerProcessor   ---&gt; EventListenerMethodProcessor</span></span><br><span class="line"><span class="comment">// org.springframework.context.event.internalEventListenerFactory  --- &gt; DefaultEventListenerFactory</span></span><br><span class="line">   <span class="keyword">if</span> (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">      RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(ConfigurationClassPostProcessor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      def.setSource(source);</span><br><span class="line">      beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">      RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(AutowiredAnnotationBeanPostProcessor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      def.setSource(source);</span><br><span class="line">      beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Check for JSR-250 support, and if present add the CommonAnnotationBeanPostProcessor.</span></span><br><span class="line">   <span class="keyword">if</span> (jsr250Present &amp;&amp; !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">      RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(CommonAnnotationBeanPostProcessor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      def.setSource(source);</span><br><span class="line">      beanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor.</span></span><br><span class="line">   <span class="keyword">if</span> (jpaPresent &amp;&amp; !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">      RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         def.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME,</span><br><span class="line">               AnnotationConfigUtils<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()))</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">               <span class="string">"Cannot load optional framework class: "</span> + PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      def.setSource(source);</span><br><span class="line">      beanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">      RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(EventListenerMethodProcessor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      def.setSource(source);</span><br><span class="line">      beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) &#123;</span><br><span class="line">      RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(DefaultEventListenerFactory<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      def.setSource(source);</span><br><span class="line">      beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> beanDefs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里都是先判断这些内部的bean,是不是已经在 registry 中已经存在了,如果没有存在的话，就会利用类信息来构造出一个RootBeanDefinition来,接着就是调用 registerPostProcessor 方法给注册到 registry  中来.</p>
<p>最后返回一个注册过的 bean 的 Set 集合回去.</p>
<p>总结下这里就是为了给spring容器中注册一些内部的 bean 进去. 这些注册进去的bean,都是在后面初始化bean&amp;解析bean等情况有使用到的.</p>
<h5 id="new-ClassPathBeanDefinitionScanner-方法"><a href="#new-ClassPathBeanDefinitionScanner-方法" class="headerlink" title="new ClassPathBeanDefinitionScanner() 方法"></a>new ClassPathBeanDefinitionScanner() 方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathBeanDefinitionScanner</span><span class="params">(BeanDefinitionRegistry registry, <span class="keyword">boolean</span> useDefaultFilters)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>(registry, useDefaultFilters, getOrCreateEnvironment(registry));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------</span><br><span class="line"><span class="comment">// 最后走到 org.springframework.context.annotation.ClassPathBeanDefinitionScanner#ClassPathBeanDefinitionScanner(org.springframework.beans.factory.support.BeanDefinitionRegistry, boolean, org.springframework.core.env.Environment, org.springframework.core.io.ResourceLoader) 构造函数来.    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathBeanDefinitionScanner</span><span class="params">(BeanDefinitionRegistry registry, <span class="keyword">boolean</span> useDefaultFilters,</span></span></span><br><span class="line"><span class="function"><span class="params">			Environment environment, @Nullable ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		Assert.notNull(registry, <span class="string">"BeanDefinitionRegistry must not be null"</span>);</span><br><span class="line"><span class="comment">// 赋值 registry 来.    </span></span><br><span class="line">		<span class="keyword">this</span>.registry = registry;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (useDefaultFilters) &#123;</span><br><span class="line"><span class="comment">// 添加 filter 到 includeFilters 中来.</span></span><br><span class="line"><span class="comment">// AnnotationTypeFilter(Component.class)</span></span><br><span class="line"><span class="comment">// AnnotationTypeFilter(((Class&lt;? extends Annotation&gt;) ClassUtils.forName("javax.annotation.ManagedBean", cl)     </span></span><br><span class="line"><span class="comment">// 等信息进来      </span></span><br><span class="line">			registerDefaultFilters();</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">// org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#setEnvironment</span></span><br><span class="line"><span class="comment">// 设置 enviornment到父类中来.    </span></span><br><span class="line">		setEnvironment(environment);</span><br><span class="line"><span class="comment">// 这里也是这是到父类来了.</span></span><br><span class="line"><span class="comment">// 返回的resourcePatternResolver是AnnotationConfigApplicationContext.</span></span><br><span class="line"><span class="comment">// metadataReaderFactory 是 CachingMetadataReaderFactory 对象来.</span></span><br><span class="line"><span class="comment">// componentsIndex 是 null.    </span></span><br><span class="line">		setResourceLoader(resourceLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法可以看到,添加了三个 filter 到 includeFilters 中来.</p>
<p>设置environment / resource 到 其父类org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider 中来.</p>
<p>也就是setXXX方法是调用的父类.</p>
<h4 id="register-componentClasses-方法"><a href="#register-componentClasses-方法" class="headerlink" title="register(componentClasses)  方法"></a>register(componentClasses)  方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//  检验传入进来的 comonpentClasses是一定要有值的. </span></span><br><span class="line">   Assert.notEmpty(componentClasses, <span class="string">"At least one component class must be specified"</span>);</span><br><span class="line">   <span class="keyword">this</span>.reader.register(componentClasses);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-------------------------</span><br><span class="line"><span class="comment">// 这里从名字上就可以很容易看出是注册 bean 的    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (Class&lt;?&gt; componentClass : componentClasses) &#123;</span><br><span class="line">			registerBean(componentClass);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">-----------------------------</span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">doRegisterBean</span><span class="params">(Class&lt;T&gt; beanClass, @Nullable String name,</span></span></span><br><span class="line"><span class="function"><span class="params">			@Nullable Class&lt;? extends Annotation&gt;[] qualifiers, @Nullable Supplier&lt;T&gt; supplier,</span></span></span><br><span class="line"><span class="function"><span class="params">			@Nullable BeanDefinitionCustomizer[] customizers)</span> </span>&#123;</span><br><span class="line"><span class="comment">// new 一个 bd 出来.</span></span><br><span class="line">		AnnotatedGenericBeanDefinition abd = <span class="keyword">new</span> AnnotatedGenericBeanDefinition(beanClass);</span><br><span class="line"><span class="comment">// 这里没有 @Conditional 注解和 metadata 是 null 就会直接返回 false 来.    </span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.conditionEvaluator.shouldSkip(abd.getMetadata())) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		abd.setInstanceSupplier(supplier);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 在对象上获取 @Scope 注解,这里没有,所以就不会往下走.</span></span><br><span class="line"><span class="comment">// 这里返回的 ScopeMetadata应该是默认的,scopeName是singleton,scopedProxyMode是No/1    </span></span><br><span class="line">		ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(abd);</span><br><span class="line">		abd.setScope(scopeMetadata.getScopeName());</span><br><span class="line"><span class="comment">// 获取 beanName 来    </span></span><br><span class="line">		String beanName = (name != <span class="keyword">null</span> ? name : <span class="keyword">this</span>.beanNameGenerator.generateBeanName(abd, <span class="keyword">this</span>.registry));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对一些注解的处理.</span></span><br><span class="line"><span class="comment">// @Lazy , @Primary , @DependsOn , @Role , @Description 如果有这些注解的话,就会进行处理.</span></span><br><span class="line"><span class="comment">// 根据注解的名字,来调用相应的set方法.    </span></span><br><span class="line">		AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);</span><br><span class="line">    </span><br><span class="line"> <span class="comment">// 这里是对是否有 @Primary / @Lazy /   @Qualifier 注解进行判断.</span></span><br><span class="line">		<span class="keyword">if</span> (qualifiers != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (Class&lt;? extends Annotation&gt; qualifier : qualifiers) &#123;</span><br><span class="line">				<span class="keyword">if</span> (Primary<span class="class">.<span class="keyword">class</span> </span>== qualifier) &#123;</span><br><span class="line">					abd.setPrimary(<span class="keyword">true</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (Lazy<span class="class">.<span class="keyword">class</span> </span>== qualifier) &#123;</span><br><span class="line">					abd.setLazyInit(<span class="keyword">true</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					abd.addQualifier(<span class="keyword">new</span> AutowireCandidateQualifier(qualifier));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//这里 BeanDefinitionCustomizer[] customizers 数组如果有值的话,</span></span><br><span class="line"><span class="comment">// 会调用 customizer 的 customize 方法传入 bd.</span></span><br><span class="line"><span class="comment">// TODO , 这里由于没有具体的值,也不是很清楚做了什么事情.    </span></span><br><span class="line">		<span class="keyword">if</span> (customizers != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (BeanDefinitionCustomizer customizer : customizers) &#123;</span><br><span class="line">				customizer.customize(abd);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 bd 和 bean的名字，创建出一个 bd 的持有者.    </span></span><br><span class="line">		BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(abd, beanName);</span><br><span class="line"><span class="comment">// 这里由于传入进来的 scopeMetadata的值是NO,所以就直接返回bdHolder的持有者了.</span></span><br><span class="line"><span class="comment">// 可以看到返回下面的代码,是满足一个增强类的概念的.    </span></span><br><span class="line">		definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry); </span><br><span class="line"><span class="comment">// org.springframework.beans.factory.support.DefaultListableBeanFactory#registerBeanDefinition</span></span><br><span class="line"><span class="comment">//走到beanFactory中的registerBeanDefinition方法来,先是对bd进行校验,然后利用org.springframework.beans.factory.support.DefaultListableBeanFactory#beanDefinitionMap+beaName来判断是不是已经包含了该bean</span></span><br><span class="line"><span class="comment">// 此时如果你是debug的话,你会发现有五个内置的bean已经在该beanDefinitionMap中了.这也是对应了AnnotatedBeanDefinitionReader中处理的内置的bean.</span></span><br><span class="line"><span class="comment">//如果beanDefinitionMap中没有的话,就分为是不是已经开始创建bean了.</span></span><br><span class="line"><span class="comment">//如果没有已经开始创建了,就添加到beanDefinitionMap中来,beanName也会添加到beanDefinitionNames,其实这里有个问题, beanDefinitionMap的key集合就已经是beanName集合了,为什么还单独使用一个集合来维护呢？</span></span><br><span class="line"><span class="comment">// 这样这个bean的信息和bd就放入到 BeanFactory中来了.    </span></span><br><span class="line"><span class="comment">// 如果有别名的注解或者配置的话,就会走到registry.registerAlias(beanName, alias);来进行别名的注册. </span></span><br><span class="line">		BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p>这里可以总结下看到 register 方法就是对我们的配置类进行扫描, 然后对是否有一些注解进行判断等. 最后使用 BeanDefinitionReaderUtils 工具类的方法将 bd 给 注册到 Spring 容器中来, 注意这时候是没有实例化我们的 YangBeanScannerConfig,只是封装成 bd  + beanName 给注册到 BeanFactory 的 beanDefinitionMap 中来了.</p>
<h4 id="refresh-方法"><a href="#refresh-方法" class="headerlink" title="refresh() 方法"></a>refresh() 方法</h4><p>​    更新方法，可以看到这个方法内部是走了很多方法,其逻辑也是比较绕的. 不过没事，我们一个一个方法的来看.</p>
<p> org.springframework.context.support.AbstractApplicationContext#refresh() </p>
<p>可以看到其内部的每个方法上面都是有一行注释的.  </p>
<p>于是我们挨个方法来debug进来分析.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 利用 Object 来当锁对象,避免多个线程同时调用到 refresh 方法来.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object startupShutdownMonitor = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">      <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">  </span><br><span class="line">      prepareRefresh();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">      prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">         postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">         invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">         registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">         initMessageSource();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">         initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">         onRefresh();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">         registerListeners();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">         finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">         finishRefresh();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line">                  <span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">         destroyBeans();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Reset 'active' flag.</span></span><br><span class="line">         cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">// Reset common introspection caches in Spring's core, since we</span></span><br><span class="line">         <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">         resetCommonCaches();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="prepareRefresh-方法"><a href="#prepareRefresh-方法" class="headerlink" title="prepareRefresh() 方法"></a>prepareRefresh() 方法</h5><p>从注释来看, 设置startup数据 &amp; 标识active来表示状态,同时也会初始化一些资源.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Prepare this context for refreshing, setting its startup date and</span></span><br><span class="line"><span class="comment"> * active flag as well as performing any initialization of property sources.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// Switch to active.</span></span><br><span class="line">   <span class="keyword">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line"><span class="comment">// 对状态标识的设置.    </span></span><br><span class="line">   <span class="keyword">this</span>.closed.set(<span class="keyword">false</span>);</span><br><span class="line">   <span class="keyword">this</span>.active.set(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(<span class="string">"Refreshing "</span> + <span class="keyword">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         logger.debug(<span class="string">"Refreshing "</span> + getDisplayName());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Initialize any placeholder property sources in the context environment.</span></span><br><span class="line"><span class="comment">// 这里暂时没有实现来做事情.    </span></span><br><span class="line">   initPropertySources();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Validate that all properties marked as required are resolvable:</span></span><br><span class="line">   <span class="comment">// see ConfigurablePropertyResolver#setRequiredProperties</span></span><br><span class="line"><span class="comment">// org.springframework.core.env.AbstractEnvironment#validateRequiredProperties</span></span><br><span class="line"><span class="comment">// 对 org.springframework.core.env.AbstractPropertyResolver#requiredProperties 进行检验,如果检验到有问题的话,就会抛出异常来.</span></span><br><span class="line"><span class="comment">// 这里是对 properties 进行检验.    </span></span><br><span class="line">   getEnvironment().validateRequiredProperties();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Store pre-refresh ApplicationListeners...</span></span><br><span class="line"><span class="comment">// earlyApplicationListeners是null的话,利用applicationListeners来初始化.   </span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.earlyApplicationListeners == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.earlyApplicationListeners = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="keyword">this</span>.applicationListeners);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 如果已经存在值了,就对  applicationListeners 清空，然后全部添加applicationListeners来.     </span></span><br><span class="line">      <span class="comment">// Reset local application listeners to pre-refresh state.</span></span><br><span class="line">      <span class="keyword">this</span>.applicationListeners.clear();</span><br><span class="line">      <span class="keyword">this</span>.applicationListeners.addAll(<span class="keyword">this</span>.earlyApplicationListeners);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Allow for the collection of early ApplicationEvents,</span></span><br><span class="line">   <span class="comment">// to be published once the multicaster is available...</span></span><br><span class="line">   <span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到该方法的话,对状态标识进行设置.  接着地 propertySources 资源来进行初始化, 于是就对property来进行检验.   接下来是对 earlyApplicationListeners/earlyApplicationEvents根据条件来初始化操作.</p>
<h5 id="obtainFreshBeanFactroy"><a href="#obtainFreshBeanFactroy" class="headerlink" title="obtainFreshBeanFactroy()"></a>obtainFreshBeanFactroy()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   refreshBeanFactory();</span><br><span class="line">   <span class="keyword">return</span> getBeanFactory();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---------------------------</span><br><span class="line">org.springframework.context.support.GenericApplicationContext#refreshBeanFactory</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 看到 compareAndSet 有点cas 的味道.    </span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException </span>&#123;    </span><br><span class="line">		<span class="keyword">if</span> (!<span class="keyword">this</span>.refreshed.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">					<span class="string">"GenericApplicationContext does not support multiple refresh attempts: just call 'refresh' once"</span>);</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">// private String id = ObjectUtils.identityToString(this);</span></span><br><span class="line"><span class="comment">// 这里获取出来的id在这个类被new或者子类调用父类的super()构造方法的时候,就已经被初始化值了的.    </span></span><br><span class="line">		<span class="keyword">this</span>.beanFactory.setSerializationId(getId());</span><br><span class="line">	&#125;    </span><br><span class="line">    </span><br><span class="line">-----------------</span><br><span class="line">org.springframework.context.support.GenericApplicationContext#getBeanFactory</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里就直接返回了 DefaultListableBeanFactory.   </span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ConfigurableListableBeanFactory <span class="title">getBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.beanFactory;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>该方法 设置了一个 SerializationId 到 beanFactory 中来. 最后也是返回了一个 DefaultListableBeanFactory 来.</p>
<h5 id="prepareBeanFactory-方法"><a href="#prepareBeanFactory-方法" class="headerlink" title="prepareBeanFactory() 方法"></a>prepareBeanFactory() 方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Configure the factory's standard context characteristics,</span></span><br><span class="line"><span class="comment"> * such as the context's ClassLoader and post-processors.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanFactory the BeanFactory to configure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// Tell the internal bean factory to use the context's class loader etc.</span></span><br><span class="line"><span class="comment">// org.springframework.core.io.DefaultResourceLoader#getClassLoader   </span></span><br><span class="line"><span class="comment">// 设置 class 加载器&amp;赋值进去.    </span></span><br><span class="line">   beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line"><span class="comment">// 将 beanClassLoader放入SpelParserConfiguration中来,SpelExpressionParser中有含有SpelParserConfiguration作为configuration,StandardBeanExpressionResolver属性又含有SpelExpressionParser. 这也就可以理解为beanClassLoader最后是放入到SpelParserConfiguration来.</span></span><br><span class="line">   beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 传入applicationContext和environment到ResourceEditorRegistrar对象来.</span></span><br><span class="line"><span class="comment">//然后添加到beanFactory中来.    </span></span><br><span class="line">   beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> ResourceEditorRegistrar(<span class="keyword">this</span>, getEnvironment()));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Configure the bean factory with context callbacks.</span></span><br><span class="line"><span class="comment">// 添加ApplicationContextAwareProcessor后置处理器到org.springframework.beans.factory.support.AbstractBeanFactory#beanPostProcessors中来.</span></span><br><span class="line"><span class="comment">// 在添加后置处理器到Spring容器之前,会判断这个后置处理起是不是InstantiationAwareBeanPostProcessor/DestructionAwareBeanPostProcessor 这二种情况.</span></span><br><span class="line"><span class="comment">// 最后添加到 beanPostProcessors 中来.    </span></span><br><span class="line">   beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</span><br><span class="line"><span class="comment">// 然后这里忽略了六种情况的接口. 为什么要忽略呢? 看一个地方.</span></span><br><span class="line"><span class="comment">// org.springframework.context.support.ApplicationContextAwareProcessor#postProcessBeforeInitialization &amp;  org.springframework.context.support.ApplicationContextAwareProcessor#invokeAwareInterfaces 结合这二个方法来看,是已经对这六种情况的接口做了处理的.    </span></span><br><span class="line">   beanFactory.ignoreDependencyInterface(EnvironmentAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ResourceLoaderAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   beanFactory.ignoreDependencyInterface(MessageSourceAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ApplicationContextAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// BeanFactory interface not registered as resolvable type in a plain factory.</span></span><br><span class="line">   <span class="comment">// MessageSource registered (and found for autowiring) as a bean.</span></span><br><span class="line"><span class="comment">// private final Map&lt;Class&lt;?&gt;, Object&gt; resolvableDependencies = new ConcurrentHashMap&lt;&gt;(16);    </span></span><br><span class="line"><span class="comment">// org.springframework.beans.factory.support.DefaultListableBeanFactory#resolvableDependencies,这里将 BeanFactory.class和beanFactory给添加到 resolvableDependencies中来了,这里可以看到resolvableDependencies的key是一个Class类型.</span></span><br><span class="line">   beanFactory.registerResolvableDependency(BeanFactory<span class="class">.<span class="keyword">class</span>, <span class="title">beanFactory</span>)</span>;</span><br><span class="line">   beanFactory.registerResolvableDependency(ResourceLoader<span class="class">.<span class="keyword">class</span>, <span class="title">this</span>)</span>;</span><br><span class="line">   beanFactory.registerResolvableDependency(ApplicationEventPublisher<span class="class">.<span class="keyword">class</span>, <span class="title">this</span>)</span>;</span><br><span class="line">   beanFactory.registerResolvableDependency(ApplicationContext<span class="class">.<span class="keyword">class</span>, <span class="title">this</span>)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Register early post-processor for detecting inner beans as ApplicationListeners.</span></span><br><span class="line"><span class="comment">// 这里又添加了一个后置处理器.</span></span><br><span class="line"><span class="comment">// 传入一个 ApplicationContext 给后置处理器,然后添加到BeanFactory中来.</span></span><br><span class="line"><span class="comment">// org.springframework.beans.factory.support.AbstractBeanFactory#beanPostProcessors,也即是添加到专门存放 后置处理器的集合中来了.    </span></span><br><span class="line">   beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found.</span></span><br><span class="line"><span class="comment">// beanFactory如果有loadTimeWeaver,那么就添加 LoadTimeWeaverAwareProcessor 后置处理器进来   </span></span><br><span class="line">   <span class="keyword">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">      <span class="comment">// Set a temporary ClassLoader for type matching.</span></span><br><span class="line">      beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Register default environment beans.</span></span><br><span class="line"><span class="comment">// 不包含environment/systemProperties/systemEnvironment，就会添加到org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#singletonObjects中来.    </span></span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看到,prepareBeanFactory 中做了这些事情 :  添加了 beanClassLoader,添加了二个后置处理器,然后注册了四个 BeanFactory/ResourceLoader/ApplicationEventPublisher/ApplicationContext 到DefaultListableBeanFactory#resolvableDependencies中来了.</p>
<p>最后判断beanFactory是不是不包含一些关于环境的bean,如果是的话,那就调用registerSingleton方法给注册进来.</p>
<p>还是可以看到，这里都是在为环境做准备工作.</p>
<h5 id="postProcessBeanFactory-方法"><a href="#postProcessBeanFactory-方法" class="headerlink" title="postProcessBeanFactory() 方法"></a>postProcessBeanFactory() 方法</h5><p>略略略, 该方法暂无实现类来搞事情…..</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Modify the application context's internal bean factory after its standard</span></span><br><span class="line"><span class="comment"> * initialization. All bean definitions will have been loaded, but no beans</span></span><br><span class="line"><span class="comment"> * will have been instantiated yet. This allows for registering special</span></span><br><span class="line"><span class="comment"> * BeanPostProcessors etc in certain ApplicationContext implementations.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanFactory the bean factory used by the application context</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="invokeBeanFactoryPostProcessors-方法"><a href="#invokeBeanFactoryPostProcessors-方法" class="headerlink" title="invokeBeanFactoryPostProcessors 方法"></a>invokeBeanFactoryPostProcessors 方法</h5><p>这些是对beanFactoryPostProcessors进行处理. 是借用了 PostProcessorRegistrationDelegate.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Instantiate and invoke all registered BeanFactoryPostProcessor beans,</span></span><br><span class="line"><span class="comment"> * respecting explicit order if given.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Must be called before singleton instantiation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"><span class="comment">// getBeanFactoryPostProcessors() 获取出来的是空集合.    </span></span><br><span class="line">   PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime</span></span><br><span class="line">   <span class="comment">// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)</span></span><br><span class="line">   <span class="keyword">if</span> (beanFactory.getTempClassLoader() == <span class="keyword">null</span> &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">      beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="org-springframework-context-support-PostProcessorRegistrationDelegate-invokeBeanFactoryPostProcessors-org-springframework-beans-factory-config-ConfigurableListableBeanFactory-java-util-List-lt-org-springframework-beans-factory-config-BeanFactoryPostProcessor-gt"><a href="#org-springframework-context-support-PostProcessorRegistrationDelegate-invokeBeanFactoryPostProcessors-org-springframework-beans-factory-config-ConfigurableListableBeanFactory-java-util-List-lt-org-springframework-beans-factory-config-BeanFactoryPostProcessor-gt" class="headerlink" title="org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors(org.springframework.beans.factory.config.ConfigurableListableBeanFactory, java.util.List&lt;org.springframework.beans.factory.config.BeanFactoryPostProcessor&gt;)"></a>org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors(org.springframework.beans.factory.config.ConfigurableListableBeanFactory, java.util.List&lt;org.springframework.beans.factory.config.BeanFactoryPostProcessor&gt;)</h6><p>该方法从代码上来看,还是做了蛮多的事情.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Invoke BeanDefinitionRegistryPostProcessors first, if any.</span></span><br><span class="line">   Set&lt;String&gt; processedBeans = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里是满足条件的    </span></span><br><span class="line">   <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> BeanDefinitionRegistry) &#123;</span><br><span class="line">      BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;</span><br><span class="line">      List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对 beanFactory的后置处理器进行迭代处理操作.       </span></span><br><span class="line">      <span class="keyword">for</span> (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;</span><br><span class="line">         <span class="keyword">if</span> (postProcessor <span class="keyword">instanceof</span> BeanDefinitionRegistryPostProcessor) &#123;</span><br><span class="line">            BeanDefinitionRegistryPostProcessor registryProcessor =</span><br><span class="line">                  (BeanDefinitionRegistryPostProcessor) postProcessor;</span><br><span class="line">            registryProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">            registryProcessors.add(registryProcessor);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            regularPostProcessors.add(postProcessor);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">      <span class="comment">// uninitialized to let the bean factory post-processors apply to them!</span></span><br><span class="line">      <span class="comment">// Separate between BeanDefinitionRegistryPostProcessors that implement</span></span><br><span class="line">      <span class="comment">// PriorityOrdered, Ordered, and the rest.</span></span><br><span class="line">      List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.</span></span><br><span class="line"><span class="comment">// 根据 BeanDefinitionRegistryPostProcessor.class 来获取beanNames数组,</span></span><br><span class="line"><span class="comment">// org.springframework.context.annotation.internalConfigurationAnnotationProcessor 这里是获取到了一个内置的BeanFactroyPostProcessor.      </span></span><br><span class="line">      String[] postProcessorNames =</span><br><span class="line">            beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line">      <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line"> <span class="comment">// 判断是不是有PriorityOrdered,         </span></span><br><span class="line">         <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line"> <span class="comment">// 这里的getBean就已经对bean进行初始化，是真正的走反射构造函数拿出来的实例对象.</span></span><br><span class="line"> <span class="comment">// getBean需要仔细分析下，因为其内部在 createBean是走了很多后置处理起来进行增强的. </span></span><br><span class="line"><span class="comment">// ConfigurationClassPostProcessor 给添加进来.             </span></span><br><span class="line">            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line"><span class="comment">// beanName 添加到 processedBeans集合中来了.             </span></span><br><span class="line">            processedBeans.add(ppName);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// 对集合进行排序,从beanFactory中获取出dependencyComparator来,如果没有的话,就用OrderComparator.INSTANCE默认的</span></span><br><span class="line">      sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line"><span class="comment">// 全部添加到 registryProcessors 中来.       </span></span><br><span class="line">      registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line"><span class="comment">// org.springframework.context.annotation.ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry</span></span><br><span class="line"><span class="comment">//这里是进入到ConfigurationClassPostProcessor中来了,可以看到其接口 BeanDefinitionRegistryPostProcessor,是重写了接口的方法. </span></span><br><span class="line"><span class="comment">// ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry 做了什么事情呢?</span></span><br><span class="line"><span class="comment">// 用System.identityHashCode(registry);计算出registryId来,如果在org.springframework.context.annotation.ConfigurationClassPostProcessor#registriesPostProcessed/factoriesPostProcessed(二个集合)中已经包含了的话,就会抛出已经被调用过的异常来.如果没有的话,就会添加到registriesPostProcessed中来</span></span><br><span class="line"><span class="comment">// 继续看 org.springframework.context.annotation.ConfigurationClassPostProcessor#processConfigBeanDefinitions 方法,</span></span><br><span class="line"><span class="comment">//先从registry中获取beanNames来,这其中就有Spring内置的和我们自己定义的yangBeanScannerConfig</span></span><br><span class="line"><span class="comment">//对beanNames迭代处理,接着就用ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)来判断要不要添加到List&lt;BeanDefinitionHolder&gt; configCandidates集合中来,最后是我们定义的beanName给添加进来了.</span></span><br><span class="line"><span class="comment">// 对configCandidates集合进行排序,</span></span><br><span class="line"><span class="comment">// 创建一个ConfigurationClassParser对象来解析每个@Configuration注解类.调用其parse和validate方法,解析完后就是一个ConfigurationClass的Set集合,接着就是new了一个ConfigurationClassBeanDefinitionReader对象来,</span></span><br><span class="line"><span class="comment">// this.reader.loadBeanDefinitions(configClasses); 这行代码有点根据Config去解析bean的意思.    </span></span><br><span class="line"><span class="comment">// 具体要等到后面深度解析再反过来定位每行代码的意思.</span></span><br><span class="line"><span class="comment">// 最后再清除下缓存.       </span></span><br><span class="line">      invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line"><span class="comment">// 清空 currentRegistryProcessors 集合      </span></span><br><span class="line">      currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.</span></span><br><span class="line">      postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line">      <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line"><span class="comment">// 如果processedBeans集合中不包含并且type是Ordered.class才满足进来的条件.          </span></span><br><span class="line">         <span class="keyword">if</span> (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">            processedBeans.add(ppName);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// 所以这里的currentRegistryProcessors集合是空集合.       </span></span><br><span class="line">      sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">      registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">      invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">      currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.</span></span><br><span class="line"><span class="comment">// 这里用 while 循环来最后解析,判断从getBeanNamesForType获取出来的bean是不是被解析过了的. </span></span><br><span class="line"><span class="comment">// 也是用 processedBeans 集合来进行控制的. </span></span><br><span class="line">      <span class="keyword">boolean</span> reiterate = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">while</span> (reiterate) &#123;</span><br><span class="line">         reiterate = <span class="keyword">false</span>;</span><br><span class="line">         postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line">         <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!processedBeans.contains(ppName)) &#123;</span><br><span class="line">               currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">               processedBeans.add(ppName);</span><br><span class="line">               reiterate = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">         registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">         invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">         currentRegistryProcessors.clear();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Now, invoke the postProcessBeanFactory callback of all processors handled so far.</span></span><br><span class="line"><span class="comment">// org.springframework.context.annotation.ConfigurationClassPostProcessor#postProcessBeanFactory,这里是走到了postProcessBeanFactory回调方法来了.用org.springframework.context.annotation.ConfigurationClassPostProcessor#factoriesPostProcessed集合来控制是否解析过了.用registriesPostProcessed集合来判断上次是否进入到postProcessBeanDefinitionRegistry方法中来. 如果没有的话,就会再走一边processConfigBeanDefinitions,可以看到 postProcessBeanDefinitionRegistry 方法最后也是走到了processConfigBeanDefinitions中来了.</span></span><br><span class="line"><span class="comment">//org.springframework.context.annotation.ConfigurationClassPostProcessor#enhanceConfigurationClasses 该方法判断是不是需要代理来增强,这里是没有的,所以就直接return掉了.</span></span><br><span class="line"><span class="comment">// 最后添加一个 ImportAwareBeanPostProcessor 后置处理器进来.       </span></span><br><span class="line">      invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);</span><br><span class="line"><span class="comment">// 这里的regularPostProcessors 集合是empty.       </span></span><br><span class="line">      invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Invoke factory processors registered with the context instance.</span></span><br><span class="line">      invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">   <span class="comment">// uninitialized to let the bean factory post-processors apply to them!</span></span><br><span class="line"> <span class="comment">// org.springframework.context.annotation.internalConfigurationAnnotationProcessor和org.springframework.context.event.internalEventListenerProcessor这里获取出来的是二个.   </span></span><br><span class="line">   String[] postProcessorNames =</span><br><span class="line">         beanFactory.getBeanNamesForType(BeanFactoryPostProcessor<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,</span></span><br><span class="line">   <span class="comment">// Ordered, and the rest.</span></span><br><span class="line">   List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line"> <span class="comment">// 这里是对上面已经处理过了的进行过滤处理.      </span></span><br><span class="line">      <span class="keyword">if</span> (processedBeans.contains(ppName)) &#123;</span><br><span class="line">         <span class="comment">// skip - already processed in first phase above</span></span><br><span class="line">      &#125;</span><br><span class="line">       </span><br><span class="line"><span class="comment">// 这里分为 PriorityOrdered&amp;Ordered&amp;非前二者,分这三种情况分别放入到三个不同的集合中.</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">         priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">         orderedPostProcessorNames.add(ppName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里是可以看到先是对PriorityOrdered进行处理,再对Ordered处理,最后对非前二者进行处理.    </span></span><br><span class="line">   <span class="comment">// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">   sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">   invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Next, invoke the BeanFactoryPostProcessors that implement Ordered.</span></span><br><span class="line">   List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(orderedPostProcessorNames.size());</span><br><span class="line">   <span class="keyword">for</span> (String postProcessorName : orderedPostProcessorNames) &#123;</span><br><span class="line"> <span class="comment">// 注意这里是调用了getBean方法.      </span></span><br><span class="line">      orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 排序    </span></span><br><span class="line">   sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">   invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Finally, invoke all other BeanFactoryPostProcessors.</span></span><br><span class="line">   List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(nonOrderedPostProcessorNames.size());</span><br><span class="line">   <span class="keyword">for</span> (String postProcessorName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line"> <span class="comment">// 注意这里也是调用了 getBean 方法的.      </span></span><br><span class="line">      nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// org.springframework.context.event.EventListenerMethodProcessor#postProcessBeanFactory</span></span><br><span class="line"><span class="comment">// 这里由于只有一个EventListenerMethodProcessor处理器,所以对应起来的走到其postProcessBeanFactory方法中来.</span></span><br><span class="line"><span class="comment">// 这里也是调用 postProcessBeanFactory 方法的意思,也就是回调方法.    </span></span><br><span class="line">   invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Clear cached merged bean definitions since the post-processors might have</span></span><br><span class="line">   <span class="comment">// modified the original metadata, e.g. replacing placeholders in values...</span></span><br><span class="line"><span class="comment">// org.springframework.beans.factory.support.DefaultListableBeanFactory#clearMetadataCache</span></span><br><span class="line"><span class="comment">// 对 一些集合等进行清除.    </span></span><br><span class="line">   beanFactory.clearMetadataCache();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>至此就可以看到,该方法主要是对BeanDefinitionRegistryPostProcessor.class和BeanFactoryPostProcessor.class来进行处理.</p>
<p>BeanDefinitionRegistryPostProcessor 又是先处理PriorityOrdered,然后会将处理过的放入processedBeans集合中做一个总的记录，再处理非再processedBeans集合记录中的和是Ordered的,最后用while循环来再确认一遍是不是有还没处理的,这个时候控制条件也是通过 processedBeans来控制是不是处理过了的. 这里注意, 实例化是通过调用 getBean方法来实现的,所以你会发现再调用invokeBeanDefinitionRegistryPostProcessors方法之前,都是会有调用getBean方法的.</p>
<p>BeanFactoryPostProcessor 的处理,这里是一次获取出,然后分为 PriorityOrdered/Ordered/非前二者，分别放入三个集合中进行处理,前提是都没再 processedBeans 集合中.  这里可以看到,如果是PriorityOrdered类型的话，那么在分类的时候就已经调用getBean方法来实例化这个对象了，其他二者都是最后迭代遍历的时候调用getBean方法的. 最后都是sortPostProcessors走下排序，然后调用invokeBeanFactoryPostProcessors方法，这个方法的意思，也就是调用 重写的  postProcessBeanFactory 的方法.</p>
<h5 id="registerBeanPostProcessors-方法"><a href="#registerBeanPostProcessors-方法" class="headerlink" title="registerBeanPostProcessors 方法"></a>registerBeanPostProcessors 方法</h5><p>该方法传入 beanFactory进来,然后直接借助 PostProcessorRegistrationDelegate 来实现.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">   PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="registerBeanPostProcessors-方法-1"><a href="#registerBeanPostProcessors-方法-1" class="headerlink" title="registerBeanPostProcessors 方法"></a>registerBeanPostProcessors 方法</h6><p>从名字上不难理解，注册 Bean的后置处理器进来.</p>
<p>这里传入进来的  beanFactory 是 DefaultListableBeanFactory , applicationContext是AnnotationConfigApplicationContext</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取出 BeanPostProcessor 的名字.</span></span><br><span class="line"><span class="comment">// org.springframework.context.annotation.internalAutowiredAnnotationProcessor</span></span><br><span class="line"><span class="comment">// org.springframework.context.annotation.internalCommonAnnotationProcessor</span></span><br><span class="line"><span class="comment">// 这里获取出来的是二个内部的后置处理器,因为我这里并没有扩展,只是简单的进行说明了下,后面会详细分析。</span></span><br><span class="line"><span class="comment">// 就是这行代码获取的是什么.    </span></span><br><span class="line">   String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Register BeanPostProcessorChecker that logs an info message when</span></span><br><span class="line">   <span class="comment">// a bean is created during BeanPostProcessor instantiation, i.e. when</span></span><br><span class="line">   <span class="comment">// a bean is not eligible for getting processed by all BeanPostProcessors.</span></span><br><span class="line"> <span class="comment">// 6   </span></span><br><span class="line">   <span class="keyword">int</span> beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + <span class="number">1</span> + postProcessorNames.length;</span><br><span class="line"><span class="comment">// 传入beanFactory和个数,创建出一个检查bean的后置处理器来.</span></span><br><span class="line"><span class="comment">// org.springframework.context.support.PostProcessorRegistrationDelegate.BeanPostProcessorChecker</span></span><br><span class="line"><span class="comment">// 有兴趣的同学可以看到该后置处理器重写的方法做了什么事情.</span></span><br><span class="line"><span class="comment">// 最后添加到 beanFactory 中来.    </span></span><br><span class="line">   beanFactory.addBeanPostProcessor(<span class="keyword">new</span> BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Separate between BeanPostProcessors that implement PriorityOrdered,</span></span><br><span class="line">   <span class="comment">// Ordered, and the rest.</span></span><br><span class="line">   List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   List&lt;BeanPostProcessor&gt; internalPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line"> <span class="comment">// 对后置处理器进行迭代   </span></span><br><span class="line">   <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">      <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">   <span class="comment">// 注意这里调用 getBean 方法是已经实例化这个后置处理起了.</span></span><br><span class="line"><span class="comment">// AutowiredAnnotationBeanPostProcessor</span></span><br><span class="line"><span class="comment">// CommonAnnotationBeanPostProcessor</span></span><br><span class="line"> <span class="comment">// 这里实例化的是Spring内置的二个         </span></span><br><span class="line">         BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">         priorityOrderedPostProcessors.add(pp);</span><br><span class="line">      <span class="comment">// 内部的二个后置处理器都是有实现   MergedBeanDefinitionPostProcessor 的. </span></span><br><span class="line">         <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">            internalPostProcessors.add(pp);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">         orderedPostProcessorNames.add(ppName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// First, register the BeanPostProcessors that implement PriorityOrdered.</span></span><br><span class="line"><span class="comment">// 排序    </span></span><br><span class="line">   sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line"><span class="comment">// 添加到 org.springframework.beans.factory.support.AbstractBeanFactory#beanPostProcessors,也就是添加到Spring的BanFactory中来.    </span></span><br><span class="line">   registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Next, register the BeanPostProcessors that implement Ordered.</span></span><br><span class="line"><span class="comment">// 这里是对实现了 Ordered 类型的处理，很显然我这里是没有的.    </span></span><br><span class="line">   List&lt;BeanPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(orderedPostProcessorNames.size());</span><br><span class="line">   <span class="keyword">for</span> (String ppName : orderedPostProcessorNames) &#123;</span><br><span class="line">      BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      orderedPostProcessors.add(pp);</span><br><span class="line">      <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">         internalPostProcessors.add(pp);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">   registerBeanPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Now, register all regular BeanPostProcessors.</span></span><br><span class="line"><span class="comment">// 最后是对非 PriorityOrdered和Ordered的处理，    </span></span><br><span class="line">   List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(nonOrderedPostProcessorNames.size());</span><br><span class="line">   <span class="keyword">for</span> (String ppName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">      BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      nonOrderedPostProcessors.add(pp);</span><br><span class="line">      <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">         internalPostProcessors.add(pp);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Finally, re-register all internal BeanPostProcessors.</span></span><br><span class="line"><span class="comment">// 这里可以看到,最后对内部的后置处理器又重新注册了一遍.    </span></span><br><span class="line">   sortPostProcessors(internalPostProcessors, beanFactory);</span><br><span class="line">   registerBeanPostProcessors(beanFactory, internalPostProcessors);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Re-register post-processor for detecting inner beans as ApplicationListeners,</span></span><br><span class="line">   <span class="comment">// moving it to the end of the processor chain (for picking up proxies etc).</span></span><br><span class="line"><span class="comment">// ApplicationListenerDetector 这里也是对  ApplicationListenerDetector 也是重新注册一遍.   </span></span><br><span class="line">   beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(applicationContext));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>该方法 借助 org.springframework.context.support.PostProcessorRegistrationDelegate#registerBeanPostProcessors(org.springframework.beans.factory.config.ConfigurableListableBeanFactory, org.springframework.context.support.AbstractApplicationContext) 来，获取BeanPostProcessor的后置处理器,也是分为 PriorityOrdered / Ordered/ 前二者都没有，在 PriorityOrdered  分类的时候，就已经调用了 getBean方法来获取出 bean 对象来(这里依然是分为了三个集合来装数据&amp;处理).  然后调用getBean方法后,就调用registerBeanPostProcessors方法，将后置处理器给注册到 Spring 的BeanFactory 中来.</p>
<p>最后还会最内部的 BeanPost后置处理器 &amp; ApplicationListenerDetector 再重新注册一遍.</p>
<p>可能会比较好奇这个后置处理器是干什么用的 ？ 在后面实例化 bean 的时候，就可以看到是有走很多后置处理器的.</p>
<p>所以该方法是对 beanPost的后置处理器进行实例化并且注册到 Spring 的 BeanFactory 中来的.</p>
<h5 id="initMessageSource-方法"><a href="#initMessageSource-方法" class="headerlink" title="initMessageSource () 方法"></a>initMessageSource () 方法</h5><p>初始化 messageSource .</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize the MessageSource.</span></span><br><span class="line"><span class="comment"> * Use parent's if none defined in this context.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initMessageSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 获取出 beanFactory   </span></span><br><span class="line">   ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line"><span class="comment">// 如果 beanFactory 包含了名字是messageSource的本地bean.    </span></span><br><span class="line">   <span class="keyword">if</span> (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) &#123;</span><br><span class="line">  <span class="comment">// 从 beanFactory 中获取出来.     </span></span><br><span class="line">      <span class="keyword">this</span>.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      <span class="comment">// Make MessageSource aware of parent MessageSource.</span></span><br><span class="line"><span class="comment">// this.parent不是null并且   messageSource是   HierarchicalMessageSource类型 </span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.parent != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.messageSource <span class="keyword">instanceof</span> HierarchicalMessageSource) &#123;</span><br><span class="line">  <span class="comment">// 强转,判断  getParentMessageSource 是不是null,如果是null的话,就调用 getInternalParentMessageSource() 将获取出来的值给set进去.     </span></span><br><span class="line">         HierarchicalMessageSource hms = (HierarchicalMessageSource) <span class="keyword">this</span>.messageSource;</span><br><span class="line">         <span class="keyword">if</span> (hms.getParentMessageSource() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Only set parent context as parent MessageSource if no parent MessageSource</span></span><br><span class="line">            <span class="comment">// registered already.</span></span><br><span class="line">            hms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(<span class="string">"Using MessageSource ["</span> + <span class="keyword">this</span>.messageSource + <span class="string">"]"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 这里是不包含的情况.       </span></span><br><span class="line">      <span class="comment">// Use empty MessageSource to be able to accept getMessage calls.</span></span><br><span class="line">      DelegatingMessageSource dms = <span class="keyword">new</span> DelegatingMessageSource();</span><br><span class="line"><span class="comment">// getInternalParentMessageSource() 返回的是null       </span></span><br><span class="line">      dms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line">      <span class="keyword">this</span>.messageSource = dms;</span><br><span class="line"><span class="comment">// 注册到 beanFactory 中来       </span></span><br><span class="line">      beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, <span class="keyword">this</span>.messageSource);</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(<span class="string">"No '"</span> + MESSAGE_SOURCE_BEAN_NAME + <span class="string">"' bean, using ["</span> + <span class="keyword">this</span>.messageSource + <span class="string">"]"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>该方法可以看到是对 messageSource 的初始化进行操作.</p>
<h5 id="initApplicationEventMulticaster-方法"><a href="#initApplicationEventMulticaster-方法" class="headerlink" title="initApplicationEventMulticaster 方法"></a>initApplicationEventMulticaster 方法</h5><p>这里如果了解过 Spring 的Event 机制的话,是可以比较清晰的感觉到,是对 ApplicationEventMulticaster 的初始化.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize the ApplicationEventMulticaster.</span></span><br><span class="line"><span class="comment"> * Uses SimpleApplicationEventMulticaster if none defined in the context.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.context.event.SimpleApplicationEventMulticaster</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initApplicationEventMulticaster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取出 beanFactory 来.  </span></span><br><span class="line">   ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line"><span class="comment">// 判断 beanFactory 是否包含  applicationEventMulticaster    </span></span><br><span class="line">   <span class="keyword">if</span> (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) &#123;</span><br><span class="line"><span class="comment">// 如果包含的话，就直接从beanFactroy中获取出来,并且赋值给  applicationEventMulticaster  </span></span><br><span class="line">      <span class="keyword">this</span>.applicationEventMulticaster =</span><br><span class="line">            beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(<span class="string">"Using ApplicationEventMulticaster ["</span> + <span class="keyword">this</span>.applicationEventMulticaster + <span class="string">"]"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="comment">// 如果不包含的话,传入beanFactory接着就是new一个SimpleApplicationEventMulticaster出来      </span></span><br><span class="line">      <span class="keyword">this</span>.applicationEventMulticaster = <span class="keyword">new</span> SimpleApplicationEventMulticaster(beanFactory);</span><br><span class="line"><span class="comment">// 然后注册到 beanFactory 中来.      </span></span><br><span class="line">      beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, <span class="keyword">this</span>.applicationEventMulticaster);</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(<span class="string">"No '"</span> + APPLICATION_EVENT_MULTICASTER_BEAN_NAME + <span class="string">"' bean, using "</span> +</span><br><span class="line">               <span class="string">"["</span> + <span class="keyword">this</span>.applicationEventMulticaster.getClass().getSimpleName() + <span class="string">"]"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里可以看到, 主要是对 applicationEventMulticaster 的初始化.  </p>
<p>如果beanFactory有的话，就从其中拿，如果没有就自己new一个,最后注册到beanFactory中来.</p>
<h5 id="onRefresh-方法"><a href="#onRefresh-方法" class="headerlink" title="onRefresh() 方法"></a>onRefresh() 方法</h5><p>这里是没有做任何事情的，如果是SpringBoot的源码的，这里就是启动tomcat的.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Template method which can be overridden to add context-specific refresh work.</span></span><br><span class="line"><span class="comment"> * Called on initialization of special beans, before instantiation of singletons.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This implementation is empty.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeansException in case of errors</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #refresh()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">   <span class="comment">// For subclasses: do nothing by default.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h5 id="registerListeners-方法"><a href="#registerListeners-方法" class="headerlink" title="registerListeners() 方法"></a>registerListeners() 方法</h5><p>从名字来看,这里是注册监听器的意思.</p>
<p>org.springframework.context.event.AbstractApplicationEventMulticaster.ListenerRetriever#applicationListeners 这里是存放监听器的地方。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add beans that implement ApplicationListener as listeners.</span></span><br><span class="line"><span class="comment"> * Doesn't affect other listeners, which can be added without being beans.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerListeners</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// Register statically specified listeners first.</span></span><br><span class="line"><span class="comment">// getApplicationListeners() 获取出来的是空集合.    </span></span><br><span class="line">   <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123;</span><br><span class="line">      getApplicationEventMulticaster().addApplicationListener(listener);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">   <span class="comment">// uninitialized to let post-processors apply to them!</span></span><br><span class="line"><span class="comment">// 根据ApplicationListener来获取出监听器，这也也是没有的.     </span></span><br><span class="line">   String[] listenerBeanNames = getBeanNamesForType(ApplicationListener<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line">   <span class="keyword">for</span> (String listenerBeanName : listenerBeanNames) &#123;</span><br><span class="line">      getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Publish early application events now that we finally have a multicaster...</span></span><br><span class="line"><span class="comment">// 这里也是获取早初始的 ApplicationEvent.    </span></span><br><span class="line">   Set&lt;ApplicationEvent&gt; earlyEventsToProcess = <span class="keyword">this</span>.earlyApplicationEvents;</span><br><span class="line">   <span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (earlyEventsToProcess != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (ApplicationEvent earlyEvent : earlyEventsToProcess) &#123;</span><br><span class="line">         getApplicationEventMulticaster().multicastEvent(earlyEvent);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>org.springframework.context.event.SimpleApplicationEventMulticaster#multicastEvent(org.springframework.context.ApplicationEvent, org.springframework.core.ResolvableType) 可以看下这个方法或者后续我们再详细的看，Spring是如何发送event的，以及那些监听器是怎么获取到 event 的.</p>
<p>TODO :  这里后面是有待详细的讲解的.</p>
<h5 id="finishBeanFactoryInitialization-方法"><a href="#finishBeanFactoryInitialization-方法" class="headerlink" title="finishBeanFactoryInitialization() 方法"></a>finishBeanFactoryInitialization() 方法</h5><p>从名字理解上,这里是对 beanFactory的初始化结束.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Finish the initialization of this context's bean factory,</span></span><br><span class="line"><span class="comment"> * initializing all remaining singleton beans.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// Initialize conversion service for this context.</span></span><br><span class="line"> <span class="comment">// 如果beanFactroy包含conversionService并且type是ConversionService.class的话，</span></span><br><span class="line">   <span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">         beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line"><span class="comment">// 就会从beanFactory中获取出对象设置到beanFactory的ConversionService来.       </span></span><br><span class="line">      beanFactory.setConversionService(</span><br><span class="line">            beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Register a default embedded value resolver if no bean post-processor</span></span><br><span class="line">   <span class="comment">// (such as a PropertyPlaceholderConfigurer bean) registered any before:</span></span><br><span class="line">   <span class="comment">// at this point, primarily for resolution in annotation attribute values.</span></span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line"><span class="comment">//org.springframework.beans.factory.support.AbstractBeanFactory#addEmbeddedValueResolver //添加到org.springframework.beans.factory.support.AbstractBeanFactory#embeddedValueResolvers中来.      </span></span><br><span class="line">      beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span></span><br><span class="line"><span class="comment">// 根据  LoadTimeWeaverAware.class 来获取信息.   </span></span><br><span class="line"><span class="comment">// 很明显这里我们是没有配置的,所以也就是没有的.    </span></span><br><span class="line">   String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware<span class="class">.<span class="keyword">class</span>, <span class="title">false</span>, <span class="title">false</span>)</span>;</span><br><span class="line">   <span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">      getBean(weaverAwareName);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Stop using the temporary ClassLoader for type matching.</span></span><br><span class="line">   beanFactory.setTempClassLoader(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Allow for caching all bean definition metadata, not expecting further changes.</span></span><br><span class="line"><span class="comment">//org.springframework.beans.factory.support.DefaultListableBeanFactory#freezeConfiguration</span></span><br><span class="line"><span class="comment">// 设置configurationFrozen是true,</span></span><br><span class="line"><span class="comment">// 将beanDefinitionNames集合转哈为String类型的数组. StringUtils.toStringArray(this.beanDefinitionNames);使用这个方法即可.    </span></span><br><span class="line">   beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">   beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="preInstantiateSingletons-方法"><a href="#preInstantiateSingletons-方法" class="headerlink" title="preInstantiateSingletons 方法"></a>preInstantiateSingletons 方法</h6><p>这里就是对 单例池 里面的对象进行初始化,可以看到是有 getBean 方法的.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">      logger.trace(<span class="string">"Pre-instantiating singletons in "</span> + <span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span></span><br><span class="line">   <span class="comment">// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span></span><br><span class="line"><span class="comment">// 这里获取出来的 beanNames 是有6个的,其中五个是包含了内部的</span></span><br><span class="line"><span class="comment">//org.springframework.context.annotation.internalConfigurationAnnotationProcessor</span></span><br><span class="line"><span class="comment">//org.springframework.context.annotation.internalAutowiredAnnotationProcessor</span></span><br><span class="line"><span class="comment">//org.springframework.context.annotation.internalCommonAnnotationProcessor</span></span><br><span class="line"><span class="comment">//org.springframework.context.event.internalEventListenerProcessor</span></span><br><span class="line"><span class="comment">//org.springframework.context.event.internalEventListenerFactory</span></span><br><span class="line"><span class="comment">//yangBeanScannerConfig    </span></span><br><span class="line">   List&lt;String&gt; beanNames = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Trigger initialization of all non-lazy singleton beans...</span></span><br><span class="line">   <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">      RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">       </span><br><span class="line">  <span class="comment">// bd 不是抽象的&amp;是单例的&amp;不是赖加载的     </span></span><br><span class="line">      <span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">  <span class="comment">// 判断是不是 FactroyBean        </span></span><br><span class="line">         <span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">            Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">            <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> FactoryBean) &#123;</span><br><span class="line">               <span class="keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line">               <span class="keyword">boolean</span> isEagerInit;</span><br><span class="line">               <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">                  isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)</span><br><span class="line">                              ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class="line">                        getAccessControlContext());</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span> &#123;</span><br><span class="line">                  isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">                        ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">                  getBean(beanName);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 这里不是 FactoryBean  </span></span><br><span class="line"><span class="comment">// 可以看到当我走到yangBeanScannerConfig,我们定义的类的时候,走完这个方法，就可以看到com.iyang.spring.config.YangBeanScannerConfig#YangBeanScannerConfig中打印的语句了,也就是说走完这里，我们定义的bean就已经被Spring被实例化了.             </span></span><br><span class="line">            getBean(beanName);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Trigger post-initialization callback for all applicable beans...</span></span><br><span class="line"><span class="comment">// 这里再对 beanNames 进行迭代,如果是 SmartInitializingSingleton 的话，就会再调用    afterSingletonsInstantiated 方法.</span></span><br><span class="line">   <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">      Object singletonInstance = getSingleton(beanName);</span><br><span class="line">      <span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">         <span class="keyword">final</span> SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">         <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">               smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;, getAccessControlContext());</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以对我们定义的 bean 进行实例化，最后是调用了 getBean 方法， getBean 方法表面看上去是获取，其实如果没有的话，调用的是createBean方法, 也就是会实例化我们的bean。当然它肯定不会很简单的去调用反射就实例化完一个我们的bean,肯定是有一系列的走Spring内置的或者我们自己定义的后置处理器等操作.</p>
<p>getBean 方法需要后面专门领出来分析，不能简单的过，这里对 Spring 容器进行大致的flow过,所以还是比较轻描淡写的写过去.</p>
<h5 id="finishRefresh-方法"><a href="#finishRefresh-方法" class="headerlink" title="finishRefresh 方法"></a>finishRefresh 方法</h5><p>中文式的英语 : 结束刷新方法.</p>
<p>显示清除缓存,再是init了LifecycleProcessor,调用其onRefresh()方法,接近就是发送一个ContextRefreshedEvent事件出来.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Finish the refresh of this context, invoking the LifecycleProcessor's</span></span><br><span class="line"><span class="comment"> * onRefresh() method and publishing the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.context.event.ContextRefreshedEvent&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// Clear context-level resource caches (such as ASM metadata from scanning).</span></span><br><span class="line"><span class="comment">//对org.springframework.core.io.DefaultResourceLoader#resourceCaches进行清除.    </span></span><br><span class="line">   clearResourceCaches();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Initialize lifecycle processor for this context.</span></span><br><span class="line">   initLifecycleProcessor();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Propagate refresh to lifecycle processor first.</span></span><br><span class="line"><span class="comment">//org.springframework.context.support.DefaultLifecycleProcessor</span></span><br><span class="line"><span class="comment">//org.springframework.context.support.DefaultLifecycleProcessor#startBeans</span></span><br><span class="line">    </span><br><span class="line">   getLifecycleProcessor().onRefresh();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Publish the final event.</span></span><br><span class="line"><span class="comment">// 推送Event,这里的Event是 ContextRefreshedEvent.    </span></span><br><span class="line">   publishEvent(<span class="keyword">new</span> ContextRefreshedEvent(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Participate in LiveBeansView MBean, if active.</span></span><br><span class="line"><span class="comment">//org.springframework.context.support.LiveBeansView#registerApplicationContext</span></span><br><span class="line"><span class="comment">//先根据key:spring.liveBeansView.mbeanDomain获取value,这里获取出来的是null,</span></span><br><span class="line"><span class="comment">// 所以也就是没有下文了.    </span></span><br><span class="line">   LiveBeansView.registerApplicationContext(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="initLifecycleProcessor-方法"><a href="#initLifecycleProcessor-方法" class="headerlink" title="initLifecycleProcessor 方法 ()"></a>initLifecycleProcessor 方法 ()</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize the LifecycleProcessor.</span></span><br><span class="line"><span class="comment"> * Uses DefaultLifecycleProcessor if none defined in the context.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.context.support.DefaultLifecycleProcessor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initLifecycleProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取出 beanFactory 来.  </span></span><br><span class="line">   ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line"><span class="comment">// 判断beanFactory中是否包含lifecycleProcessor    </span></span><br><span class="line">   <span class="keyword">if</span> (beanFactory.containsLocalBean(LIFECYCLE_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line"><span class="comment">// 包含的话,就会获取出来,指向this.lifecycleProcessor       </span></span><br><span class="line">      <span class="keyword">this</span>.lifecycleProcessor =</span><br><span class="line">            beanFactory.getBean(LIFECYCLE_PROCESSOR_BEAN_NAME, LifecycleProcessor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(<span class="string">"Using LifecycleProcessor ["</span> + <span class="keyword">this</span>.lifecycleProcessor + <span class="string">"]"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// 如果不包含的话，就自己new一个,然后注册到Spring容器中来.    </span></span><br><span class="line">      DefaultLifecycleProcessor defaultProcessor = <span class="keyword">new</span> DefaultLifecycleProcessor();</span><br><span class="line">      defaultProcessor.setBeanFactory(beanFactory);</span><br><span class="line">      <span class="keyword">this</span>.lifecycleProcessor = defaultProcessor;</span><br><span class="line">      beanFactory.registerSingleton(LIFECYCLE_PROCESSOR_BEAN_NAME, <span class="keyword">this</span>.lifecycleProcessor);</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(<span class="string">"No '"</span> + LIFECYCLE_PROCESSOR_BEAN_NAME + <span class="string">"' bean, using "</span> +</span><br><span class="line">               <span class="string">"["</span> + <span class="keyword">this</span>.lifecycleProcessor.getClass().getSimpleName() + <span class="string">"]"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="publishEvent-方法"><a href="#publishEvent-方法" class="headerlink" title="publishEvent 方法"></a>publishEvent 方法</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Publish the given event to all listeners.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> event the event to publish (may be an &#123;<span class="doctag">@link</span> ApplicationEvent&#125;</span></span><br><span class="line"><span class="comment"> * or a payload object to be turned into a &#123;<span class="doctag">@link</span> PayloadApplicationEvent&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> eventType the resolved event type, if known</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 4.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(Object event, @Nullable ResolvableType eventType)</span> </span>&#123;</span><br><span class="line">   Assert.notNull(event, <span class="string">"Event must not be null"</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Decorate event as an ApplicationEvent if necessary</span></span><br><span class="line">   ApplicationEvent applicationEvent;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 对传入进来的 event 进行类型的判断.    </span></span><br><span class="line">   <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ApplicationEvent) &#123;</span><br><span class="line">      applicationEvent = (ApplicationEvent) event;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      applicationEvent = <span class="keyword">new</span> PayloadApplicationEvent&lt;&gt;(<span class="keyword">this</span>, event);</span><br><span class="line">      <span class="keyword">if</span> (eventType == <span class="keyword">null</span>) &#123;</span><br><span class="line">         eventType = ((PayloadApplicationEvent&lt;?&gt;) applicationEvent).getResolvableType();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Multicast right now if possible - or lazily once the multicaster is initialized</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.earlyApplicationEvents != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.earlyApplicationEvents.add(applicationEvent);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//org.springframework.context.event.SimpleApplicationEventMulticaster#multicastEvent(org.springframework.context.ApplicationEvent, org.springframework.core.ResolvableType)</span></span><br><span class="line"><span class="comment">//走到了这里来发送event的,       </span></span><br><span class="line">      getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Publish event via parent context as well...</span></span><br><span class="line"><span class="comment">// 这里的 parent是null.    </span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.parent <span class="keyword">instanceof</span> AbstractApplicationContext) &#123;</span><br><span class="line">         ((AbstractApplicationContext) <span class="keyword">this</span>.parent).publishEvent(event, eventType);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">this</span>.parent.publishEvent(event);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是发送ContextRefreshedEvent事件出来.</p>
<h5 id="resetCommonCaches-方法"><a href="#resetCommonCaches-方法" class="headerlink" title="resetCommonCaches 方法()"></a>resetCommonCaches 方法()</h5><p>可以看到  finally 代码块中是疯狂的清除各种缓存.</p>
<p>可以大家可以点进去详细的看下，具体就不仔细描述了.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Reset Spring's common reflection metadata caches, in particular the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ReflectionUtils&#125;, &#123;<span class="doctag">@link</span> AnnotationUtils&#125;, &#123;<span class="doctag">@link</span> ResolvableType&#125;</span></span><br><span class="line"><span class="comment"> * and &#123;<span class="doctag">@link</span> CachedIntrospectionResults&#125; caches.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 4.2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ReflectionUtils#clearCache()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> AnnotationUtils#clearCache()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ResolvableType#clearCache()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> CachedIntrospectionResults#clearClassLoader(ClassLoader)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">resetCommonCaches</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   ReflectionUtils.clearCache();</span><br><span class="line">   AnnotationUtils.clearCache();</span><br><span class="line">   ResolvableType.clearCache();</span><br><span class="line">   CachedIntrospectionResults.clearClassLoader(getClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>  最后总结下,Spring在加载 bean &amp; 处理内置的一些配置 &amp; 内部处理器的时候,是下了很多的功夫。可以看着这些方法一步一步的分析下去,理解起来，个人感觉这里还不是特别深入的跟进去了代码，只是一个简单的大概描述，更深入的知识需要更加详细的理解等了.</p>
<p>  这里只是简单的对这个整个flow来进行描述，还不是特别有详细的那种.</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java源码</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
</search>
