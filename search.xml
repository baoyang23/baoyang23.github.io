<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ReentrantLock源码阅读</title>
    <url>/2020/06/20/ReentrantLock_source/</url>
    <content><![CDATA[<h2 id="ReentrantLock-源码阅读"><a href="#ReentrantLock-源码阅读" class="headerlink" title="ReentrantLock 源码阅读"></a>ReentrantLock 源码阅读</h2><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>​        ReetrantLock 效果是和 synchronized 是一样的,只不过 synchronized 是内置锁,ReetrantLock是语法级别的锁, 相对于而言是比synchronized灵活性高些. 不过从我目前公司写代码角度来看,都是直接使用 synchronized . 但是不妨碍我们来看 ReetrantLock 里面的代码实现.</p>
<p>​    使用代码 : 有lock方法就一定要有 unlock方法来释放锁.  一般代码中这样写即可.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockCaseMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockUseCase</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"执行业务代码逻辑"</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h4><p>​      ReetrantLock 中是没有什么全局参数,相比于集合,就没有那么多全局参数.但是我们要看其里面的内,这里有三个类,  Sync , NonfairSync , FairSync.     NonfairSync和FairSync 都是有继承 Sync. 可以看到NonfairSync 是非公平锁 , FairSync是公平锁.</p>
<p>​      Sync 又集成 AQS, 使用独占锁,  重写了 tryRelease 方法. </p>
<ul>
<li><p>构造函数:  默认是使用的非公平锁,如果传入进来的是true就会使用公平锁,否则就会使用非公平锁.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125;.</span></span><br><span class="line"><span class="comment"> * This is equivalent to using &#123;<span class="doctag">@code</span> ReentrantLock(false)&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125; with the</span></span><br><span class="line"><span class="comment"> * given fairness policy.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fair &#123;<span class="doctag">@code</span> true&#125; if this lock should use a fair ordering policy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>lock 方法:  lock方法是加锁的方法</p>
<p>lock方法是调用的 Sync 的lock方法, 然后我们可以看到上锁的时候,走的Sync,然后根据FairSync/NonfairSync取走各自的加锁方法,所以说公平锁和非公平锁是加锁的方式是不一样的.</p>
</li>
</ul>
<p>  非公平锁获取锁的时候,会获取state这个状态标识,然后再去走对应的逻辑,这里多了比非公平锁多了一个从队列中获取信息和不能获取锁的线程就会被挂起进入队列中排队.</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;    sync.lock();&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sync </span></span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 公平锁</span></span><br><span class="line"><span class="comment">     * Sync object for fair locks</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">tatic <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">/* </span></span><br><span class="line"><span class="comment">    	acquire(1) 调用到AQS中,最后还是调用到下面的tryAcquire方法.</span></span><br><span class="line"><span class="comment">    	那些没有获取到锁的线程,就会按照队列的方式排队,满足先进先出的效果的,也就是先来的线程先执行,</span></span><br><span class="line"><span class="comment">    	果然这就很公平</span></span><br><span class="line"><span class="comment">    	**/</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Fair version of tryAcquire.  Don't grant access unless</span></span><br><span class="line"><span class="comment">         * recursive call or no waiters or is first.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                	hasQueuedPredecessors() 方法,先判断头结点和尾结点是不相等的,因为相等的话,就重复了,就是同一个. 然后在判断头结点的 thread是不是当前线程,如果不是当前的前程的话,那么就是在这个线程钱面还有一个等待获取锁时间更久的线程,于是就先抛弃这个线程,去执行那个等待更久的线程.</span></span><br><span class="line"><span class="comment">                	</span></span><br><span class="line"><span class="comment">                	compareAndSetState 就是用cas来获取锁的代码,如果获取成功的话,就会走setExclusiveOwnerThread方法,这里set进去的值是在释放锁的时候会用到.</span></span><br><span class="line"><span class="comment">                	最后返回true,说明获取锁成功了.</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            	获取从setExclusiveOwnerThread里面的thread,来判断是否与当前线程相等,如果相等的话,就说明重入了.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;之前</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">        <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">        <span class="comment">// thread is first in queue.</span></span><br><span class="line">        Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        Node s;</span><br><span class="line">        <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">            ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	非公平锁:</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class="line"><span class="comment">         * acquire on failure.</span></span><br><span class="line"><span class="comment">         可以看到非公平锁是没有从队列中获取说明结点信息,而是直接获取锁的.</span></span><br><span class="line"><span class="comment">         获取成功了就会走 setExclusiveOwnerThread 方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	Sync类中</span></span><br><span class="line"><span class="comment">	这段代码的逻辑也是和 公平锁后来的处理一样的了. c如果是0的话,就会走获取锁的代码,如果不是0的话,就说明重入了,所以就++</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>  unlock方法:   unlock是释放锁的方法. 可以看到释放锁是走的 Sync的release方法,所以不管公平锁还是非公平锁起走的释放锁方法是不一样的.</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;    sync.release(<span class="number">1</span>);&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	Sync 中方法. </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// tryRelease()方法返回true的话,就说明锁都释放完了.</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="comment">// 恢复线程</span></span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">            <span class="comment">// 如果当前线程不是自己的话,就会抛出异常.这里可以理解为,独占锁,肯定是自己.</span></span><br><span class="line">            <span class="comment">// 也就是说,如果不是独占锁的话,就会抛出异常.</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 如果你调用了一次lock的话,那么会加一,所以这个地方要等这个lock方法全部被释放掉.</span></span><br><span class="line">    		<span class="comment">// 也就是由于重入锁的原因.</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                free = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 释放完了,就设置了null.  </span></span><br><span class="line">                <span class="comment">// 然后AbstractOwnableSynchronizer中的thread标记也就是null,</span></span><br><span class="line">                <span class="comment">// 所以下个线程判断是null的话,就可以获取到执行权,也就是获取到锁.</span></span><br><span class="line">                setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            setState(c);</span><br><span class="line">            <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​         </p>
<ul>
<li><p>​    isLocked () 方法, 判断这个线程是不是被锁了:</p>
<p>​    调用Sync中isLock方法,如果不是0的话,就说明是被锁了,如果是0的话,就说明没有被锁.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Queries if this lock is held by any thread. This method is</span></span><br><span class="line"><span class="comment">     * designed for use in monitoring of the system state,</span></span><br><span class="line"><span class="comment">     * not for synchronization control.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if any thread holds this lock and</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> false&#125; otherwise</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.isLocked();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"> <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>  hasQueuedThreads()  :  是否有线程在等待队列中</p>
<p>  hasQueuedThread(Thread thread) :  线程是否在等待队列中</p>
<p>  getQueueLength() :  获取队列中线程个数</p>
<p>  等这些方法都是比较好理解的,可以自行点进去仔细看下.  </p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><pre><code> Sync  /  NonfairSync  /  FairSync  这个三个类就是 ReetrantLock中的三个类,都是围绕这这三个类在做文章.

公平锁和非公平锁的获取锁方式不一样,但是释放方式是一样的. 公平锁获取锁的时候,如果有线程持有了的话,那么其他的会被挂起并且进入等待队列. 而非公平锁,直接获取锁,就是抢占式.</code></pre>]]></content>
      <categories>
        <category>ReentrantLock</category>
      </categories>
      <tags>
        <tag>java源码</tag>
        <tag>Java锁</tag>
      </tags>
  </entry>
  <entry>
    <title>docker学习笔记</title>
    <url>/2020/04/23/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h3><blockquote>
<p><strong>Docker</strong> 是个好东西，所以你得学习。 进公司是一直都有使用docker来发布项目的,之前对docker也是有多多少少的学习。最近想学习一下k8s，所以也顺路安装一下docker.</p>
</blockquote>
<hr>
<h3 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a>Docker 安装</h3><blockquote>
<p>这里笔者安装的环境就是 VM 上跑的 Centos 来进行安装的</p>
</blockquote>
<ol>
<li><p>卸载旧版本</p>
<p>[root@localhost ~]# sudo yum remove docker \</p>
<blockquote>
<pre><code>docker-client \
docker-client-latest \
docker-common \
docker-latest \
docker-latest-logrotate \
docker-logrotate \
docker-engine
已加载插件：fastestmirror
参数 docker 没有匹配
参数 docker-client 没有匹配
参数 docker-client-latest 没有匹配
参数 docker-common 没有匹配
参数 docker-latest 没有匹配
参数 docker-latest-logrotate 没有匹配
参数 docker-logrotate 没有匹配
参数 docker-engine 没有匹配
不删除任何软件包</code></pre></blockquote>
</li>
<li><p>安装所需要的依赖包</p>
<blockquote>
<p><strong>sudo</strong> <strong>yum install</strong> -y yum-utils <br> device-mapper-persistent-data <br> lvm2</p>
</blockquote>
</li>
<li><p>设置稳定的仓库</p>
<blockquote>
<p><strong>sudo</strong> yum-config-manager <br>  –add-repo <br>  https:<strong>//</strong>download.docker.com<strong>/</strong>linux<strong>/</strong>centos<strong>/</strong>docker-ce.repo</p>
</blockquote>
</li>
<li><p>安装最新的Docker Engine-Community</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;sudo yum install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
<hr>
<p> 感觉 正常的安装 docker 还是很慢的</p>
<p>Step 1 : 安装必要的一些系统工具</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure>



<p>Step 2 : 添加软件信息</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager --<span class="keyword">add</span><span class="bash">-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span></span><br></pre></td></tr></table></figure>



<p>Step 3 :  更新并且安装 docker-ce</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line">sudo yum makecache fast</span><br></pre></td></tr></table></figure>



<p>Step 4 : 开启Docker服务</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line">sudo service docker start</span><br></pre></td></tr></table></figure>



<p>Step 5 (非必要),配置加速</p>
<p>/etc/docker/daemon.json (如果没有这个文件的话,就去创建一个)</p>
<p>{</p>
<p>“registry-mirrors”: [“<a href="http://hub-mirror.c.163.com&quot;]">http://hub-mirror.c.163.com&quot;]</a></p>
<p>}</p>
<p>Step 6 重启指令</p>
<p>   systemctl daemon-reload</p>
<p>   systemctl restart docker</p>
<hr>
<p>现在VM上安装一台Centos 7 , 安装好docker , 然后使用克隆来克隆一台即可。最好的镜像加速也要配置下.</p>
<p>Linux : Centos 7</p>
<table>
<thead>
<tr>
<th>主机名</th>
<th>ip</th>
<th><strong>kubelet</strong>/<strong>kubeadm</strong>/<strong>kubectl</strong></th>
<th>flannel version</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>master</td>
<td>192.168.247.131</td>
<td>V1.14.2</td>
<td>V0.11.0</td>
<td>主节点</td>
</tr>
<tr>
<td>node</td>
<td>192.168.247.132</td>
<td>V1.14.2</td>
<td>V0.11.0</td>
<td>node节点</td>
</tr>
</tbody></table>
<h3 id="主机名"><a href="#主机名" class="headerlink" title="主机名"></a>主机名</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hostnamectl set-hostname master</span><br><span class="line">hostnamectl set-hostname node</span><br></pre></td></tr></table></figure>



<p> 修改/etc/hosts ; 即可</p>
<p> [root@localhost ~]# cat /etc/hosts<br>127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4<br>::1         localhost localhost.localdomain localhost6 localhost6.localdomain6<br>192.168.247.131 master<br>192.168.247.132 node</p>
<hr>
<p>零时禁用Swap : </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">swapoff -a</span><br></pre></td></tr></table></figure>



<p>永久禁用:</p>
<p>  sed -i.bak ‘/swap/s/^/#/‘ /etc/fstab</p>
<hr>
<p>内核参数修改 :</p>
<p>   零时修改 :</p>
<p>​        sysctl net.bridge.bridge-nf-call-iptables=1</p>
<p>​       sysctl net.bridge.bridge-nf-call-ip6tables=1</p>
<p>   永久修改 :</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt;  /etc/sysctl.d/k8s.conf</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<p>   sysctl -p /etc/sysctl.d/k8s.conf</p>
<p>Notes  :  如果遇见了下面这个错误</p>
<p>sysctl: cannot stat /proc/sys/net/bridge/bridge-nf-call-iptables: No such file or directory<br>sysctl: cannot stat /proc/sys/net/bridge/bridge-nf-call-ip6tables: No such file or directory</p>
<p>执行 modprobe br_netfilter 即可.</p>
<hr>
<p>修改 Cgroup Driver  –&gt; 修改daemon.json</p>
<p> 在 /etc/docker/daemon.json中新加</p>
<p>“exec-opts”: [“native.cgroupdriver=systemd”</p>
<p>[root@localhost ~]# cat /etc/docker/daemon.json<br>{<br>  “registry-mirrors”: [“<a href="http://hub-mirror.c.163.com&quot;]">http://hub-mirror.c.163.com&quot;]</a>,<br>  “exec-opts”: [“native.cgroupdriver=systemd”]<br>}</p>
<p>这样的效果即可.</p>
<p>配置了后记得重启下docker即可</p>
<hr>
<p>设置 k8s 源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>



<blockquote>
<ol>
<li>[] 中括号中的是repository id，唯一，用来标识不同仓库</li>
<li>name 仓库名称，自定义</li>
<li>baseurl 仓库地址</li>
<li>enable 是否启用该仓库，默认为1表示启用</li>
<li>gpgcheck 是否验证从该仓库获得程序包的合法性，1为验证</li>
<li>repo_gpgcheck 是否验证元数据的合法性 元数据就是程序包列表，1为验证</li>
<li>gpgkey=URL 数字签名的公钥文件所在位置，如果gpgcheck值为1，此处就需要指定gpgkey文件的位置，如果gpgcheck值为0就不需要此项了</li>
</ol>
</blockquote>
<p>更新下缓存 :</p>
<p> yum clean all</p>
<p> yum -y makecache</p>
<hr>
<h3 id="Master节点安装"><a href="#Master节点安装" class="headerlink" title="Master节点安装"></a>Master节点安装</h3><p> 如果不指定的话,那么就默认是安装最新的</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line">yum install -y kubelet-<span class="number">1.14</span>.<span class="number">2</span> kubeadm-<span class="number">1.14</span>.<span class="number">2</span> kubectl-<span class="number">1.14</span>.<span class="number">2</span></span><br></pre></td></tr></table></figure>



<p>启动kubelet 并且设置为开机自动启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> kubelet &amp;&amp; systemctl start kubelet</span><br></pre></td></tr></table></figure>



<p>kubelet命令补全</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"source &lt;(kubectl completion bash)"</span> &gt;&gt; ~/.bash_profile</span><br><span class="line"><span class="built_in">source</span> .bash_profile</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h3><p>vi image.sh</p>
<p> 往 sh 脚本里面写入 下面的内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">url=registry.cn-hangzhou.aliyuncs.com/google_containers</span><br><span class="line">version=v1.14.2</span><br><span class="line">images=(`kubeadm config images list --kubernetes-version=<span class="variable">$version</span>|awk -F <span class="string">'/'</span> <span class="string">'&#123;print $2&#125;'</span>`)</span><br><span class="line"><span class="keyword">for</span> imagename <span class="keyword">in</span> <span class="variable">$&#123;images[@]&#125;</span> ; <span class="keyword">do</span></span><br><span class="line">  docker pull <span class="variable">$url</span>/<span class="variable">$imagename</span></span><br><span class="line">  docker tag <span class="variable">$url</span>/<span class="variable">$imagename</span> k8s.gcr.io/<span class="variable">$imagename</span></span><br><span class="line">  docker rmi -f <span class="variable">$url</span>/<span class="variable">$imagename</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>



<p>给权限 chmod u+x image.sh</p>
<p>启动 ./image.sh</p>
<hr>
<h3 id="初始化-Master"><a href="#初始化-Master" class="headerlink" title="初始化 Master"></a>初始化 Master</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubeadm init --apiserver-advertise-address 192.168.247.131 --pod-network-cidr=10.244.0.0/16</span><br></pre></td></tr></table></figure>

<p> 这里启动ok了后会有 node加入节点的信息</p>
<p>加载环境变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"export KUBECONFIG=/etc/kubernetes/admin.conf"</span> &gt;&gt; ~/.bash_profile</span><br><span class="line"><span class="built_in">source</span> .bash_profile</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">cp -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">chown $(id -u):$(id -g) <span class="variable">$HOME</span>/.kube/config</span><br></pre></td></tr></table></figure>



<hr>
<p>安装pod 网络</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br></pre></td></tr></table></figure>

<p>如果 kube-flannel.yml 访问不了的话，就创建一个,然后copy进去</p>
<h2 id="root-localhost-cat-kube-flannel-yml"><a href="#root-localhost-cat-kube-flannel-yml" class="headerlink" title="[root@localhost ~]# cat kube-flannel.yml "></a>[root@localhost ~]# cat kube-flannel.yml </h2><p>apiVersion: policy/v1beta1<br>kind: PodSecurityPolicy<br>metadata:<br>  name: psp.flannel.unprivileged<br>  annotations:<br>    seccomp.security.alpha.kubernetes.io/allowedProfileNames: docker/default<br>    seccomp.security.alpha.kubernetes.io/defaultProfileName: docker/default<br>    apparmor.security.beta.kubernetes.io/allowedProfileNames: runtime/default<br>    apparmor.security.beta.kubernetes.io/defaultProfileName: runtime/default<br>spec:<br>  privileged: false<br>  volumes:<br>    - configMap<br>    - secret<br>    - emptyDir<br>    - hostPath<br>  allowedHostPaths:<br>    - pathPrefix: “/etc/cni/net.d”<br>    - pathPrefix: “/etc/kube-flannel”<br>    - pathPrefix: “/run/flannel”<br>  readOnlyRootFilesystem: false</p>
<h1 id="Users-and-groups"><a href="#Users-and-groups" class="headerlink" title="Users and groups"></a>Users and groups</h1><p>  runAsUser:<br>    rule: RunAsAny<br>  supplementalGroups:<br>    rule: RunAsAny<br>  fsGroup:<br>    rule: RunAsAny</p>
<h1 id="Privilege-Escalation"><a href="#Privilege-Escalation" class="headerlink" title="Privilege Escalation"></a>Privilege Escalation</h1><p>  allowPrivilegeEscalation: false<br>  defaultAllowPrivilegeEscalation: false</p>
<h1 id="Capabilities"><a href="#Capabilities" class="headerlink" title="Capabilities"></a>Capabilities</h1><p>  allowedCapabilities: [‘NET_ADMIN’]<br>  defaultAddCapabilities: []<br>  requiredDropCapabilities: []</p>
<h1 id="Host-namespaces"><a href="#Host-namespaces" class="headerlink" title="Host namespaces"></a>Host namespaces</h1><p>  hostPID: false<br>  hostIPC: false<br>  hostNetwork: true<br>  hostPorts:</p>
<ul>
<li>min: 0<br>max: 65535<h1 id="SELinux"><a href="#SELinux" class="headerlink" title="SELinux"></a>SELinux</h1>seLinux:<h1 id="SELinux-is-unused-in-CaaSP"><a href="#SELinux-is-unused-in-CaaSP" class="headerlink" title="SELinux is unused in CaaSP"></a>SELinux is unused in CaaSP</h1>rule: ‘RunAsAny’</li>
</ul>
<hr>
<p>kind: ClusterRole<br>apiVersion: rbac.authorization.k8s.io/v1beta1<br>metadata:<br>  name: flannel<br>rules:</p>
<ul>
<li>apiGroups: [‘extensions’]<br>resources: [‘podsecuritypolicies’]<br>verbs: [‘use’]<br>resourceNames: [‘psp.flannel.unprivileged’]</li>
<li>apiGroups:<ul>
<li>“”<br>resources:</li>
<li>pods<br>verbs:</li>
<li>get</li>
</ul>
</li>
<li>apiGroups:<ul>
<li>“”<br>resources:</li>
<li>nodes<br>verbs:</li>
<li>list</li>
<li>watch</li>
</ul>
</li>
<li>apiGroups:<ul>
<li>“”<br>resources:</li>
<li>nodes/status<br>verbs:</li>
<li>patch</li>
</ul>
</li>
</ul>
<hr>
<p>kind: ClusterRoleBinding<br>apiVersion: rbac.authorization.k8s.io/v1beta1<br>metadata:<br>  name: flannel<br>roleRef:<br>  apiGroup: rbac.authorization.k8s.io<br>  kind: ClusterRole<br>  name: flannel<br>subjects:</p>
<ul>
<li>kind: ServiceAccount<br>name: flannel<br>namespace: kube-system</li>
</ul>
<hr>
<p>apiVersion: v1<br>kind: ServiceAccount<br>metadata:<br>  name: flannel<br>  namespace: kube-system</p>
<hr>
<p>kind: ConfigMap<br>apiVersion: v1<br>metadata:<br>  name: kube-flannel-cfg<br>  namespace: kube-system<br>  labels:<br>    tier: node<br>    app: flannel<br>data:<br>  cni-conf.json: |<br>    {<br>      “name”: “cbr0”,<br>      “cniVersion”: “0.3.1”,<br>      “plugins”: [<br>        {<br>          “type”: “flannel”,<br>          “delegate”: {<br>            “hairpinMode”: true,<br>            “isDefaultGateway”: true<br>          }<br>        },<br>        {<br>          “type”: “portmap”,<br>          “capabilities”: {<br>            “portMappings”: true<br>          }<br>        }<br>      ]<br>    }<br>  net-conf.json: |<br>    {<br>      “Network”: “10.244.0.0/16”,<br>      “Backend”: {<br>        “Type”: “vxlan”<br>      }<br>    }</p>
<hr>
<p>apiVersion: apps/v1<br>kind: DaemonSet<br>metadata:<br>  name: kube-flannel-ds-amd64<br>  namespace: kube-system<br>  labels:<br>    tier: node<br>    app: flannel<br>spec:<br>  selector:<br>    matchLabels:<br>      app: flannel<br>  template:<br>    metadata:<br>      labels:<br>        tier: node<br>        app: flannel<br>    spec:<br>      affinity:<br>        nodeAffinity:<br>          requiredDuringSchedulingIgnoredDuringExecution:<br>            nodeSelectorTerms:<br>              - matchExpressions:<br>                  - key: kubernetes.io/os<br>                    operator: In<br>                    values:<br>                      - linux<br>                  - key: kubernetes.io/arch<br>                    operator: In<br>                    values:<br>                      - amd64<br>      hostNetwork: true<br>      tolerations:<br>      - operator: Exists<br>        effect: NoSchedule<br>      serviceAccountName: flannel<br>      initContainers:<br>      - name: install-cni<br>        image: quay.io/coreos/flannel:v0.12.0-amd64<br>        command:<br>        - cp<br>        args:<br>        - -f<br>        - /etc/kube-flannel/cni-conf.json<br>        - /etc/cni/net.d/10-flannel.conflist<br>        volumeMounts:<br>        - name: cni<br>          mountPath: /etc/cni/net.d<br>        - name: flannel-cfg<br>          mountPath: /etc/kube-flannel/<br>      containers:<br>      - name: kube-flannel<br>        image: quay.io/coreos/flannel:v0.12.0-amd64<br>        command:<br>        - /opt/bin/flanneld<br>        args:<br>        - –ip-masq<br>        - –kube-subnet-mgr<br>        resources:<br>          requests:<br>            cpu: “100m”<br>            memory: “50Mi”<br>          limits:<br>            cpu: “100m”<br>            memory: “50Mi”<br>        securityContext:<br>          privileged: false<br>          capabilities:<br>            add: [“NET_ADMIN”]<br>        env:<br>        - name: POD_NAME<br>          valueFrom:<br>            fieldRef:<br>              fieldPath: metadata.name<br>        - name: POD_NAMESPACE<br>          valueFrom:<br>            fieldRef:<br>              fieldPath: metadata.namespace<br>        volumeMounts:<br>        - name: run<br>          mountPath: /run/flannel<br>        - name: flannel-cfg<br>          mountPath: /etc/kube-flannel/<br>      volumes:<br>        - name: run<br>          hostPath:<br>            path: /run/flannel<br>        - name: cni<br>          hostPath:<br>            path: /etc/cni/net.d<br>        - name: flannel-cfg<br>          configMap:<br>            name: kube-flannel-cfg</p>
<hr>
<p>apiVersion: apps/v1<br>kind: DaemonSet<br>metadata:<br>  name: kube-flannel-ds-arm64<br>  namespace: kube-system<br>  labels:<br>    tier: node<br>    app: flannel<br>spec:<br>  selector:<br>    matchLabels:<br>      app: flannel<br>  template:<br>    metadata:<br>      labels:<br>        tier: node<br>        app: flannel<br>    spec:<br>      affinity:<br>        nodeAffinity:<br>          requiredDuringSchedulingIgnoredDuringExecution:<br>            nodeSelectorTerms:<br>              - matchExpressions:<br>                  - key: kubernetes.io/os<br>                    operator: In<br>                    values:<br>                      - linux<br>                  - key: kubernetes.io/arch<br>                    operator: In<br>                    values:<br>                      - arm64<br>      hostNetwork: true<br>      tolerations:<br>      - operator: Exists<br>        effect: NoSchedule<br>      serviceAccountName: flannel<br>      initContainers:<br>      - name: install-cni<br>        image: quay.io/coreos/flannel:v0.12.0-arm64<br>        command:<br>        - cp<br>        args:<br>        - -f<br>        - /etc/kube-flannel/cni-conf.json<br>        - /etc/cni/net.d/10-flannel.conflist<br>        volumeMounts:<br>        - name: cni<br>          mountPath: /etc/cni/net.d<br>        - name: flannel-cfg<br>          mountPath: /etc/kube-flannel/<br>      containers:<br>      - name: kube-flannel<br>        image: quay.io/coreos/flannel:v0.12.0-arm64<br>        command:<br>        - /opt/bin/flanneld<br>        args:<br>        - –ip-masq<br>        - –kube-subnet-mgr<br>        resources:<br>          requests:<br>            cpu: “100m”<br>            memory: “50Mi”<br>          limits:<br>            cpu: “100m”<br>            memory: “50Mi”<br>        securityContext:<br>          privileged: false<br>          capabilities:<br>             add: [“NET_ADMIN”]<br>        env:<br>        - name: POD_NAME<br>          valueFrom:<br>            fieldRef:<br>              fieldPath: metadata.name<br>        - name: POD_NAMESPACE<br>          valueFrom:<br>            fieldRef:<br>              fieldPath: metadata.namespace<br>        volumeMounts:<br>        - name: run<br>          mountPath: /run/flannel<br>        - name: flannel-cfg<br>          mountPath: /etc/kube-flannel/<br>      volumes:<br>        - name: run<br>          hostPath:<br>            path: /run/flannel<br>        - name: cni<br>          hostPath:<br>            path: /etc/cni/net.d<br>        - name: flannel-cfg<br>          configMap:<br>            name: kube-flannel-cfg</p>
<hr>
<p>apiVersion: apps/v1<br>kind: DaemonSet<br>metadata:<br>  name: kube-flannel-ds-arm<br>  namespace: kube-system<br>  labels:<br>    tier: node<br>    app: flannel<br>spec:<br>  selector:<br>    matchLabels:<br>      app: flannel<br>  template:<br>    metadata:<br>      labels:<br>        tier: node<br>        app: flannel<br>    spec:<br>      affinity:<br>        nodeAffinity:<br>          requiredDuringSchedulingIgnoredDuringExecution:<br>            nodeSelectorTerms:<br>              - matchExpressions:<br>                  - key: kubernetes.io/os<br>                    operator: In<br>                    values:<br>                      - linux<br>                  - key: kubernetes.io/arch<br>                    operator: In<br>                    values:<br>                      - arm<br>      hostNetwork: true<br>      tolerations:<br>      - operator: Exists<br>        effect: NoSchedule<br>      serviceAccountName: flannel<br>      initContainers:<br>      - name: install-cni<br>        image: quay.io/coreos/flannel:v0.12.0-arm<br>        command:<br>        - cp<br>        args:<br>        - -f<br>        - /etc/kube-flannel/cni-conf.json<br>        - /etc/cni/net.d/10-flannel.conflist<br>        volumeMounts:<br>        - name: cni<br>          mountPath: /etc/cni/net.d<br>        - name: flannel-cfg<br>          mountPath: /etc/kube-flannel/<br>      containers:<br>      - name: kube-flannel<br>        image: quay.io/coreos/flannel:v0.12.0-arm<br>        command:<br>        - /opt/bin/flanneld<br>        args:<br>        - –ip-masq<br>        - –kube-subnet-mgr<br>        resources:<br>          requests:<br>            cpu: “100m”<br>            memory: “50Mi”<br>          limits:<br>            cpu: “100m”<br>            memory: “50Mi”<br>        securityContext:<br>          privileged: false<br>          capabilities:<br>             add: [“NET_ADMIN”]<br>        env:<br>        - name: POD_NAME<br>          valueFrom:<br>            fieldRef:<br>              fieldPath: metadata.name<br>        - name: POD_NAMESPACE<br>          valueFrom:<br>            fieldRef:<br>              fieldPath: metadata.namespace<br>        volumeMounts:<br>        - name: run<br>          mountPath: /run/flannel<br>        - name: flannel-cfg<br>          mountPath: /etc/kube-flannel/<br>      volumes:<br>        - name: run<br>          hostPath:<br>            path: /run/flannel<br>        - name: cni<br>          hostPath:<br>            path: /etc/cni/net.d<br>        - name: flannel-cfg<br>          configMap:<br>            name: kube-flannel-cfg</p>
<hr>
<p>apiVersion: apps/v1<br>kind: DaemonSet<br>metadata:<br>  name: kube-flannel-ds-ppc64le<br>  namespace: kube-system<br>  labels:<br>    tier: node<br>    app: flannel<br>spec:<br>  selector:<br>    matchLabels:<br>      app: flannel<br>  template:<br>    metadata:<br>      labels:<br>        tier: node<br>        app: flannel<br>    spec:<br>      affinity:<br>        nodeAffinity:<br>          requiredDuringSchedulingIgnoredDuringExecution:<br>            nodeSelectorTerms:<br>              - matchExpressions:<br>                  - key: kubernetes.io/os<br>                    operator: In<br>                    values:<br>                      - linux<br>                  - key: kubernetes.io/arch<br>                    operator: In<br>                    values:<br>                      - ppc64le<br>      hostNetwork: true<br>      tolerations:<br>      - operator: Exists<br>        effect: NoSchedule<br>      serviceAccountName: flannel<br>      initContainers:<br>      - name: install-cni<br>        image: quay.io/coreos/flannel:v0.12.0-ppc64le<br>        command:<br>        - cp<br>        args:<br>        - -f<br>        - /etc/kube-flannel/cni-conf.json<br>        - /etc/cni/net.d/10-flannel.conflist<br>        volumeMounts:<br>        - name: cni<br>          mountPath: /etc/cni/net.d<br>        - name: flannel-cfg<br>          mountPath: /etc/kube-flannel/<br>      containers:<br>      - name: kube-flannel<br>        image: quay.io/coreos/flannel:v0.12.0-ppc64le<br>        command:<br>        - /opt/bin/flanneld<br>        args:<br>        - –ip-masq<br>        - –kube-subnet-mgr<br>        resources:<br>          requests:<br>            cpu: “100m”<br>            memory: “50Mi”<br>          limits:<br>            cpu: “100m”<br>            memory: “50Mi”<br>        securityContext:<br>          privileged: false<br>          capabilities:<br>             add: [“NET_ADMIN”]<br>        env:<br>        - name: POD_NAME<br>          valueFrom:<br>            fieldRef:<br>              fieldPath: metadata.name<br>        - name: POD_NAMESPACE<br>          valueFrom:<br>            fieldRef:<br>              fieldPath: metadata.namespace<br>        volumeMounts:<br>        - name: run<br>          mountPath: /run/flannel<br>        - name: flannel-cfg<br>          mountPath: /etc/kube-flannel/<br>      volumes:<br>        - name: run<br>          hostPath:<br>            path: /run/flannel<br>        - name: cni<br>          hostPath:<br>            path: /etc/cni/net.d<br>        - name: flannel-cfg<br>          configMap:<br>            name: kube-flannel-cfg</p>
<hr>
<p>apiVersion: apps/v1<br>kind: DaemonSet<br>metadata:<br>  name: kube-flannel-ds-s390x<br>  namespace: kube-system<br>  labels:<br>    tier: node<br>    app: flannel<br>spec:<br>  selector:<br>    matchLabels:<br>      app: flannel<br>  template:<br>    metadata:<br>      labels:<br>        tier: node<br>        app: flannel<br>    spec:<br>      affinity:<br>        nodeAffinity:<br>          requiredDuringSchedulingIgnoredDuringExecution:<br>            nodeSelectorTerms:<br>              - matchExpressions:<br>                  - key: kubernetes.io/os<br>                    operator: In<br>                    values:<br>                      - linux<br>                  - key: kubernetes.io/arch<br>                    operator: In<br>                    values:<br>                      - s390x<br>            hostNetwork: true<br>            tolerations:<br>            - operator: Exists<br>                effect: NoSchedule<br>            serviceAccountName: flannel<br>            initContainers:<br>            - name: install-cni<br>                image: quay.io/coreos/flannel:v0.12.0-s390x<br>                command:<br>                - cp<br>                args:<br>                - -f<br>                - /etc/kube-flannel/cni-conf.json<br>                - /etc/cni/net.d/10-flannel.conflist<br>                volumeMounts:<br>                - name: cni<br>                    mountPath: /etc/cni/net.d<br>                - name: flannel-cfg<br>                    mountPath: /etc/kube-flannel/<br>            containers:<br>            - name: kube-flannel<br>                image: quay.io/coreos/flannel:v0.12.0-s390x<br>                command:<br>                - /opt/bin/flanneld<br>                args:<br>                - –ip-masq<br>                - –kube-subnet-mgr<br>                resources:<br>                    requests:<br>                        cpu: “100m”<br>                        memory: “50Mi”<br>                    limits:<br>                        cpu: “100m”<br>                        memory: “50Mi”<br>                securityContext:<br>                    privileged: false<br>                    capabilities:<br>                          add: [“NET_ADMIN”]<br>                env:<br>                - name: POD_NAME<br>                    valueFrom:<br>                        fieldRef:<br>                            fieldPath: metadata.name<br>                - name: POD_NAMESPACE<br>                    valueFrom:<br>                        fieldRef:<br>                            fieldPath: metadata.namespace<br>                volumeMounts:<br>                - name: run<br>                    mountPath: /run/flannel<br>                - name: flannel-cfg<br>                    mountPath: /etc/kube-flannel/<br>            volumes:<br>                - name: run<br>                    hostPath:<br>                        path: /run/flannel<br>                - name: cni<br>                    hostPath:<br>                        path: /etc/cni/net.d<br>                - name: flannel-cfg<br>                    configMap:<br>                        name: kube-flannel-cfg</p>
<p>然后执行 kubectl apply -f kube-flannel.yml 即可</p>
<hr>
<p>Node 节点执行加入的指令即可</p>
<p>安装 K8s 过程中如果出现错误的话.</p>
<blockquote>
<p>error execution phase preflight: [preflight] Some fatal errors occurred:<br>[ERROR ImagePull]: failed to pull image k8s.gcr.io/kube-apiserver:v1.18.0: output: Error response from daemon: Get <a href="https://k8s.gcr.io/v2/" target="_blank" rel="noopener">https://k8s.gcr.io/v2/</a>: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)<br>, error: exit status 1<br>   [ERROR ImagePull]: failed to pull image k8s.gcr.io/kube-controller-manager:v1.18.0: output: Error response from daemon: Get <a href="https://k8s.gcr.io/v2/" target="_blank" rel="noopener">https://k8s.gcr.io/v2/</a>: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)<br>, error: exit status 1<br>   [ERROR ImagePull]: failed to pull image k8s.gcr.io/kube-scheduler:v1.18.0: output: Error response from daemon: Get <a href="https://k8s.gcr.io/v2/" target="_blank" rel="noopener">https://k8s.gcr.io/v2/</a>: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)<br>, error: exit status 1<br>   [ERROR ImagePull]: failed to pull image k8s.gcr.io/kube-proxy:v1.18.0: output: Error response from daemon: Get <a href="https://k8s.gcr.io/v2/" target="_blank" rel="noopener">https://k8s.gcr.io/v2/</a>: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)<br>, error: exit status 1<br>   [ERROR ImagePull]: failed to pull image k8s.gcr.io/pause:3.2: output: Error response from daemon: Get <a href="https://k8s.gcr.io/v2/" target="_blank" rel="noopener">https://k8s.gcr.io/v2/</a>: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)<br>, error: exit status 1<br>   [ERROR ImagePull]: failed to pull image k8s.gcr.io/etcd:3.4.3-0: output: Error response from daemon: Get <a href="https://k8s.gcr.io/v2/" target="_blank" rel="noopener">https://k8s.gcr.io/v2/</a>: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)<br>, error: exit status 1<br>   [ERROR ImagePull]: failed to pull image k8s.gcr.io/coredns:1.6.7: output: Error response from daemon: Get <a href="https://k8s.gcr.io/v2/" target="_blank" rel="noopener">https://k8s.gcr.io/v2/</a>: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)<br>, error: exit status 1docker tag docker.io/mirrorgooglecontainers/kube-apiserver:v1.14.0</p>
</blockquote>
<p>Helm 安装</p>
<blockquote>
<p>这里的v2.14.1 版本是可以选择的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;curl -O https:&#x2F;&#x2F;get.helm.sh&#x2F;helm-v2.14.1-linux-amd64.tar.gz</span><br></pre></td></tr></table></figure>


</blockquote>
<p>Helm 卸载 tiller 操作</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;kubectl get -n kube-system secrets,sa,clusterrolebinding -o name|grep tiller|xargs kubectl -n kube-system delete</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;kubectl get all -n kube-system -l app&#x3D;helm -o name|xargs kubectl delete -n kube-system</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>https://www.cnblogs.com/jackluo/p/10345266.html</code> 参考地址</p>
<p>低版本Helm 的 tiller 处理方法</p>
<p><code>helm init --upgrade --tiller-image cnych/tiller:v2.10.0</code></p>
<blockquote>
<p><a href="https://www.jianshu.com/p/f43f07361398https://www.jianshu.com/p/f43f07361398" target="_blank" rel="noopener">https://www.jianshu.com/p/f43f07361398https://www.jianshu.com/p/f43f07361398</a> 参考地址</p>
</blockquote>
<p>错误:</p>
<blockquote>
<p>[root@node1 ~]# helm install stable/nginx-ingress -n nginx-ingress –namespace kube-system  -f ingress-nginx.yaml<br>Error: release nginx-ingress failed: namespaces “kube-system” is forbidden: User “system:serviceaccount:kube-system:default” cannot get resource “namespaces” in API group “” in the namespace “kube-system”<br>[root@node1 ~]# </p>
</blockquote>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap源码阅读记录</title>
    <url>/2020/04/29/HashMap%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><blockquote>
<p>HashMap 是基于哈希表的Map接口.是可以使用null来做为key.不保证映射的顺序.</p>
<p>HashMap 是一种基于Key-Value的数据结构.</p>
</blockquote>
<p>​    </p>
<p><img src="" alt="[https://github.com/baoyang23/images_repository/blob/master/java/hashMap/HashMap%E7%BB%93%E6%9E%84%E5%9B%BE.png](https://github.com/baoyang23/images_repository/blob/master/java/hashMap/HashMap结构图.png)"></p>
<h3 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a>HashMap源码分析</h3><p>默认初始化容量</p>
<blockquote>
<p>static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16</p>
</blockquote>
<hr>
<p>构造函数中未指定时使用的加载因子.</p>
<blockquote>
<p>static final float DEFAULT_LOAD_FACTOR = 0.75f</p>
</blockquote>
<hr>
<p>存储数据使用的Node节点,可以理解为你Java中定义的一个类,就是这个类的next中的值,可能是下一个类似的节点，也可能是null(没有下一个指向).</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">   <span class="keyword">final</span> K key;</span><br><span class="line">   V value;</span><br><span class="line">   Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">   Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">       <span class="keyword">this</span>.hash = hash;</span><br><span class="line">       <span class="keyword">this</span>.key = key;</span><br><span class="line">       <span class="keyword">this</span>.value = value;</span><br><span class="line">       <span class="keyword">this</span>.next = next;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">       V oldValue = value;</span><br><span class="line">       value = newValue;</span><br><span class="line">       <span class="keyword">return</span> oldValue;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">           Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">           <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">               Objects.equals(value, e.getValue()))</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<hr>
<p><strong>Note: TreeNode这个内部类也是需要仔细看的。Java8中,当链表中的Node个数大于8的时候，就会转化为TreNode来进行存储Node节点.这里由于代码比较多，就不贴出来，但是对于要提升的，就要去仔细看看。</strong></p>
<hr>
<p>来看put方法，就是我们每次调用存储的方法，来看看代码层面是怎么实现。先根据key来调用hash()方法,可以看到调用hash方法后，就返回了int类型的,也就是调用hash来计算出哈希值.然后直接调用putVal方法，这才是真正的存储数据的方法.</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>注释的译文: 将指定值与此映射中的指定键相关联。如果映射先前包含键的映射，则替换旧值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> h;</span><br><span class="line">   <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>putVal 方法讲解:</strong></p>
<p>定义tab 的 Node数组, (tab = table) == null 这行代码是可以看到,全局变量的 table赋值给tab.</p>
<p>Node&lt;K,V&gt; p 的话，这里如果算出来的hash值，tab[i= ()n-1 &amp; hash] , 也就是这样代码,如果是null的话,就说明在数组tab(table)中是不存在的.反正,就说明该哈希值在数组中是已经存在的(这就是哈希冲突).</p>
<p>然后发生哈希冲突怎么办呢？</p>
<p>我们看到代码 p.hash == hash &amp;&amp; ((k = p. key) == key || (key != null &amp;&amp; key.equals(k))), 判断hash值是否相等并且二者的key的值是否相等,使用==或者equals来进行判断，如果是想相同的话,就说明 Key 已经是存在的了,覆盖掉。   </p>
<p>如果p是 TreeNode类型的话,就说明该哈希值冲突的个数已经大于8了，看到 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this,tab,hash,key,value)这行代码，点进去看就可以,这里就有之前提到的说需要看TreeNode这个类的。</p>
<p>for(int bigCount = 0;;++bigCount){} 中的代码,就是发生了put进来的key的哈希值是一样的,但是Key的值却不是一样。 e = p.next == null,如果p节点的next是Null的话,就是说明没有下一个节点,然后调用newNode来生成一个Node节点. bigCount &gt;= TREEIFY_THRESHOLD - 1 , 如果大于7的话,链表就会调用treeIfBin(tab,hash)这个方法转化为红黑树结构.</p>
<p>可以看到putVal中的方法，仔细去阅读还是比较容易理解的.</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">   Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">   <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">       n = (tab = resize()).length;</span><br><span class="line">   <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">       tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">       Node&lt;K,V&gt; e; K k;</span><br><span class="line">       <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">           ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">           e = p;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">           e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">               <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                   <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                       treeifyBin(tab, hash);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                   ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               p = e;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">           V oldValue = e.value;</span><br><span class="line">           <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">               e.value = value;</span><br><span class="line">           afterNodeAccess(e);</span><br><span class="line">           <span class="keyword">return</span> oldValue;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ++modCount;</span><br><span class="line">   <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">       resize();</span><br><span class="line">   afterNodeInsertion(evict);</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>resize() 方法讲解</strong></p>
<p>这是HashMap中进行扩容的方法.</p>
<p>int oldCap = (oldTab == null) ? 0 : oldTab.length;  拿出tab的长度,如果没有就是0(第一次初始化的时候,就是没有值1).</p>
<p>threshold 这个值,是根据你传入进来的数值,比如第一次初始化的时候，你在构造函数中传入进来的值，就会调用返回生成值并且赋值给threshold这个全局变量。</p>
<p>oldCap &gt; 0 , 看到 newThr = old &lt;&lt;&lt;1; 二倍扩容.</p>
<p>oldThr &gt; 0 , 这个 newCap = oldThr 这个值取决于threshold，目前感觉像是第一次初始化并且构造函数有传入值才是有用的.</p>
<p>否则就是使用默认的数值来进行初始化.大小确定完后,就将 newTab的值也会赋值给threshold.</p>
<p>Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</p>
<p>table = newTable;</p>
<p>for int j =0; j &lt; oldCap; ++j 中可以看出来,根据每个下标去进行迭代的，每个值有可能是 单个Node节点,也就是Node的next的值是null。 也有可能是 TreeNode类型的 。 也有可能是 Node下面的next还是有Node的。然后分别根据这三种情况,将老的数组中的值赋值给新扩容大小的数组中.</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">   Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">   <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">   <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">   <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">           threshold = Integer.MAX_VALUE;</span><br><span class="line">           <span class="keyword">return</span> oldTab;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">           newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">       newCap = oldThr;</span><br><span class="line">   <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">       newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">       newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">       newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                 (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">   &#125;</span><br><span class="line">   threshold = newThr;</span><br><span class="line">   <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">   Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">   table = newTab;</span><br><span class="line">   <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">           Node&lt;K,V&gt; e;</span><br><span class="line">           <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">               oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">               <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                   newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                   ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">               <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                   Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                   Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                   Node&lt;K,V&gt; next;</span><br><span class="line">                   <span class="keyword">do</span> &#123;</span><br><span class="line">                       next = e.next;</span><br><span class="line">                       <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                           <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                               loHead = e;</span><br><span class="line">                           <span class="keyword">else</span></span><br><span class="line">                               loTail.next = e;</span><br><span class="line">                           loTail = e;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">else</span> &#123;</span><br><span class="line">                           <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                               hiHead = e;</span><br><span class="line">                           <span class="keyword">else</span></span><br><span class="line">                               hiTail.next = e;</span><br><span class="line">                           hiTail = e;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                   <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                       newTab[j] = loHead;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                       newTab[j + oldCap] = hiHead;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> newTab;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>


</blockquote>
<p><strong>get方法讲解</strong></p>
<p>调用hash()方法，这个在pul的方法中是有提到的.我们这里主要是看getNode方法,可以看到get方法中也有tab数组(这个数组才是存储数据的). if条件,tab不为null,并且长度也是大于0的,并且根据 tab[(n-1)&amp;hash]算出来的下表在数组中的值是不为null的.先判断,hash是否相等,key对应的值是否也相等,如果是的话，直接返回first节点,first节点是在if判断条件中进行赋值了的。如果不是的话,就拿取first节点的next值,如果是TreeNode类型的话,就说明这个哈希值已经冲突8次甚至更多,然后调用TreeNode的getTreeNode()来获取节点并且返回。还有一种就是没有转化TreeNode，还是使用单链表, while(e=e.next) 可以看出来,往下继续next，就是在迭代单链表,如果满足key值相同的话,就会返回。</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123; </span><br><span class="line">   Node&lt;K,V&gt; e;</span><br><span class="line">   <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>注释译文: 返回指定键映射到的值，如果此映射不包含键的映射，则返回{@code null}。可以看到译文,如果根据Key映射到值,就返回值,如果没有映射到的话,就会返回Null.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">   Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line">   if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">       (first &#x3D; tab[(n - 1) &amp; hash]) !&#x3D; null) &#123;</span><br><span class="line">       if (first.hash &#x3D;&#x3D; hash &amp;&amp; &#x2F;&#x2F; always check first node</span><br><span class="line">           ((k &#x3D; first.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">           return first;</span><br><span class="line">       if ((e &#x3D; first.next) !&#x3D; null) &#123;</span><br><span class="line">           if (first instanceof TreeNode)</span><br><span class="line">               return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">           do &#123;</span><br><span class="line">               if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                   ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                   return e;</span><br><span class="line">           &#125; while ((e &#x3D; e.next) !&#x3D; null);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return null;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<hr>
<p><strong>containKey 方法讲解</strong></p>
<p>可以看出来判断是否包含一个key，是直接调用getNode()方法,然后根据判断是否等于null来进行返回。</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> getNode(hash(key), key) != <span class="keyword">null</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<hr>
<p>好啦,HashMap中put 和 get 理解明白即可,主要是 put 方法,这才是整个HashMap中的灵魂代码，也是必须了解的。</p>
]]></content>
      <categories>
        <category>Java源码</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadLocal源码阅读</title>
    <url>/2020/06/20/ThreadLocal_source/</url>
    <content><![CDATA[<h2 id="ThreadLocal源码阅读"><a href="#ThreadLocal源码阅读" class="headerlink" title="ThreadLocal源码阅读"></a>ThreadLocal源码阅读</h2><p>ThreadLocal 是来这个公司有过使用一次的感受,所以就学习阅读下源码。  其实Thread 这个里面,就有一个 Map(这里是用ThreadLocal内部类中实现的) , 里面的key就是 ThreadLocal, value 就是存储的值,所以一个Thread是有多个 ThreadLocal。 </p>
<hr>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>  参数部分</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The next hash code to be given out. Updated atomically. Starts at</span></span><br><span class="line"><span class="comment"> * zero.</span></span><br><span class="line"><span class="comment">   AtomicInteger 是一个线程安全的,实现原理是采用了cas.	</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode =</span><br><span class="line">    <span class="keyword">new</span> AtomicInteger();</span><br></pre></td></tr></table></figure>



<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p> set 赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*	首先获取当前线程.</span></span><br><span class="line"><span class="comment">	调用 getMap 方法, 直接调用 t.trheadLocals来获取 ThreadLocalMap。(ThreadLocalMap这里是ThreadLocal内部自己实现的类)</span></span><br><span class="line"><span class="comment">	如果map不是null的话,就进行set值,这里可以看到 set 的key是this,也就是ThreadLocal它自己.</span></span><br><span class="line"><span class="comment">	否则就是调用createMap方法,走这个方法是可以确认 currentThread中的threadLocals的值是null,所以直接new了一个进行赋值即可.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Get-方法"><a href="#Get-方法" class="headerlink" title="Get 方法"></a>Get 方法</h4><p> get 方法,获取值.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	这里可以看到,获取ThreadLocalMap,如果ThreadLocalMap的是null的话,就会走setInitialValue方法。</span></span><br><span class="line"><span class="comment">	如果有值的话,就会进行获取值并且返回.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	如果获取出来的ThreadLocalMap 不是null的话,就会进行set,这个时候set进去的值,value就是null了.</span></span><br><span class="line"><span class="comment">	如果获取出来是nulld</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T value = initialValue();</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="remove-方法"><a href="#remove-方法" class="headerlink" title="remove 方法"></a>remove 方法</h4><p>remove 方法就是获取map,如果map不是null的话,就调用m.remove(this)，根据当前this来删除.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">        m.remove(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p> ThreadLocal里面的方法也比较少,还是比较好理解的。只要弄清楚ThreadLocal和Thread是怎么在存储的,就很好的理解了。</p>
<p>注意 : 使用ThreadLocal一定要进行remove,否则容易出现内存泄漏，从而导致内存溢出。</p>
]]></content>
      <categories>
        <category>ThreadLocal</category>
      </categories>
      <tags>
        <tag>java源码</tag>
        <tag>Java锁</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis缓存知识学习</title>
    <url>/2020/04/19/redis%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h3 id="Redis-缓存知识的学习"><a href="#Redis-缓存知识的学习" class="headerlink" title="Redis 缓存知识的学习"></a>Redis 缓存知识的学习</h3><blockquote>
<p>现在缓存,消息队列,集群(集群就涉及到很多中间件)的使用或者说是学习都是必须的,也是必备的. 所以就这周就打算学习下Redis缓存方面的知识来记录。</p>
</blockquote>
<h3 id="Redis-安装-基于Linux"><a href="#Redis-安装-基于Linux" class="headerlink" title="Redis 安装(基于Linux)"></a>Redis 安装(基于Linux)</h3><blockquote>
<p>这里说下我使用的电脑环境是 Ubuntu , 所以在执行make的时候,很多gcc之类的东西是不需要安装的.</p>
</blockquote>
<p>  这里我们使用Redis 官方给出来的案例来进行安装</p>
<ol>
<li><p>wget <a href="http://download.redis.io/releases/redis-5.0.8.tar.gz" target="_blank" rel="noopener">http://download.redis.io/releases/redis-5.0.8.tar.gz</a> (<a href="https://redis.io/download" target="_blank" rel="noopener">https://redis.io/download</a>) 使用wget 或者去官网上下载都是可以的。</p>
</li>
<li><p>tar zxvf redis-5.0.8.tar.gz   这里使用官方目前提供的来进来下载。</p>
</li>
<li><p>cd redis-5.0.8   目录下面  然后执行 make (看你的权限是不是要执行 sudo make) </p>
</li>
<li><p>cd src 下面  sudo ./redis-server</p>
</li>
</ol>
<hr>
<p>启动成功界面</p>
<p>13827:C 19 Apr 2020 14:48:09.023 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo<br>13827:C 19 Apr 2020 14:48:09.023 # Redis version=5.0.8, bits=64, commit=00000000, modified=0, pid=13827, just started<br>13827:C 19 Apr 2020 14:48:09.023 # Warning: no config file specified, using the default config. In order to specify a config file use ./redis-server /path/to/redis.conf<br>13827:M 19 Apr 2020 14:48:09.024 * Increased maximum number of open files to 10032 (it was originally set to 1024).<br>           <em>.</em><br>      <em>.-``__ ‘’-.</em><br> <em>.-``    <code>.</code></em>.  ‘’-._           Redis 5.0.8 (00000000/0) 64 bit<br>.-<code>.-```.  ```\/    _.,_ &#39;&#39;-._                                   
(    &#39;      ,       .-`  | `,    )     Running in standalone mode
|`-._`-...-` __...-.</code>-.<em>|’<code>_.-&#39;|     Port: 6379
|</code>-.</em>   <code>._    /     _.-&#39;    |     PID: 13827</code>-._    <code>-._</code>-./  <em>.-‘    _.-‘<br>|<code>-._</code>-.</em>    <code>-.__.-&#39;    _.-&#39;_.-&#39;|                                  
|</code>-.<em>`-.</em>        <em>.-‘</em>.-‘    |           <a href="http://redis.io" target="_blank" rel="noopener">http://redis.io</a><br><code>-._</code>-.<em>`-.__.-‘</em>.-‘    <em>.-‘<br>|<code>-._</code>-.</em>    <code>-.__.-&#39;    _.-&#39;_.-&#39;|                                  
|</code>-.<em>`-.</em>        <em>.-‘</em>.-‘    |<br><code>-._</code>-.<em>`-.__.-‘</em>.-‘    <em>.-‘<br> `-.</em>    <code>-.__.-&#39;    _.-&#39;</code>-._        <em>.-‘<br>         `-._</em>.-‘                                      </p>
<hr>
<p>13827:M 19 Apr 2020 14:48:09.024 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.<br>13827:M 19 Apr 2020 14:48:09.024 # Server initialized<br>13827:M 19 Apr 2020 14:48:09.024 # WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add ‘vm.overcommit_memory = 1’ to /etc/sysctl.conf and then reboot or run the command ‘sysctl vm.overcommit_memory=1’ for this to take effect.<br>13827:M 19 Apr 2020 14:48:09.024 # WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command ‘echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled’ as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.<br>13827:M 19 Apr 2020 14:48:09.024 * Ready to accept connections</p>
<hr>
<p>   然后就可以看到 redis的启动界面, 然后再开一个黑窗口,也同样是在src下面, sudo ./redis-cli  就可以连上(这里我都是在同一台server上,ip,port什么都是默认的, 如果你启动有修改的话,那么连接的时候,这些配置也是需要进行修改的)</p>
<p><strong>对于 Redis的安装,熟悉Linux的朋友还是很快的。</strong></p>
<hr>
<h3 id="Redis-数据结构"><a href="#Redis-数据结构" class="headerlink" title="Redis 数据结构"></a>Redis 数据结构</h3><ol>
<li><p>字符串 String</p>
<blockquote>
<p>127.0.0.1:6379[1]&gt; set name yang<br>OK<br>127.0.0.1:6379[1]&gt; get name<br>“yang”</p>
<p>可以看到对于 String 存储还是常规的</p>
</blockquote>
</li>
<li><p>字典 Hash</p>
<blockquote>
<p>127.0.0.1:6379[1]&gt; HSET json1 name gavin age 18<br>(integer) 2</p>
<p>127.0.0.1:6379[1]&gt; hget json1 name<br>“gavin”<br>127.0.0.1:6379[1]&gt; hget json1 age<br>“18”</p>
<p> 对于Hash 存储的基本操作,基于还是看你个人想怎么存储. </p>
<p> 127.0.0.1:6379[1]&gt; HEXISTS json1 json<br>(integer) 0<br>127.0.0.1:6379[1]&gt; HEXISTS json1 name<br>(integer) 1</p>
<p> 这是判断这个key是否存在</p>
</blockquote>
</li>
<li><p>列表List</p>
<blockquote>
<p>127.0.0.1:6379[1]&gt; lpush list1 1,2,3,4,5,6,7<br>(integer) 1<br>127.0.0.1:6379[1]&gt; lpush list1 8 9 10 11 12 13 14<br>(integer) 8<br>127.0.0.1:6379[1]&gt; LRANGE list1 0 11<br>1) “14”<br>2) “13”<br>3) “12”<br>4) “11”<br>5) “10”<br>6) “9”<br>7) “8”<br>8) “1,2,3,4,5,6,7”</p>
<p>可以看出lpush 对于添加的顺序，最先添加的值是在最后面的。</p>
<p>127.0.0.1:6379[1]&gt; RPUSH list1 latsone<br>(integer) 9</p>
<p>127.0.0.1:6379[1]&gt; LRANGE list1 0 13<br>1) “14”<br>2) “13”<br>3) “12”<br>4) “11”<br>5) “10”<br>6) “9”<br>7) “8”<br>8) “1,2,3,4,5,6,7”<br>9) “latsone”</p>
<p>rpush 就是直接在最尾部进行追加.</p>
<p>lpop key(lits1 对应自己的key) : 返回并删除指定 Key 的链表中的第一个元素</p>
<p>rpop key: 返回并删除指定 Key 的链表中的最后一个元素,即尾元素 </p>
</blockquote>
</li>
<li><p>集合Set</p>
<blockquote>
<p>127.0.0.1:6379[1]&gt; sadd set1 a b c<br>(integer) 3<br>127.0.0.1:6379[1]&gt; sadd set z<br>(integer) 1<br>127.0.0.1:6379[1]&gt; SMEMBERS set1<br>1) “b”<br>2) “a”<br>3) “c”<br>127.0.0.1:6379[1]&gt; SISMEMBER set1 c<br>(integer) 1<br>127.0.0.1:6379[1]&gt; SISMEMBER set1 x<br>(integer) 0<br>127.0.0.1:6379[1]&gt; SMEMBERS set1<br>1) “b”<br>2) “a”<br>3) “c”<br>127.0.0.1:6379[1]&gt; SREM set1 a<br>(integer) 1<br>127.0.0.1:6379[1]&gt; SMEMBERS set1<br>1) “b”<br>2) “c”</p>
<p>sadd  是进行添加</p>
<p>smembers  进行查看该集合中数据</p>
<p>sismember 判断集合中是否有该值,如果是有的话,就会返回1,如果是没有的话,就会返回0</p>
<p>srem 是删除集合中某个元素. 如果存在删除就返回1,如果不存在删除就会返回0 </p>
</blockquote>
</li>
<li><p>有序集合 ZSet</p>
<blockquote>
<p>127.0.0.1:6379[1]&gt; SREM set1 add<br>(integer) 0<br>127.0.0.1:6379[1]&gt; zadd scores 90 ‘Chinese’<br>(integer) 1<br>127.0.0.1:6379[1]&gt; zadd scores 94 ‘math’<br>(integer) 1<br>127.0.0.1:6379[1]&gt; zadd scores 96 ‘english’<br>(integer) 1<br>127.0.0.1:6379[1]&gt; ZRANGE scores 0 -1<br>1) “Chinese”<br>2) “math”<br>3) “english”<br>127.0.0.1:6379[1]&gt; ZRANGE scores 0 -1 withscores<br>1) “Chinese”<br>2) “90”<br>3) “math”<br>4) “94”<br>5) “english”<br>6) “96”<br>127.0.0.1:6379[1]&gt; zadd scores 88 ‘matha’<br>(integer) 1<br>127.0.0.1:6379[1]&gt; ZRANGE scores 0 -1 withscores<br>1) “matha”<br>2) “88”<br>3) “Chinese”<br>4) “90”<br>5) “math”<br>6) “94”<br>7) “english”<br>8) “96”</p>
<p>zset 的基本操作.等到你工作需要使用的时候,可以在权衡来具体使用</p>
</blockquote>
<hr>
</li>
</ol>
<p>   还有一些数据结果，对于平常的项目或者需求是很少使用到的.这里也列举出来,做一个大概的说明.</p>
<ol>
<li><p>HyperLogLog</p>
<blockquote>
<p>HyperLogLog 是用来做 <strong>基数统计</strong> 的算法. 优点 : 再输入元素的数量或者体积非常非常大的时候时候,计算基数所需要的空间总是固定的,并且很小.</p>
<p>Redis 中 HyperLogLog 键只需花费12KB内存,就可以计算接近 2^64 个不同的元素的基数.</p>
<p>127.0.0.1:6379[1]&gt; PFADD pf1 1 2 3 4 1 2 3 2 2 2 2<br>(integer) 1<br>127.0.0.1:6379[1]&gt; PFCOUNT pf1<br>(integer) 4<br>127.0.0.1:6379[1]&gt; pfadd m2 3 3 3 4 4 4 5 5 5 6 6 6 1<br>(integer) 1<br>127.0.0.1:6379[1]&gt; PFMERGE mergeN pf1 m2<br>OK<br>127.0.0.1:6379[1]&gt; PFCOUNT mergeN<br>(integer) 6</p>
<p>从结果可以看出, HyperLogLog 就是对进行统计.</p>
<p>实用场景 :  统计注册Ip个数,统计每日访问IP数 等数有关</p>
</blockquote>
</li>
<li><p>Geo</p>
<blockquote>
<p>127.0.0.1:6379[1]&gt; GEOADD cities:locations 117.12 39.08 tianjin 114.29 38.02 shijiazhuang 118.01 39.08 tangshan 115.29 38.51 baoding<br>(integer) 4</p>
<p>127.0.0.1:6379[1]&gt; GEOPOS cities:locations tianjin<br>1) 1) “117.12000042200088501”<br>  2) “39.0800000535766543”<br>127.0.0.1:6379[1]&gt; GEOPOS cities:locations tianjin baoding<br>1) 1) “117.12000042200088501”<br>  2) “39.0800000535766543”<br>2) 1) “115.28999894857406616”<br>  2) “38.50999956342798924”</p>
<p>geoadd 是存储</p>
<p>geopos 是根据地名来进行存储数据</p>
<p>127.0.0.1:6379[1]&gt; geodist cities:locations tianjin tangshan km<br>“76.8434”<br>127.0.0.1:6379[1]&gt; geodist cities:locations tianjin tangshans km<br>(nil)</p>
<p>km 是计算具体的单位 : m(米),km(千米),mi(英里),ft(英尺)</p>
<p>参考连接(<a href="https://blog.csdn.net/qq_34206560/article/details/91049218" target="_blank" rel="noopener">https://blog.csdn.net/qq_34206560/article/details/91049218</a>)</p>
</blockquote>
</li>
<li><p>Pub/Sub</p>
<blockquote>
<p>开启二个 黑窗口 来连接 redis</p>
<p>窗口一 : 对CCTV 进行订阅</p>
<p>127.0.0.1:6379&gt; subscribe CCTV<br>Reading messages… (press Ctrl-C to quit)<br>1) “subscribe”<br>2) “CCTV”<br>3) (integer) 1</p>
<p>1) “message”<br>2) “CCTV”<br>3) “\xe6\x88\x91\xe6\x98\xafGavin”</p>
<p>1) “message”<br>2) “CCTV”<br>3) “Hello Gavin”</p>
<p>窗口二 :  对CCTV 进行写</p>
<p>127.0.0.1:6379[1]&gt; publish CCTV “我是Gavin”<br>(integer) 1<br>127.0.0.1:6379[1]&gt; publish CCTV “Hello Gavin”<br>(integer) 1</p>
<p>要先开启 订阅，不然发送的消息会丢失。</p>
</blockquote>
</li>
</ol>
<hr>
<p>还有一个更需要了解的知识,是更加必不可少的.</p>
<ul>
<li>Redis Module </li>
<li>BloomFilter</li>
<li>RedisSearch</li>
<li>Redis-ML</li>
</ul>
<p>等等</p>
<hr>
<h3 id="Redis-实现分布式锁"><a href="#Redis-实现分布式锁" class="headerlink" title="Redis 实现分布式锁"></a>Redis 实现分布式锁</h3><ul>
<li><p>获取锁的时候,如果先用 setnx 来争取到锁,再给expire 的锁来设置过期时间 防止锁忘记释放. 如果在expire之前,程序出现异常的话,那么这个setnx获取到的锁就无法被释放掉.</p>
<p>如果是正常获获取锁并且设置过期时间</p>
<hr>
<p>/**</p>
<ul>
<li><p>尝试获取 分布式锁</p>
</li>
<li><p>我们使用key来当锁，因为key是唯一的。</p>
</li>
<li><p>原因就是我们在上面讲到可靠性时，分布式锁要满足第四个条件解铃还须系铃人，通过给value赋值为requestId，</p>
</li>
<li><p>我们就知道这把锁是哪个请求加的了，在解锁的时候就可以有依据。requestId可以使用UUID.randomUUID().toString()方法生成<br>*</p>
</li>
<li><p>这个参数我们填的是NX，意思是SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作</p>
</li>
<li><p>这个参数我们传的是PX，意思是我们要给这个key加一个过期的设置，具体时间由第五个参数决定</p>
</li>
<li><p>设置超时时期</p>
</li>
<li><p>@param jedis</p>
</li>
<li><p>@param localKey</p>
</li>
<li><p>@param requestId  请求表示</p>
</li>
<li><p>@param expireTime 超时时间</p>
</li>
<li><p>@return<br>*/<br>public static boolean tryGetDistributedLock(Jedis jedis,String localKey,String requestId,int expireTime){<br> return LOCK_SUCCESS.equalsIgnoreCase(jedis.set(localKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime));<br>}</p>
<hr>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>释放锁 </p>
<hr>
<p> /**</p>
<ul>
<li><p>释放锁</p>
</li>
<li><p>requestId : 请求标识</p>
</li>
<li><p>@param jedis</p>
</li>
<li><p>@param localKey</p>
</li>
<li><p>@param requestId</p>
</li>
<li><p>@return<br>*</p>
</li>
<li><p>不能直接使用 jedis.del(lockKey) 来删除锁,可能当前进来的锁并不是 先前判断出锁的拥有者<br>*<br>*/<br>public static boolean releaseDistributedLock(Jedis jedis,String localKey,String requestId){<br> String script = “if redis.call(‘get’, KEYS[1]) == ARGV[1] then return redis.call(‘del’, KEYS[1]) else return 0 end”;<br> Object result = jedis.eval(script, Collections.singletonList(localKey), Collections.singletonList(requestId));<br> return RELEASE_SUCCESS.equals(result);</p>
<p>}</p>
<hr>
</li>
</ul>
</li>
</ul>
<ul>
<li>如果Redis的Key需要设置同一时期过去,key是很多的话,redis可能会出现短暂的卡顿现象.</li>
</ul>
<hr>
<h3 id="Redis-获取-Key-技巧"><a href="#Redis-获取-Key-技巧" class="headerlink" title="Redis 获取 Key 技巧"></a>Redis 获取 Key 技巧</h3><p>抛出问题 :   <strong>加入Redis 里面有 一亿个Key,其中有10w个key是以某个固定的的已知前缀开头,如何将它们全部找出来?</strong></p>
<p>使用keys指令可以扫出指定模式的key列表。 X </p>
<p>使用scan指令来获取key列表。  Y</p>
<p>这个时候你要回答redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。</p>
<hr>
<h3 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h3><p>​         默认情况下, Redis 将内存数据库快照保存到dump.rdb二进制文件中. </p>
<ul>
<li><p>RDB :  配置文件 save 60 1000 . 除了在配置文件中使用save,还可以手动执行save来生成RDB快照文件.save 是同步命令,bgsave是异步命令, bgsave 会从 redis 主进程fork出一个子进程来专门生成rdb二进制文件</p>
<blockquote>
<p>127.0.0.1:6379[1]&gt; save<br>OK        </p>
</blockquote>
</li>
<li><p>AOF : 配置文件中 appendonly : yes 修改为yes.</p>
<blockquote>
<p>appendfsync  always: 每次有新命令追加到aof文件中就执行一个持久化指令,非常慢但是安全</p>
<p>appendfsync  everysec : 每次执行一次持久化,足够快(和使用rdb持久化差不多) 并且故障时只丢失1s的数据</p>
<p>appendfsync no : 从不持久化</p>
</blockquote>
</li>
</ul>
<hr>
<h3 id="Pipeline-学习"><a href="#Pipeline-学习" class="headerlink" title="Pipeline 学习"></a>Pipeline 学习</h3><p>​      pipeline 可以将多次 IO 往返的时间缩减为一次,前提是pipeline执行的指令之间没有因果关系.</p>
<hr>
<p>package com.yang.basicjavacache.redis.test;</p>
<p>import redis.clients.jedis.Jedis;<br>import redis.clients.jedis.Pipeline;</p>
<p>import java.util.HashMap;<br>import java.util.Map;</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>*<PRE><br>*</p>
<ul>
<li>File Name       : </li>
<li></li>
<li>Creation Date   : 20-4-19</li>
<li></li>
<li>Author          : Gavin</li>
<li></li>
<li>Purpose         : </li>
<li></li>
<li>History         : </li>
<li></li>
<li></PRE></li>
<li><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</li>
</ul>
<p>public class PipelineTestMain {</p>
<pre><code>public static void main(String[] args) {

    Jedis redis = new Jedis(&quot;192.168.18.141&quot;, 6379);
    redis.auth(&quot;123456&quot;);
    Map&lt;String, String&gt; data = new HashMap&lt;String, String&gt;();
    redis.select(8);
    redis.flushDB();
    long start = System.currentTimeMillis();
    for (int i = 0; i &lt; 1000000; i++) {
        data.clear();
        data.put(&quot;k_&quot; + i, &quot;v_&quot; + i);
        redis.hmset(&quot;key_&quot; + i, data);
    }
    long end = System.currentTimeMillis();
    System.out.println(&quot;    共插入:[&quot; + redis.dbSize() + &quot;]条 .. &quot;);
    System.out.println(&quot;1,未使用PIPE批量设值耗时&quot; + (end - start) / 1000 + &quot;秒..&quot;);

    redis.select(8);
    redis.flushDB();
    Pipeline pipe = redis.pipelined();
    start = System.currentTimeMillis();
    for (int i = 0; i &lt; 1000000; i++) {
        data.clear();
        data.put(&quot;k_&quot; + i, &quot;v_&quot; + i);
        pipe.hmset(&quot;key_&quot; + i, data); //将值封装到PIPE对象，此时并未执行，还停留在客户端
    }
    pipe.sync();
    end = System.currentTimeMillis();
    System.out.println(&quot;    PIPE共插入:[&quot; + redis.dbSize() + &quot;]条 .. &quot;);
    System.out.println(&quot;2,使用PIPE批量设值耗时&quot; + (end - start) / 1000 + &quot;秒 ..&quot;);
}</code></pre><p>}</p>
<blockquote>
<p>   共插入:[1000000]条 ..<br>1,未使用PIPE批量设值耗时14秒..<br>   PIPE共插入:[1000000]条 ..<br>2,使用PIPE批量设值耗时1秒 ..</p>
<p>从执行的结果来看的，这中间的时间差别还是很大的.</p>
</blockquote>
<p>Pipeline 管道技术,指的是客户端可以发送多个请求到服务端,过程中不需要等待请求的回复,在最后一次并读结果即可.</p>
<hr>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>关于我BaoYang</title>
    <url>/2019/10/07/%E5%85%B3%E4%BA%8E%E6%88%91/</url>
    <content><![CDATA[<p>这里用于记录个人学习和生活的博客;使用的是Github + Hexo 来搭建的，由于是第一次使用,在很多方面都不是很懂，后续会慢慢的来更新这些信息。</p>
<p>最近犯了一个很严重的错误,让我严重的意识到一些态度的问题对于个人来说还是很重要的。如果不是这些事,也许我还是无法很快速的成长，也许给我现在的感触最深的几个地方就是.我为什么会有这种错误的出现?当出现这种错误后,又是因为我个人不能很好的处理掉乱七八糟的.</p>
<p>2019-10-17  已经有好几天没有提交代码上github，提心吊胆的感觉也是让我觉得很难受。有些错误,我相信我自己以后是不会再出现的了.</p>
<p>2019-10-22 坚持使用csdn来记录技术或者博客等,这里的博客希望更多的总结或者文章的汇总等.加油,给自己.</p>
<p>个人 : BaoYang , Java爱好者,虽然平时也会捣鼓一些其他的东西,毕竟刚刚工作对一些新的东西有时候或者说是居多的时候,总是会充满一些好奇感忍不住去研究下它的好处或者使用啥的啊。</p>
<p><a href="https://blog.csdn.net/by_yangge" target="_blank" rel="noopener">https://blog.csdn.net/by_yangge</a> csdn博客地址也是用于记录一些个人的学习东西或者遇见的错误记录等问题。关于写博客或者记录一下个人的状态等信息,我个人虽然也是刚刚开始,更多的时候,我也是希望我可以长期的坚持下来记录学习和博客的记载等. 也是看个人和 贵在坚持这点吧.</p>
]]></content>
      <categories>
        <category>关于个人的</category>
      </categories>
      <tags>
        <tag>关于我</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring源码阅读日记</title>
    <url>/2020/01/16/Spring%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="导入Spring"><a href="#导入Spring" class="headerlink" title="导入Spring"></a>导入Spring</h3><ol>
<li><p>从github上clone Spring的源码到本地。</p>
<p>好处 : 可以进行代码的修改和打入备注。当你看到某个方法,不是很明白的时候,你可以进行注释掉debug执行,看下具体的效果。最好是能从github上下载出来，在本地进行编译下即可。</p>
</li>
<li><p>准备 JDK , Gradle 等环境。其中可能会遇见不少问题。需要耐心百度下或者看下错误具体的原因。</p>
</li>
<li><p>遇见的错误 : </p>
<blockquote>
<p> <a href="https://blog.csdn.net/m0_37798534/article/details/79584031" target="_blank" rel="noopener">https://blog.csdn.net/m0_37798534/article/details/79584031</a></p>
</blockquote>
</li>
</ol>
<h3 id="创建Project"><a href="#创建Project" class="headerlink" title="创建Project"></a>创建Project</h3><ul>
<li><p>在编译的Spring项目中创建一个自己的project.</p>
</li>
<li><p>引入 spring-context 的依赖,就可以debug进行操作</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Spring源码</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反射学习</title>
    <url>/2020/07/01/java_reflect_1/</url>
    <content><![CDATA[<h4 id="题记"><a href="#题记" class="headerlink" title="题记"></a>题记</h4><p>​     最近在看Spring源码的时候, 可以看到在加载类等的时候,都是大量使用的反射。估摸着MyBatis这种框架,其内部也是会大量的使用反射。所以看得出来反射在第三方的框架中使用是非常多的,于是说学习反射技术是很有必要的，不论是你写代码造轮子还是去理解第三方框架的底层实现.</p>
<p>​    话不多bb,直接上代码看看是个什么操作.</p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>我们这里写一个简单的pojo类,也就是我们经常使用的.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">public</span> String age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(Integer id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"User说"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然后接着在写一个启动的Main类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserClazzMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User u = <span class="keyword">new</span> User();</span><br><span class="line">        <span class="comment">// 获取类的所有的构造方法</span></span><br><span class="line">        Constructor&lt;?&gt;[] constructors = u.getClass().getConstructors();</span><br><span class="line">        System.out.println(Arrays.asList(constructors).toString());</span><br><span class="line">        <span class="comment">// 根据传入进去的参数类型,获取出类的构造方法.</span></span><br><span class="line">        Constructor&lt;? extends User&gt; constructor = u.getClass().getConstructor(Integer<span class="class">.<span class="keyword">class</span>, <span class="title">String</span>.<span class="title">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印结果:[public com.iyang.bootbasicio.pojo.User(), public com.iyang.bootbasicio.pojo.User(java.lang.Integer,java.lang.String)],</span></span><br><span class="line"><span class="comment">//可以看到这是一个获取类的构造方法的.</span></span><br></pre></td></tr></table></figure>



<p>调用反射获取方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserClazzMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        User u = <span class="keyword">new</span> User();</span><br><span class="line">        <span class="comment">// 可以看到获取出来的全部方法,不仅仅包含我们写的,还有Object中的notify等方法.</span></span><br><span class="line">        Method[] methods = u.getClass().getMethods();</span><br><span class="line">        System.out.println(Arrays.asList(methods).toString());</span><br><span class="line">        <span class="comment">// 根据方法的名字来过去我们特定的方法.</span></span><br><span class="line">        Method method = u.getClass().getMethod(<span class="string">"say"</span>);</span><br><span class="line">        System.out.println(method.toString());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//getDeclaredMethods方法仅仅只获取除了我们这个类里面的方法,并没有获取全部的方法(也就是不包括Object的).</span></span><br><span class="line">        Method[] declaredMethods = u.getClass().getDeclaredMethods();</span><br><span class="line">        System.out.println(Arrays.asList(declaredMethods).toString());</span><br><span class="line">        <span class="comment">// 这里依然是获取我们自己写的方法</span></span><br><span class="line">        Method say = u.getClass().getDeclaredMethod(<span class="string">"say"</span>);</span><br><span class="line">        System.out.println(say.toString());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这样我们就可以调用了user的say方法</span></span><br><span class="line">        Method say = u.getClass().getDeclaredMethod(<span class="string">"say"</span>);</span><br><span class="line">        say.invoke(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">[<span class="keyword">public</span> <span class="keyword">void</span> com.iyang.bootbasicio.pojo.User.setId(java.lang.Integer), <span class="keyword">public</span> <span class="keyword">void</span> com.iyang.bootbasicio.pojo.User.say(), <span class="keyword">public</span> java.lang.String com.iyang.bootbasicio.pojo.User.getName(), <span class="keyword">public</span> <span class="keyword">void</span> com.iyang.bootbasicio.pojo.User.setName(java.lang.String), <span class="keyword">public</span> java.lang.Integer com.iyang.bootbasicio.pojo.User.getId(), <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> java.lang.Object.wait(<span class="keyword">long</span>,<span class="keyword">int</span>) <span class="keyword">throws</span> java.lang.InterruptedException, <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> java.lang.Object.wait(<span class="keyword">long</span>) <span class="keyword">throws</span> java.lang.InterruptedException, <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> java.lang.Object.wait() <span class="keyword">throws</span> java.lang.InterruptedException, <span class="keyword">public</span> <span class="keyword">boolean</span> java.lang.Object.equals(java.lang.Object), <span class="keyword">public</span> java.lang.String java.lang.Object.toString(), <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> java.lang.Object.hashCode(), <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> java.lang.Class java.lang.Object.getClass(), <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> java.lang.Object.notify(), <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> java.lang.Object.notifyAll()]</span><br><span class="line">----------------------------</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> com.iyang.bootbasicio.pojo.User.say()</span><br></pre></td></tr></table></figure>



<p> 调用获取字段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserClazzMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        User u = <span class="keyword">new</span> User();</span><br><span class="line">        <span class="comment">//获取全部的字段,是public修饰的字段,private修饰的是获取不到的.</span></span><br><span class="line">        Field[] fields = u.getClass().getFields();</span><br><span class="line">        System.out.println(Arrays.asList(fields).toString());</span><br><span class="line">        <span class="comment">//获取字段,私有的不能获取,会抛出异常,只能获取public修饰的字段.</span></span><br><span class="line">        Field field = u.getClass().getField(<span class="string">"age"</span>);</span><br><span class="line">        System.out.println(field.toString());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取全部的字段,private修饰的也是可以获取出来的</span></span><br><span class="line">        Field[] declaredFields = u.getClass().getDeclaredFields();</span><br><span class="line">        System.out.println(Arrays.asList(declaredFields).toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据字段的名字获取字段,不管什么修饰的,都是可以获取出来的.</span></span><br><span class="line">        Field name = u.getClass().getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">        System.out.println(name.toString());</span><br><span class="line">       &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<p>获取注解:</p>
<p>我们先定义二个注解, 然后记得加在User类上. GavinYang 和 PeterWong 这二个注解是可以加在类上的, GavinYangFiledAnno是加在字段上面的.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> GavinYang &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">lwf</span><span class="params">()</span> <span class="keyword">default</span> "lwf"</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> PeterWong &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> "peterWong"</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.FIELD&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> GavinYangFiledAnno &#123;</span><br><span class="line">    <span class="function">String <span class="title">desc</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// 从结果来看,获取注解还是蛮顺利的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        User u = <span class="keyword">new</span> User();</span><br><span class="line">        <span class="comment">// 获取这个类上面的注解</span></span><br><span class="line">        Annotation[] annotations = u.getClass().getAnnotations();</span><br><span class="line">        System.out.println(Arrays.asList(annotations).toString());</span><br><span class="line">        <span class="comment">// 根据注解名字获取,可以看到返回的也直接是注解的Obejct了</span></span><br><span class="line">        GavinYang gavinYang = u.getClass().getAnnotation(GavinYang<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(gavinYang.toString());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取字段上面使用的注解.</span></span><br><span class="line">        Field field = u.getClass().getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">        Annotation[] fieldAnnotations = field.getAnnotations();</span><br><span class="line">        System.out.println(Arrays.asList(fieldAnnotations).toString());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">[<span class="meta">@com</span>.iyang.bootbasicio.pojo.GavinYang(lwf=baoyang), <span class="meta">@com</span>.iyang.bootbasicio.pojo.PeterWong(name=gavinyang)]</span><br><span class="line"><span class="meta">@com</span>.iyang.bootbasicio.pojo.GavinYang(lwf=baoyang)     </span><br><span class="line">[<span class="meta">@com</span>.iyang.bootbasicio.pojo.GavinYangFiledAnno(desc=秒啊)]</span><br></pre></td></tr></table></figure>



<h4 id="小站一下"><a href="#小站一下" class="headerlink" title="小站一下"></a>小站一下</h4><p>UserService 无参构造方法 User说使用依赖注入完成一个简单的注入</p>
<p>认一下Spring写一个差不多的注入注解. 在写一个虚假的 UserService,当然了,我们这里先不使用扫描,就使用简单的UserServcie去操作即可.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.FIELD&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> GavinYangAutowired &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">alias</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GavinYangAutowired</span></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"UserService 无参构造方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        user.say();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>UserClassMain 类来启动发车 , 这里看结果是可以成功的启动 UserService 并且也是用hello方法来调用user的say,都是成功. 但是真实的框架复杂程度不是这几行就可以ok了的. 这只是一个简单易学的demo.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserClazzMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        UserService u  = <span class="keyword">new</span> UserService();</span><br><span class="line">        Field[] fields = u.getClass().getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span>(Field f : fields)&#123;</span><br><span class="line">            GavinYangAutowired autowired = f.getDeclaredAnnotation(GavinYangAutowired<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span>(autowired != <span class="keyword">null</span>)&#123;</span><br><span class="line">                Class&lt;?&gt; fType = f.getType();</span><br><span class="line">                Constructor&lt;?&gt; typeConstructor = fType.getConstructor();</span><br><span class="line">                Object instance = typeConstructor.newInstance();</span><br><span class="line"></span><br><span class="line">                f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                f.set(u,instance);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        u.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserService 无参构造方法</span></span><br><span class="line"><span class="comment">// User说</span></span><br></pre></td></tr></table></figure>



<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>可以看到反射的功能还是蛮强大的, 但是项目里面一般是CRUD,目前也没有什么特别的地方看到使用反射的情况比较多.就是最近一直看Spring源码中,是可以看到有大量使用反射的情况.</p>
]]></content>
      <categories>
        <category>Java源码</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>深入了解JVM阅读笔记</title>
    <url>/2020/04/18/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3JVM%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="深入理解JVM阅读笔记"><a href="#深入理解JVM阅读笔记" class="headerlink" title="深入理解JVM阅读笔记"></a>深入理解JVM阅读笔记</h3><ol>
<li><p>个人认为学习JVM是对每个学习(深入)JAVA的人是一个必备的知识。</p>
</li>
<li><p>同时JVM里面的知识也不是一遍就可以学习好的，是要经过反复的阅读和自己的理解。肯定还要带有一定的项目实战经历(但是这个一般的情况都不是很容易遇见)。  </p>
<hr>
</li>
</ol>
<h3 id="Java内存区域笔记"><a href="#Java内存区域笔记" class="headerlink" title="Java内存区域笔记"></a>Java内存区域笔记</h3><ol>
<li><p>程序计数器: </p>
<p> 程序计数器是一块较小的内存,可以看成当前线程所执行的字节码的行号指示器.字节码解释器工作是通过改变计数器的值来选取吓一条需要执行的字节码,分支,循环,跳转,异常处理,线程恢复等基础功能都需要依赖这个计数器来完成.</p>
<p>  如果线程正在执行的是一个JAVA方法,这个计数器记录的是正在执行的虚拟机字节码指令地址,如果执行的是Native方法,这个计数器的值就是空(Undefind).此内存区域是唯一一个在JAVA虚拟机规范中没有规定任    OutOfMemoryError情况的区域</p>
</li>
<li><p>Java虚拟机栈</p>
<p>​        与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p>
<p>​       局部变量表存放了编译可知的各种基本类型(boolean,byte,char,short,int,float,long,double),对象引用(reference类型,它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型)    </p>
<p>​       在JAVA虚拟机规范中,对这个区域的规定了二种异常情况,如果线程请求的栈深度大于虚拟机所允许的深度,将会跑出来StackOverflowError异常,如果虚拟机栈可以动态扩展,如果扩展的是无法申请到足够的内存,就会抛出OutOfMeneryError异常</p>
</li>
</ol>
<p>   ​       虚拟机栈是Java执行方法的内存模型。每个方法被执行的时候，都会创建一个栈帧，当把栈帧压入栈，当方法正常返回或者抛出未捕获的异常时，栈帧就会出栈。</p>
<p>   ​       栈帧:  栈帧存储方法的相关信息，包含局部变量数表，返回值，操作数栈，动态链接。</p>
<p>   ​                  局部变量表:  包含了方法执行过程中的所有变量。局部变量数组所需要的空间在编译期间完成分配，在方法运行期间不会改变局部变量数组大小。</p>
<p>   ​                  返回值: 如果有返回值的话,压入调用者栈帧中的操作数栈中，并且把PC的值指向 方法调用指令 后面的一条指令地址。</p>
<p>   ​                  操作数栈:  操作变量的内存模型。操作数栈的最大深度在编译的时候已经确定（写入方法区Code属性的max_stacks项中）。操作数栈的元素可以是任意JAVA类型。32位数据占用栈空间为1，64位数据占用栈空间为6。方法刚开始执行的时候，栈是空的，当方法执行过程中，各种字节码指令往栈中存取数据。</p>
<p>   ​                  动态链接:  每个栈帧都持有在运行常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程的动态链接。</p>
<ol start="3">
<li><p>本地方法栈</p>
<p>​       本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。在虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常</p>
<p>​      调用本地Native的内存模型</p>
<p>​      线程独享</p>
</li>
<li><p>Java堆</p>
<p>​    Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块.Java堆是被所有线程共享的一块内存区域.此内存区域的唯一目的就是存放对象实例,几乎所有的对象实例都在这里分配.所有的对象实例以及数组都要在堆上分配,但是随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了`</p>
<p>​    Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆。从内存回收的角度来看，由于现在收集器基本都采用分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。从内存分配的角度来看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。不过无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。</p>
<p>​    当前主流的虚拟机都是按照可扩展来实现的(通过-Xmx 和 -Xms控制)。如果在堆中没有内存完成实例分配，堆中没有内存完成实例配置，并且堆也无法再扩展时，将会抛出来OurOfMemoryError异常。</p>
</li>
<li><p>方法区</p>
<p>  方法区与Java堆一样,是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。</p>
<p>  多人都更愿意把方法区称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已，这样HotSpot的垃圾收集器可以像管理Java堆一样管理这部分内存。（Java8 中好像永久代换了名字）</p>
<p>​    根据虚拟机规定，当方法区无法满足内存分配的需求时，将会抛出OutOfMemoryError异常。</p>
</li>
<li><p>运行时常量池</p>
<p>​        运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p>
<p>​        运行时常量池相对于Class文件常量池的另外一个重要特性时具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。</p>
<p>​        运行时常量池时方法区的一部分，自然受到方法区内存限制,当常量池无法再申请到内存时就会抛出OutOfMemeryError异常。</p>
</li>
<li><p>直接内存</p>
<p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现，所以我们放到这里一起讲解。</p>
</li>
</ol>
<p>总结 :  对于Java内存区域的知识点大致是这样，但是每个点都是要深入进去了解的。这里是摘抄书籍的内容来做笔记。后期再看的时候，会添加上个人笔记。</p>
<hr>
<h3 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h3><ol>
<li><p>Class类文件结构</p>
<p>​     任何一个Class文件都对应着唯一一个类或接口的定义信息，但反过来说，类或接口并不一定都得定义在文件里（譬如类或接口也可以通过类加载器直接生成）。</p>
<p>​     Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。</p>
<p>​      这里我们就采用书中的代码,跟着来一步一步实现。</p>
<p>​       进入到这个TestClass.java的目录下，执行javac TestClass.java 就会在同一级目录下生成出 TestClass.class文件，这里我是用 Sublime 打开的.class文件,也同样可以看到书中的效果，开头的cafe babe(至于这其中的故事可以去看原书籍).</p>
<p>​        然后继续在刚刚的目录下,来执行 javap -verbose TestClass ，都可以看到效果。这里的内容对着原书籍上仔细的一一对看即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.yang.basicjavatest.gjvm;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Author: Mu_Yi</span><br><span class="line"> * @Date: 2020&#x2F;4&#x2F;18 14:27</span><br><span class="line"> * @Version 1.0</span><br><span class="line"> * @qq: 1411091515</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class TestClass &#123;</span><br><span class="line"></span><br><span class="line">    private int m;</span><br><span class="line"></span><br><span class="line">    public int inc()&#123;</span><br><span class="line"></span><br><span class="line">        return m + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>cafe babe 0000 0034 0013 0a00 0400 0f09<br>0003 0010 0700 1107 0012 0100 016d 0100<br>0149 0100 063c 696e 6974 3e01 0003 2829<br>5601 0004 436f 6465 0100 0f4c 696e 654e<br>756d 6265 7254 6162 6c65 0100 0369 6e63<br>0100 0328 2949 0100 0a53 6f75 7263 6546<br>696c 6501 000e 5465 7374 436c 6173 732e<br>6a61 7661 0c00 0700 080c 0005 0006 0100<br>2563 6f6d 2f79 616e 672f 6261 7369 636a<br>6176 6174 6573 742f 676a 766d 2f54 6573<br>7443 6c61 7373 0100 106a 6176 612f 6c61<br>6e67 2f4f 626a 6563 7400 2100 0300 0400<br>0000 0100 0200 0500 0600 0000 0200 0100<br>0700 0800 0100 0900 0000 1d00 0100 0100<br>0000 052a b700 01b1 0000 0001 000a 0000<br>0006 0001 0000 0009 0001 000b 000c 0001<br>0009 0000 001f 0002 0001 0000 0007 2ab4<br>0002 0460 ac00 0000 0100 0a00 0000 0600<br>0100 0000 0f00 0100 0d00 0000 0200 0e</p>
</blockquote>
</li>
</ol>
<pre><code>javap -verbose TestClass.class 效果</code></pre><blockquote>
<p>D:\Java_DaiMa\idea_github_self\basic-java-io\basic-java-test\src\main\java\com\yang\basicjavatest\gjvm&gt;javap -verbose TestClass.class<br>Classfile /D:/Java_DaiMa/idea_github_self/basic-java-io/basic-java-test/src/main/java/com/yang/basicjavatest/gjvm/TestClass.class<br>  Last modified 2020-4-18; size 303 bytes<br>  MD5 checksum b5c0b88622793ee9ace089dce2d2959d<br>  Compiled from “TestClass.java”<br>public class com.yang.basicjavatest.gjvm.TestClass<br>  minor version: 0<br>  major version: 52<br>  flags: ACC_PUBLIC, ACC_SUPER<br>Constant pool:<br>   #1 = Methodref          #4.#15         // java/lang/Object.”<init>“:()V<br>   #2 = Fieldref           #3.#16         // com/yang/basicjavatest/gjvm/TestClass.m:I<br>   #3 = Class              #17            // com/yang/basicjavatest/gjvm/TestClass<br>   #4 = Class              #18            // java/lang/Object<br>   #5 = Utf8               m<br>   #6 = Utf8               I<br>   #7 = Utf8               <init><br>   #8 = Utf8               ()V<br>   #9 = Utf8               Code<br>  #10 = Utf8               LineNumberTable<br>  #11 = Utf8               inc<br>  #12 = Utf8               ()I<br>  #13 = Utf8               SourceFile<br>  #14 = Utf8               TestClass.java<br>  #15 = NameAndType        #7:#8          // “<init>“:()V<br>  #16 = NameAndType        #5:#6          // m:I<br>  #17 = Utf8               com/yang/basicjavatest/gjvm/TestClass<br>  #18 = Utf8               java/lang/Object<br>{<br>  public com.yang.basicjavatest.gjvm.TestClass();<br>    descriptor: ()V<br>    flags: ACC_PUBLIC<br>    Code:<br>      stack=1, locals=1, args_size=1<br>         0: aload_0<br>         1: invokespecial #1                  // Method java/lang/Object.”<init>“:()V<br>         4: return<br>      LineNumberTable:<br>        line 9: 0</p>
<p>  public int inc();<br>    descriptor: ()I<br>    flags: ACC_PUBLIC<br>    Code:<br>      stack=2, locals=1, args_size=1<br>         0: aload_0<br>         1: getfield      #2                  // Field m:I<br>         4: iconst_1<br>         5: iadd<br>         6: ireturn<br>      LineNumberTable:<br>        line 15: 0<br>}<br>SourceFile: “TestClass.java”</p>
</blockquote>
<ol start="2">
<li><p>LineNumberTable 属性 </p>
<p> LineNumberTable属性用于描述Java源码行号与字节码行号（字节码的偏移量）之间的对应关系。它并不是运行时必需的属性，但默认会生成到Class文件之中，可以在Javac中分别使用-g:none或-g:lines选项来取消或要求生成这项信息。如果选择不生成LineNumberTable属性，对程序运行产生的最主要的影响就是当抛出异常时，堆栈中将不会显示出错的行号，并且在调试程序的时候，也无法按照源码行来设置断点。     </p>
</li>
</ol>
<ol start="3">
<li><p>LocalVariableTable属性</p>
<p>LocalVariableTable属性用于描述栈帧中局部变量表中的变量与Java源码中定义的变量之间的关系，它也不是运行时必需的属性，但默认会生成到Class文件之中，可以在Javac中分别使用-g:none或-g:vars选项来取消或要求生成这项信息。如果没有生成这项属性，最大的影响就是当其他人引用这个方法时，所有的参数名称都将会丢失，IDE将会使用诸如arg0、arg1之类的占位符代替原有的参数名，这对程序运行没有影响，但是会对代码编写带来较大不便，而且在调试期间无法根据参数名称从上下文中获得参数值。</p>
</li>
</ol>
<ol start="4">
<li><p>SourceFile属性</p>
<p> SourceFile属性用于记录生成这个Class文件的源码文件名称。这个属性也是可选的，可以分别使用Javac的-g:none或-g:source选项来关闭或要求生成这项信息。在Java中，对于大多数的类来说，类名和文件名是一致的，但是有一些特殊情况（如内部类）例外。如果不生成这项属性，当抛出异常时，堆栈中将不会显示出错代码所属的文件名。这个属性是一个定长的属性。</p>
</li>
</ol>
<ol start="5">
<li><p>ConstantValue 属性</p>
<p> ConstantValue属性的作用是通知虚拟机自动为静态变量赋值。只有被static关键字修饰的变量（类变量）才可以使用这项属性。类似“int x=123”和“static int x=123”这样的变量定义在Java程序中是非常常见的事情，但虚拟机对这两种变量赋值的方式和时刻都有所不同。对于非static类型的变量（也就是实例变量）的赋值是在实例构造器<init>方法中进行的；而对于类变量，则有两种方式可以选择：在类构造器<clinit>方法中或者使用ConstantValue属性。目前Sun Javac编译器的选择是：如果同时使用final和static来修饰一个变量（按照习惯，这里称“常量”更贴切），并且这个变量的数据类型是基本类型或者java.lang.String的话，就生成ConstantValue属性来进行初始化，如果这个变量没有被final修饰，或者并非基本类型及字符串，则将会选择在<clinit>方法中进行初始化。</p>
</li>
<li><p>InnerClasses 属性</p>
<p> InnerClasses属性用于记录内部类与宿主类之间的关联。如果一个类中定义了内部类，那编译器将会为它以及它所包含的内部类生成InnerClasses属性。</p>
</li>
</ol>
<p>   等等更多的属性就去具体的原书籍中查看</p>
<hr>
<ol start="2">
<li>字节码指令也推荐在原书籍中查看。</li>
</ol>
<hr>
<h3 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h3><ol>
<li><p>类加载的时机 :  </p>
<p>  类从被加载到虚拟机内存中开始,到卸载出内存为止，它的整个生命周期包括 : 加载(loading),验证(verification),准备(Preparation), 解析(resolution),初始化(init),使用(use) 和 卸载(unloading).</p>
</li>
<li><p>加载(类加载):</p>
<ul>
<li>通过一个类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据。</li>
<li>在内存中生成一个代表这个类的 java.lang.Class对象，作为方法区这个类的各种数据访问入口。</li>
</ul>
</li>
<li><p>验证 :</p>
<p>  验证是连接阶段的第一步,这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害到虚拟机自身的安危。</p>
<ul>
<li>​    文件格式的检验 ： 这一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。</li>
<li>元数据验证:  是对字节码描述的信息进行语义分析，以确保起描述的信息符合Java语言虚拟机的要求。</li>
<li>字节码验证:  通过数据流和控制流分析，确保程序语义是合法的，符合逻辑的。</li>
<li>符号引用验证: 最后一阶段的检验发生在虚拟机将符号引用转化为直接引用的时候。</li>
</ul>
</li>
<li><p>准备 :  </p>
<p>​    准备阶段是正式为类变量分配内存并设置类变变量初始化的阶段，这些变量所使用的内存都将在方法区中进行分配。这时候进行内存分配的仅包括类变量(被static修饰的变量)，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。</p>
</li>
<li><p>解析 : </p>
<ul>
<li><p>​     类或接口的解析:   假设当前代码所处的类是D,如果要把一个从未解析的过的符号引用N解析为一个类或者接口C直接引用</p>
<ol>
<li><p>​     如果C不是一个数组类型，那虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C。在加载过程中，由于元数据验证、字节码验证的需要，又可能触发其他相关类的加载动作，例如加载这个类的父类或实现的接口。一旦这个加载过程出现了任何异常，解析过程就宣告失败。</p>
</li>
<li><p>如果C是一个数组类型，并且数组的元素类型为对象，也就是N的描述符会是类似“[Ljava/lang/Integer”的形式，那将会按照第1点的规则加载数组元素类型。如果N的描述符如前面所假设的形式，需要加载的元素类型就是“java.lang.Integer”，接着由虚拟机生成一个代表此数组维度和元素的数组对象。</p>
</li>
<li><p>如果上面的步骤没有出现任何异常，那么C在虚拟机中实际上已经成为一个有效的类或接口了，但在解析完成之前还要进行符号引用验证，确认D是否具备对C的访问权限。如果发现不具备访问权限，将抛出java.lang.IllegalAccessError异常。</p>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>字段解析 : </p>
<p>​      要解析一个未被解析过的字段符号引用，首先将会对字段表内class_index[插图]项中索引的CONSTANT_Class_info符号引用进行解析，也就是字段所属的类或接口的符号引用。如果在解析这个类或接口符号引用的过程中出现了任何异常，都会导致字段符号引用解析的失败。如果解析成功完成，那将这个字段所属的类或接口用C表示，虚拟机规范要求按照如下步骤对C进行后续字段的搜索。</p>
<ol>
<li>​        如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li>
<li>否则，如果在C中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li>
<li>否则，如果C不是java.lang.Object的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li>
<li>否则，查找失败，抛出java.lang.NoSuchFieldError异常。</li>
</ol>
</li>
<li><p>类方法解析 :</p>
<p>​     类方法解析的第一个步骤与字段解析一样，也需要先解析出类方法表的class_index[插图]项中索引的方法所属的类或接口的符号引用，如果解析成功，我们依然用C表示这个类，接下来虚拟机将会按照如下步骤进行后续的类方法搜索。</p>
<ol>
<li><p>​      类方法和接口方法符号引用的常量类型定义是分开的，如果在类方法表中发现class_index中索引的C是个接口，那就直接抛出java.lang.IncompatibleClassChangeError异常。</p>
</li>
<li><p>如果通过了第1步，在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</p>
</li>
<li><p>否则，在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</p>
</li>
<li><p>否则，在类C实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果存在匹配的方法，说明类C是一个抽象类，这时查找结束，抛出java.lang.AbstractMethodError异常。</p>
</li>
<li><p>否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError。</p>
</li>
</ol>
</li>
</ul>
<pre><code>最后，如果查找过程成功返回了直接引用，将会对这个方法进行权限验证，如果发现不具备对此方法的访问权限，将抛出java.lang.IllegalAccessError异常。</code></pre><ul>
<li><p>接口方法解析: </p>
<p> 接口方法也需要先解析出接口方法表的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，依然用C表示这个接口，接下来虚拟机将会按照如下步骤进行后续的接口方法搜索。</p>
<ol>
<li>​    与类方法解析不同，如果在接口方法表中发现class_index中的索引C是个类而不是接口，那就直接抛出java.lang.IncompatibleClassChangeError异常。</li>
<li>否则，在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li>
<li>否则，在接口C的父接口中递归查找，直到java.lang.Object类（查找范围会包括Object类）为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li>
<li>否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError异常。</li>
</ol>
</li>
</ul>
<pre><code>​    由于接口中的所有方法默认都是public的，所以不存在访问权限的问题，因此接口方法的符号解析应当不会抛出java.lang.IllegalAccessError异常。</code></pre><ol start="6">
<li><p>初始化 : </p>
<p>​    类初始化阶段是类加载过程的最后一步，前面的类加载过程中。除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码（或者说是字节码）</p>
</li>
<li><p>类加载阶段:</p>
<pre><code>类加载器虽然只用于实现类的加载动作，但它在JAVA程序中起到的作用却远远不限于类加载阶段。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在JAVA虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。</code></pre><p>跟着书上的写了代码，结果也是书上的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.yang.basicjavatest.gjvm;</span><br><span class="line"></span><br><span class="line">import java.io.InputStream;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Author: Mu_Yi</span><br><span class="line"> * @Date: 2020&#x2F;4&#x2F;18 15:35</span><br><span class="line"> * @Version 1.0</span><br><span class="line"> * @qq: 1411091515</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class ClassLoaderTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        ClassLoader classLoader &#x3D; new ClassLoader() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">               try&#123;</span><br><span class="line">                   String fileName &#x3D; name.substring(name.lastIndexOf(&quot;.&quot;) + 1 ) + &quot;.class&quot;;</span><br><span class="line">                   InputStream inputStream &#x3D; getClass().getResourceAsStream(fileName);</span><br><span class="line">                   if(inputStream &#x3D;&#x3D; null)&#123;</span><br><span class="line">                       return super.loadClass(name);</span><br><span class="line">                   &#125;</span><br><span class="line">                   byte [] b &#x3D; new byte[inputStream.available()];</span><br><span class="line">                   inputStream.read(b);</span><br><span class="line">                   return defineClass(name,b,0,b.length);</span><br><span class="line">               &#125;catch (Exception e)&#123;</span><br><span class="line">                   throw new ClassNotFoundException(name);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Object instance &#x3D; classLoader.loadClass(&quot;com.yang.basicjavatest.gjvm.ClassLoaderTest&quot;).newInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(instance.getClass());</span><br><span class="line">        System.out.println(instance instanceof ClassLoaderTest);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<hr>
<p>后续会持续学习JVM方面的知识,也会持续更新这篇知识。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>ArrayDeque 源码阅读记录</title>
    <url>/2020/04/30/java_list/ArrayDeque_Source/</url>
    <content><![CDATA[<p>ArrayDeque 在我目前做的项目中,使用是比较少的,基本都没有地方用到。可能是我太low了,也可能是业务没有一定要用到队列的情况. 但是这不影响我们对其进行源码阅读。</p>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p> 结构还是可以看到, 使用一个Object的数组, 二个int类型的变量来记录头和尾(从单词的意思)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">transient Object[] elements; &#x2F;&#x2F; non-private to simplify nested class access</span><br><span class="line"></span><br><span class="line">transient int head;</span><br><span class="line"></span><br><span class="line">transient int tail;</span><br></pre></td></tr></table></figure>



<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li><p>构造函数</p>
<p>无参构造函数. 可以看到无参构造函数,默认是对数据进行初始化大小为16的操作.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ArrayDeque() &#123;</span><br><span class="line">    elements &#x3D; new Object[16];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    </p>
<p>有参构造函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**传递int类型的构造函数,最后是调用到了calculateSize方法返回值来初始化数组大小 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayDeque</span><span class="params">(<span class="keyword">int</span> numElements)</span> </span>&#123;</span><br><span class="line">    allocateElements(numElements);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">allocateElements</span><span class="params">(<span class="keyword">int</span> numElements)</span> </span>&#123;</span><br><span class="line">        elements = <span class="keyword">new</span> Object[calculateSize(numElements)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 获取变量MIN_INITIAL_CAPACITY的值,如果传入进来的值是大于这个值,就会进行下面的运算操作,然后返回这个值出去.   */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateSize</span><span class="params">(<span class="keyword">int</span> numElements)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> initialCapacity = MIN_INITIAL_CAPACITY;</span><br><span class="line">        <span class="comment">// Find the best power of two to hold elements.</span></span><br><span class="line">        <span class="comment">// Tests "&lt;=" because arrays aren't kept full.</span></span><br><span class="line">        <span class="keyword">if</span> (numElements &gt;= initialCapacity) &#123;</span><br><span class="line">            initialCapacity = numElements;</span><br><span class="line">            initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">1</span>);</span><br><span class="line">            initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">2</span>);</span><br><span class="line">            initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">4</span>);</span><br><span class="line">            initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">8</span>);</span><br><span class="line">            initialCapacity |= (initialCapacity &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">            initialCapacity++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)   <span class="comment">// Too many elements, must back off</span></span><br><span class="line">                initialCapacity &gt;&gt;&gt;= <span class="number">1</span>;<span class="comment">// Good luck allocating 2 ^ 30 elements</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> initialCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   传递集合的构造函数</span></span><br><span class="line"><span class="comment">   使用传递进来的集合的长度来初始化数组的长度.</span></span><br><span class="line"><span class="comment">   然后调用addAll方法,这里说明下 addAll 是在其 AbstractCollection 里面,也就是子类调用父类的方法.然后add方法是在ArrayDeque里面调用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayDeque</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        allocateElements(c.size());</span><br><span class="line">        addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">allocateElements</span><span class="params">(<span class="keyword">int</span> numElements)</span> </span>&#123;</span><br><span class="line">        elements = <span class="keyword">new</span> Object[calculateSize(numElements)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 这里可以看到,定义给变量,迭代集合c,依次调用add方法,如果add方法返回的是true,变量modified就会变为true.最后addAll就会返回变量modified回去. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (E e : c)</span><br><span class="line">            <span class="keyword">if</span> (add(e))</span><br><span class="line">                modified = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 往下调用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        addLast(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	这里的值是不能传入null进来的,否则的话就会报NPE的异常.</span></span><br><span class="line"><span class="comment">	然后使用下标tail直接插入到最后,if 里面是对 tail 的值进行新赋值操作,如果满足条件就会调用doubleCapacity方法,目测这个方法就是进行扩容的方法.</span></span><br><span class="line"><span class="comment">	这里就是看下  (tail = (tail + 1) &amp; (elements.length - 1)) 这个赋值操作,就是给tail进行新的赋值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        elements[tail] = e;</span><br><span class="line">        <span class="keyword">if</span> ( (tail = (tail + <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)) == head)</span><br><span class="line">            doubleCapacity();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加方法</p>
<p>add(E e)  这里添加调用的方法,我们主要看下 doubleCapacity 这个方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    addLast(e);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void addLast(E e) &#123;</span><br><span class="line">        if (e &#x3D;&#x3D; null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        elements[tail] &#x3D; e;</span><br><span class="line">        if ( (tail &#x3D; (tail + 1) &amp; (elements.length - 1)) &#x3D;&#x3D; head)</span><br><span class="line">            doubleCapacity();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">	这里对 head &#x2F; elements的长度都进行值存储操作, 一 是便于后面使用System.arraycopy 来进行copy数组的值,好从对应下标开始复制值. 二是 head &#x2F;  tail 等赋值.</span><br><span class="line">	可以看到扩容后的的大小,来new了一个新的数组,后面调用System.arraycopy来进行复制.</span><br><span class="line">*&#x2F;</span><br><span class="line">private void doubleCapacity() &#123;</span><br><span class="line">        assert head &#x3D;&#x3D; tail;</span><br><span class="line">        int p &#x3D; head;</span><br><span class="line">        int n &#x3D; elements.length;</span><br><span class="line">        int r &#x3D; n - p; &#x2F;&#x2F; number of elements to the right of p</span><br><span class="line">        int newCapacity &#x3D; n &lt;&lt; 1;</span><br><span class="line">        if (newCapacity &lt; 0)</span><br><span class="line">            throw new IllegalStateException(&quot;Sorry, deque too big&quot;);</span><br><span class="line">        Object[] a &#x3D; new Object[newCapacity];</span><br><span class="line">        System.arraycopy(elements, p, a, 0, r);</span><br><span class="line">        System.arraycopy(elements, 0, a, r, p);</span><br><span class="line">        elements &#x3D; a;</span><br><span class="line">        head &#x3D; 0;</span><br><span class="line">        tail &#x3D; n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​      </p>
<p>addFirst 从头部插入 , 可以看到 使用  head = (head - 1) &amp; (elements.length - 1) 是计算出头部下标的位置,并且对值进行覆盖. 如果 head 与 tail 是相等的话,就会调用 doubleCapacity来进行扩容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    elements[head = (head - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)] = e;</span><br><span class="line">    <span class="keyword">if</span> (head == tail)</span><br><span class="line">        doubleCapacity();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>  addLast 尾部插入, 这个方法上面都是有提到的。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void addLast(E e) &#123;</span><br><span class="line">    if (e &#x3D;&#x3D; null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    elements[tail] &#x3D; e;</span><br><span class="line">    if ( (tail &#x3D; (tail + 1) &amp; (elements.length - 1)) &#x3D;&#x3D; head)</span><br><span class="line">        doubleCapacity();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​      </p>
<pre><code>offerLast / offerFirst  内部都是分别调用到了 addLast / addFirst 方法</code></pre><p>​          push 方法也是调用的 addFirst 方法</p>
<ul>
<li><p>get 获取值方法</p>
<p>​    getFirst / getLast 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 从head对应的数组中直接获取出值,如果值是null的话,就会抛出一个异常,否则就会返回*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    E result = (E) elements[head];</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	(tail - 1) &amp; (elements.length - 1) 得出尾部元素的下标位置,然后用数组下标返回对应的值.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        E result = (E) elements[(tail - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)];</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>  peekFirst / peekLast 中的操作,是与 getFirst / getLast 是一样的    </p>
<p>  peek 方法里面是走的 peekFirst 方法  </p>
<ul>
<li><p>remove 方法</p>
<p>removeFirst 方法, 走的是 pollFirst 方法</p>
<p>removeLast 方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public E removeFirst() &#123;</span><br><span class="line">    E x &#x3D; pollFirst();</span><br><span class="line">    if (x &#x3D;&#x3D; null)</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 头节点 head 使用变量 h 来记录, 直接elements[h]下标来获取值,如果值是null的话,就执行返回(这里直接返回的逻辑处理是,初始化一个集合,但是没任何值,就调用removeFirst方法,这个时候数组里面是没有值的,于是就直接返回即可).</span><br><span class="line"> 如果不是null的话,就会走下面的,将h的下标值设置为null,也就是进行删除,然后重新计算出 head 的值.</span><br><span class="line">*&#x2F;</span><br><span class="line">public E pollFirst() &#123;</span><br><span class="line">        int h &#x3D; head;</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        E result &#x3D; (E) elements[h];</span><br><span class="line">        &#x2F;&#x2F; Element is null if deque empty</span><br><span class="line">        if (result &#x3D;&#x3D; null)</span><br><span class="line">            return null;</span><br><span class="line">        elements[h] &#x3D; null;     &#x2F;&#x2F; Must null out slot</span><br><span class="line">        head &#x3D; (h + 1) &amp; (elements.length - 1);</span><br><span class="line">        return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public E removeLast() &#123;</span><br><span class="line">        E x &#x3D; pollLast();</span><br><span class="line">        if (x &#x3D;&#x3D; null)</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">        return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">	先计算出尾节点的下标,然后用值result来进行记录.如果是null的话,就直接方法(这里想法和上面一样).将t的下标的值重置为null进行删除,然后tail的值就是等t的值.</span><br><span class="line">*&#x2F;</span><br><span class="line">public E pollLast() &#123;</span><br><span class="line">        int t &#x3D; (tail - 1) &amp; (elements.length - 1);</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        E result &#x3D; (E) elements[t];</span><br><span class="line">        if (result &#x3D;&#x3D; null)</span><br><span class="line">            return null;</span><br><span class="line">        elements[t] &#x3D; null;</span><br><span class="line">        tail &#x3D; t;</span><br><span class="line">        return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>   remove 方法是直接调用的 removeFirst 方法.</p>
<ul>
<li>removeFirstOccurrence   /   removeLastOccurrence  TODO 后续更新</li>
</ul>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>  ArrayDeque 队列， 队列的特性就是对数据是先进先出。 而栈的特性是先进后出(比如枪打出去的子弹).</p>
<p>  这里的理解就是, 使用二个变量，然后每次进行 add / get / remove  都是利用这二个变量来进行 添加 / 删除 / 获取等操作.    </p>
]]></content>
      <categories>
        <category>Java集合源码</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>ArrayDeque</tag>
      </tags>
  </entry>
  <entry>
    <title>Vector 源码阅读记录</title>
    <url>/2020/04/29/java_list/Vector/</url>
    <content><![CDATA[<p>Vector 的结构和对数据的添加和删除 与 <a href="https://github.com/baoyang23/source-notes/blob/master/java/jvm_aggregate/ArrayList_Source.md" target="_blank" rel="noopener">ArrayList</a> 是非常相似的. 可以点进去看看.</p>
<p>具体的执行逻辑代码还是非常相似的. </p>
<p>Vector 比起 ArrayList 是线程安全的原因是, Vector 在一些方法上是使用了 synchronized 来进行加锁,从而保证了线程安全问题。</p>
]]></content>
      <categories>
        <category>Java集合源码</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Vector</tag>
      </tags>
  </entry>
  <entry>
    <title>ArrayList 源码阅读记录</title>
    <url>/2020/05/06/java_list/ArrayList_Source/</url>
    <content><![CDATA[<p>ArrayList 是代码中使用非常频繁的,所以看底层的代码时非常有必须的.</p>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>​     ArrayList  是一个由 Object []  的数组来实现的</p>
<p>​     transient Object[] elementData ,这个变量就是存放数据的.</p>
<p>​     长度是用 int size 这个变量来记录的,而不是直接调用的 数组的长度获取的.</p>
<p>​     </p>
<p>​     如果ArrayList list = new ArrayList();   只是仅仅new一个集合的话,数组的大小是没有初始化为10的,而是在add()中,进行判断。 如果数组的是为空的数组的话,就会使用 <strong>DEFAULT_CAPACITY</strong> 来进行初始化。也就是要调用add方法才行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">    <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li><p>先来介绍add()方法 , 上代码</p>
<p>add  里面是走了三个方法, size 没有赋值的情况下,就是0.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确认容量 , 打个比方我们没有对size进行赋值,那么size + 1 传入到这个里面的值也就是1,那么 elementData 对应的也就是一个空数组</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">     ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  满足是空数组的话,就会使用默认的值 10 于 minCapcacity 来进行对比,这里返回的10</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  如果 minCapacity  减去 数组的长度是大于0的,就会调用grow来进行扩容</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            grow(minCapacity);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里可以看到先对数组的值进行,然后对保存出来的值进行1.5倍扩容,与传入进来的值进行对比,满足条件赋值.这里就要看到 Arrays.copyOf(elementDate,newCapacity); 这才是真正的对数组进行扩容的方法,也就是直接调用Arrays的API. Arrays.copyOf() 里面最后也是调用了 System.arraycopy()的方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">到这里 ensureCapacityInternal 方法也就是走完了</span><br><span class="line">---------------------------------------------</span><br><span class="line">后面就是使用 数组下标来进行赋值并且返回<span class="keyword">true</span>。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>​        </p>
<p>​               </p>
<ul>
<li><p>根据下标来添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + 1);  &#x2F;&#x2F; Increments modCount!!</span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + 1,</span><br><span class="line">                     size - index);</span><br><span class="line">    elementData[index] &#x3D; element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 检查下标是否越界 , ensureCapacityInternal 方法和上面一样</span><br><span class="line">private void rangeCheckForAdd(int index) &#123;</span><br><span class="line">        if (index &gt; size || index &lt; 0)</span><br><span class="line">            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;  System.arraycopy() 从 elementDate 的 index处开始复制, 复制给后面的elementDate数组的值,从index + 1 开始复制,也就是说 index 相当于修改了 index + 1, 然后index位置就是没有值了,所以elementDate[index] &#x3D; element的值,size ++.</span><br></pre></td></tr></table></figure>
</li>
<li><p>set方法 : 也就是根据下标来对久的值进行一种替换,取出对应下标的值,然后下标对应的位置赋值给新值,最后返回旧值回去即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 先检查下标是否越界,如果越界就会抛出异常</span><br><span class="line">public E set(int index, E element) &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    E oldValue &#x3D; elementData(index);</span><br><span class="line">    elementData[index] &#x3D; element;</span><br><span class="line">    return oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 取出对应下标的值</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    E elementData(int index) &#123;</span><br><span class="line">        return (E) elementData[index];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>remove </p>
<p>根据传入进来的值进行删除,</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分为 null 和 不是 null 的情况来进行删除.满足条件的话,最后都会调用到 fastRemove方法中来</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  根据传入进来的 下标来删除数据,System.arraycopy 这个方法并不默认,根据下标的位置来进行复制数组。</span></span><br><span class="line"><span class="comment">//  可以看到最后有一个 将值设置为null的操作,从注释上看是help GC, 帮助GC</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据下标删除</p>
<p>  可以看到根据下标删除的话，会先判断传入进来的下标是否满足条件,就是没有出现越界的情况.</p>
<p>  然后取出旧值,接下来的代码就是非常的熟悉了,就是fastRemove() 里面的代码了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public E remove(int index) &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">  </span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue &#x3D; elementData(index);</span><br><span class="line">  </span><br><span class="line">    int numMoved &#x3D; size - index - 1;</span><br><span class="line">    if (numMoved &gt; 0)</span><br><span class="line">        System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] &#x3D; null; &#x2F;&#x2F; clear to let GC do its work</span><br><span class="line">  </span><br><span class="line">    return oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>   大致就是看 ArrayList 是如何添加数据的,对数据是怎么保存的,是如何删除数据的,是怎么样进行扩容的,大致弄明白这些就是对ArrayList有一个大致的了解</p>
]]></content>
      <categories>
        <category>Java集合源码</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring初始化(一)</title>
    <url>/2020/06/27/spring/Spring_Construction/</url>
    <content><![CDATA[<h4 id="阅读方法"><a href="#阅读方法" class="headerlink" title="阅读方法"></a>阅读方法</h4><p>   最简单的阅读方法,就是创建一个maven项目,让引入Spring的依赖.  然后写上一个main方法,来读取包下的内容,然后写一个bean,即可. 这个bean要在你扫描的包下.   于是我们直接在new的地方打上断点跟进去即可.</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SpringStartMain &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AnnotationConfigApplicationContext context &#x3D; new AnnotationConfigApplicationContext(&quot;com.iyang.spring&quot;);</span><br><span class="line">        YangBeanOne yangBeanOne &#x3D; context.getBean(YangBeanOne.class);</span><br><span class="line">        System.out.println(yangBeanOne.getClass().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p> 还有一种就是你去github上clone一个Spring的源码,然后倒入idea,当然你需要gradle环境来构建.然后成功的build一下, 如果成功了的话,就在源码的目录创建一个模块(x项目),然后像上面一样。这样做的好处是,你可以随便修改源码的代码, 你觉得它的哪个地方的代码写到不够好的话,也是可以去修改的.</p>
<h4 id="Debug阅读"><a href="#Debug阅读" class="headerlink" title="Debug阅读"></a>Debug阅读</h4><p>  开始debug进行代码的阅读 : </p>
<p>  debug就会进入到这个构造函数中, 这里我们先对 this() 和 scan(basePackages) 这二个方法进行阅读, refresh()里面涉及到内容比较多(BeanPostprocess,Aware,event等),不是一下子就能看明白的,是需要大量的时间去仔细阅读的.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new AnnotationConfigApplicationContext, scanning for components</span></span><br><span class="line"><span class="comment"> * in the given packages, registering bean definitions for those components,</span></span><br><span class="line"><span class="comment"> * and automatically refreshing the context.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> basePackages the packages to scan for component classes</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>();</span><br><span class="line">   scan(basePackages);</span><br><span class="line">   refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>this () 方法  </p>
<p> 可以看到this方法,基本是在做一些对环境初始化的操作.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new AnnotationConfigApplicationContext that needs to be populated</span></span><br><span class="line"><span class="comment"> * through &#123;<span class="doctag">@link</span> #register&#125; calls and then manually &#123;<span class="doctag">@linkplain</span> #refresh refreshed&#125;.</span></span><br><span class="line"><span class="comment"> 同时还会走到 : org.springframework.context.support.GenericApplicationContext#GenericApplicationContext()这个方法里面来.  this.beanFactory = new DefaultListableBeanFactory(); 可以看到这里是new了一个beanFactory的,也就是我们后面的refresh()方法,可以看到DefaultListableBeanFactroy这个类.</span></span><br><span class="line"><span class="comment"> 再往父类走 : org.springframework.context.support.AbstractApplicationContext#AbstractApplicationContext()就会走到这个类的这个方法来, this.resourcePatternResolver = getResourcePatternResolver(); 这里可以看到是初始化了 resourcePatternResolver.当然了,肯定还有一些new的全局变量的初始化也会进行初始化的.</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.reader = <span class="keyword">new</span> AnnotatedBeanDefinitionReader(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//这个方法对registry,environment和resourceLoader进行赋值,然后根据filter是true,添加了三个filter过滤器.可以看到这个方法虽然带了scanner名字,但是看每个走的方法,好像是没有扫描任何东西,都是对全局参数进行赋值等操作.</span></span><br><span class="line">   <span class="keyword">this</span>.scanner = <span class="keyword">new</span> ClassPathBeanDefinitionScanner(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---------------------------------</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create a new &#123;<span class="doctag">@code</span> AnnotatedBeanDefinitionReader&#125; for the given registry.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;If the registry is &#123;<span class="doctag">@link</span> EnvironmentCapable&#125;, e.g. is an &#123;<span class="doctag">@code</span> ApplicationContext&#125;,</span></span><br><span class="line"><span class="comment">	 * the &#123;<span class="doctag">@link</span> Environment&#125; will be inherited, otherwise a new</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> StandardEnvironment&#125; will be created and used.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> registry the &#123;<span class="doctag">@code</span> BeanFactory&#125; to load bean definitions into,</span></span><br><span class="line"><span class="comment">	 * in the form of a &#123;<span class="doctag">@code</span> BeanDefinitionRegistry&#125;</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #AnnotatedBeanDefinitionReader(BeanDefinitionRegistry, Environment)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #setEnvironment(Environment)</span></span><br><span class="line"><span class="comment">这里可以看到传入进来的registry是 this,也就是传入了AnnotationConfigApplicationContext它自己. </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">可以看到这个方法主要做的事情是,初始化Environment,然后new一个ConditionEvaluator对象,其保存了五个信息. 最后就分别添加五个 Processor到beanFactroy的beanDefinitionMap中来.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">AnnotatedBeanDefinitionReader</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// getOrCreateEnvironment()方法,先对registry进行非null的判断,如果是Null的话,就会抛出对应的异常.最后是new StandardEnvironment()了一个对象返回来. registry是满足EnvironmentCapable</span></span><br><span class="line"><span class="comment">// this()方法:先对传入进来的registry和environemnt进行非null的判断.this.registry = registry; 紧着new了一个ConditionEvaluator对象,其构造函数中,初始化了registry,beanFactory,environment,resourceLoader和classLoader这五个参数,是在内部类ConditionContextImpl中. 最后往beanFactory的beanDefinitionMap中添加了五个值,分别是:</span></span><br><span class="line"><span class="comment">//org.springframework.context.annotation.internalConfigurationAnnotationProcessor</span></span><br><span class="line"><span class="comment">//org.springframework.context.annotation.internalAutowiredAnnotationProcessor</span></span><br><span class="line"><span class="comment">//org.springframework.context.annotation.internalCommonAnnotationProcessor</span></span><br><span class="line"><span class="comment">//org.springframework.context.event.internalEventListenerProcessor</span></span><br><span class="line"><span class="comment">//org.springframework.context.event.internalEventListenerFactory  </span></span><br><span class="line"><span class="comment">//添加完,new AnnotatedBeanDefinitionReader()这个方法就走完了.        </span></span><br><span class="line">		<span class="keyword">this</span>(registry, getOrCreateEnvironment(registry));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">----------------------------------</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create a new &#123;<span class="doctag">@code</span> ClassPathBeanDefinitionScanner&#125; for the given bean factory.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> registry the &#123;<span class="doctag">@code</span> BeanFactory&#125; to load bean definitions into, in the form</span></span><br><span class="line"><span class="comment">	 * of a &#123;<span class="doctag">@code</span> BeanDefinitionRegistry&#125;</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ClassPathBeanDefinitionScanner</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>(registry, <span class="keyword">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ClassPathBeanDefinitionScanner</span><span class="params">(BeanDefinitionRegistry registry, <span class="keyword">boolean</span> useDefaultFilters)</span> </span>&#123;</span><br><span class="line"><span class="comment">//这里也有getOrCreateEnvironment()方法来获取环境,在上一步已经做了,所以这步是直接获取上一步的结果即可.      </span></span><br><span class="line">		<span class="keyword">this</span>(registry, useDefaultFilters, getOrCreateEnvironment(registry));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先对传入进来的 registry 进行非null的判断,</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ClassPathBeanDefinitionScanner</span><span class="params">(BeanDefinitionRegistry registry, <span class="keyword">boolean</span> useDefaultFilters,</span></span></span><br><span class="line"><span class="function"><span class="params">			Environment environment, @Nullable ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		Assert.notNull(registry, <span class="string">"BeanDefinitionRegistry must not be null"</span>);</span><br><span class="line">		<span class="keyword">this</span>.registry = registry;</span><br><span class="line">		<span class="comment">// 这里传入的是ture,也就是会走到这个if里面来.</span></span><br><span class="line">		<span class="keyword">if</span> (useDefaultFilters) &#123;</span><br><span class="line"><span class="comment">//org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#registerDefaultFilters, 往includeFilters 集合中添加Filter,这些添加的filter,点进去看即可.            </span></span><br><span class="line">			registerDefaultFilters();</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">// this.environment赋上传入进来的environment值.        </span></span><br><span class="line">		setEnvironment(environment);</span><br><span class="line"><span class="comment">// org.springframework.core.io.support.ResourcePatternUtils#getResourcePatternResolver进行判断,这里由于是ResourcePatternResolver,所以在第一个if就返回了.</span></span><br><span class="line"><span class="comment">//接着new一个CachingMetadataReaderFactory,传入进去resourceLoader,new这个类的内部也是可以看,就是对参数进行赋值,并没有做其他的什么事情了.      </span></span><br><span class="line"><span class="comment">//this.componentsIndex = CandidateComponentsIndexLoader.loadIndex(this.resourcePatternResolver.getClassLoader());获取出来的值Null.        </span></span><br><span class="line">		setResourceLoader(resourceLoader);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>





<p>scan(basePackages) 方法 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对传入进来的参数进行一个校验.</span></span><br><span class="line"><span class="comment">//scanner也是上面那步this.scanner = new ClassPathBeanDefinitionScanner(this)给new出来的.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">   Assert.notEmpty(basePackages, <span class="string">"At least one base package must be specified"</span>);</span><br><span class="line">   <span class="keyword">this</span>.scanner.scan(basePackages);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Perform a scan within the specified base packages.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> basePackages the packages to check for annotated classes</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> number of beans registered</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">scan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line"><span class="comment">// org.springframework.beans.factory.support.DefaultListableBeanFactory#getBeanDefinitionCount 走到这步来获取个数,还记得new AnnotatedBeanDefinitionReader(this)这个方法里面添加了五个processor吗?所以这里获取出来的beanCountAtScanStart大小就是5(默认对初始化做任何改动的情况下).</span></span><br><span class="line">	<span class="keyword">int</span> beanCountAtScanStart = <span class="keyword">this</span>.registry.getBeanDefinitionCount();</span><br><span class="line"><span class="comment">//从名字上看,这个方法是真正的做扫描的.其实Spring中,scan都算不做事的,doScan才是真的做事的。到后面还有getBean不是做事的,doGetBean才是做事的,createBean也是的. </span></span><br><span class="line"><span class="comment">//doScan做的事情可以看到,读取包下的类,然后根据filter条件来过滤,满足条件的话,就会封装成ScannedGenericBeanDefinition,最后是一个集合包装的该包下全部满足条件的. 然后就是接着对 sbd进行注解的处理,比如有些打入了Lazy等注解的,都要读取出来,存入bd的信息中.最后再检查一遍db,如果没问题的话,就会根据beanName和bd,new一个BeanDefinitionHolder出来,最后注册到beanFactory中去,也就是放入BeanFactory的beanDeifitionMap中去.    </span></span><br><span class="line">	doScan(basePackages);</span><br><span class="line">	<span class="comment">// Register annotation config processors, if necessary.</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.includeAnnotationConfig) &#123;</span><br><span class="line"><span class="comment">// 先获取出beanFactory,先调用beanFactory的getDependencyComparator和getAutowireCandidateResolver方法,如果满足条件的话,就会有对应的set方法.然后紧接着就是判断beanFactory中是否包含一些bd,如果是不包含的话,这里就会添加进去. 这里判断的值,再最初new reader()的时候已经有添加到BeanFactory的beanDifitionMap中去.        </span></span><br><span class="line">		AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="keyword">this</span>.registry);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 这里返回int参数,但是 this.scanner.scan(basePackages); 好像并没有使用到返回值.</span></span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">this</span>.registry.getBeanDefinitionCount() - beanCountAtScanStart);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Perform a scan within the specified base packages,</span></span><br><span class="line"><span class="comment">* returning the registered bean definitions.</span></span><br><span class="line"><span class="comment">* &lt;p&gt;This method does &lt;i&gt;not&lt;/i&gt; register an annotation config processor</span></span><br><span class="line"><span class="comment">* but rather leaves this up to the caller.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> basePackages the packages to check for annotated classes</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> set of beans registered if any for tooling registration purposes (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">doScan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先是对传入进来的参数进行检验.</span></span><br><span class="line">	Assert.notEmpty(basePackages, <span class="string">"At least one base package must be specified"</span>);</span><br><span class="line">    <span class="comment">// 存BeanDefinitionHolder的集合,也是最后要返回的.</span></span><br><span class="line">	Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">	<span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line"><span class="comment">//根据传入进去的包名字,读取出包名字下的所有文件,然后迭代这些文件,这些文件要有能读的权限,再走isCandidateComponent(metadataReader)这个方法,其中就有使用 excludeFilters和includeFilters,这二个filter来过滤进行一些判断操作. 返回ture,就会往下走,new一个ScannedGenericBeanDefinition,其中beanClass就是这个类的全限定名字.比如这里(com.iyang.spring.bean.YangBeanOne),我们的是这个.</span></span><br><span class="line"><span class="comment">//这就是这个方法,扫描,然后根据特定filter,如果是满足条件的话,就会new一个sbd,然后放入Set集合中,返回. </span></span><br><span class="line">		Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">for</span> (BeanDefinition candidate : candidates) &#123;</span><br><span class="line"><span class="comment">//org.springframework.context.annotation.AnnotationScopeMetadataResolver#resolveScopeMetadata,走的这个方法,因AnnotationConfigUtils.attributesFor(...)方法返回的是null,所以这个里面就仅仅只是new了一个ScopeMetadata对象返回了           </span></span><br><span class="line">			ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);</span><br><span class="line"><span class="comment">//scope的值是singletone.这不就是我们熟悉的单例嘛.            </span></span><br><span class="line">			candidate.setScope(scopeMetadata.getScopeName());</span><br><span class="line"><span class="comment">//获取出这个bean的名字            </span></span><br><span class="line">			String beanName = <span class="keyword">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="keyword">this</span>.registry);</span><br><span class="line"><span class="comment">// db是 AbstractBeanDefinition的话,这里肯定是,从AbstractBeanDefinition这个名字上看,是一个抽象的，也就是应该是父类.            </span></span><br><span class="line">			<span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line"><span class="comment">//beanDefinition.applyDefaults(this.beanDefinitionDefaults)该方法是对一些参数进行赋值操作. </span></span><br><span class="line"><span class="comment">//                </span></span><br><span class="line">				postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);</span><br><span class="line">			&#125;</span><br><span class="line"><span class="comment">// bd是AnnotatedBeanDefinition或者其子类.            </span></span><br><span class="line">			<span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line"><span class="comment">// 该方是对bd的Lazy.calss,Primary.class,DependsOn.class,Role.class,Description.class这些注解进行获取,如果有的话,就会调用bd对应的set方法给值set进去. 当然我们这里的bean没有这些属性.这里可自行加入一些注入,然后debug到这个地方进行看.</span></span><br><span class="line">                AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);</span><br><span class="line">				&#125;</span><br><span class="line"><span class="comment">// 检查registry中是否含有这个beanName,如果没包含的话,就直接返回ture.            </span></span><br><span class="line">			<span class="keyword">if</span> (checkCandidate(beanName, candidate)) &#123;</span><br><span class="line"><span class="comment">// 传入bean和beanName, new一个bean的Holder出来,也就是bean的持有者的意思.其实个人觉得这里是对bean进行一层封装,Holder更抽象地理解点.                </span></span><br><span class="line">				BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(candidate, beanName);</span><br><span class="line"><span class="comment">//scopeMetadata中获取出getScopedProxyMode,如果是No的话,就直接返回definitionHolder         </span></span><br><span class="line">				definitionHolder =</span><br><span class="line">							AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line"><span class="comment">// 添加到最外层的集合中                </span></span><br><span class="line">				beanDefinitions.add(definitionHolder);</span><br><span class="line"><span class="comment">//org.springframework.beans.factory.support.DefaultListableBeanFactory#registerBeanDefinition,最后走到了这里,该方法会先对传入进来的参数进行非null的判断,如果bd是AbstractBeanDefinition的话,就会强转调用其validate()方法,进行检验. 在从this.beanDefinitionMap中获取,根据beanName,第一次肯定是获取不到的,走到else.else中在判断hasBeanCreationStarted(),这里返回的是flase,也就是走到了else的else中去了,根据beanName和bean存入到this.beanDefinitionMap中,然后beanName添加到beanDefinitionNames集合中.  这就是这步根据beanName和bean放入beanFactory的beanDefinitionMap集合中.               </span></span><br><span class="line">				registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> beanDefinitions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li><p>this() 方法 :  该方法中主要是初始化了 this.reader 和 this.scanner这个参数,当然了,其中还有一些环境等信息   的初始化. this.reader的时候,是有往beanFactroy中添加五个默认要添加的bd,也就是添加到了 BeanFactory的BeanDefitionMap中.  this.scanner 也是对一些环境等信息初始化 , 然后下接来的方法就是使用  this.scanner来进扫描 class,然后满足条件的,就封装成bd,注册到beanFactory中去.</p>
</li>
<li><p>register() 方法里面调用 this.reader.register(componentClasses); 该方法就是读取包下的class信息,然后满足条件的就封装成bd,同时还会对注解@Lazy等也会读取,如果是有这些注解的话,就会调用bd对应的set方法,给赋值进去,最后将bd给注册到BeanFactory的beanDefitionMap中去即可.</p>
</li>
</ul>
<p>  可以看到 this() 方法 和 register()方法,主要是对环境的初始化和根据传入进来的包名来进行扫描获取class信息,满足条件的class信息就会转化为bd,然后注册到beanFactory中去.</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Java源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring初始化(二)</title>
    <url>/2020/06/28/spring/Spring_Refresh/</url>
    <content><![CDATA[<h4 id="题记"><a href="#题记" class="headerlink" title="题记"></a>题记</h4><p>​    昨天记录了this()和 register() 这二个方法, 这二个方法都是为后面的做铺垫,也就是提前初始化了一些环境和读取class文件.  refresh() 这个方法才是最重要的,其中包含的内容是非常多的. 所以这里慢慢进行更新其方法的内容.</p>
<h4 id="refresh-方法"><a href="#refresh-方法" class="headerlink" title="refresh 方法"></a>refresh 方法</h4><p>这里可以看到的是, refresh()该方法里面,基本都是走了很多方法的. 所以挨个看方法,有些方法是留给子类的,也就是进行扩展的. 从synchronized这个关键字来看,这里只容许一次只有一个线程来执行这个方法.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">      <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">      prepareRefresh();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line"></span><br><span class="line">      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * org.springframework.beans.factory.support.DefaultListableBeanFactory</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">         postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">         invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">         registerBeanPostProcessors(beanFactory);</span><br><span class="line">         <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">         initMessageSource();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">         initApplicationEventMulticaster();</span><br><span class="line">         <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">         onRefresh();</span><br><span class="line">         <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">         registerListeners();</span><br><span class="line">         <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">         finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">         finishRefresh();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line">                  <span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">         destroyBeans();</span><br><span class="line">         <span class="comment">// Reset 'active' flag.</span></span><br><span class="line">         cancelRefresh(ex);</span><br><span class="line">         <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">// Reset common introspection caches in Spring's core, since we</span></span><br><span class="line">         <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">         resetCommonCaches();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="refresh-prepareRefresh-方法"><a href="#refresh-prepareRefresh-方法" class="headerlink" title="refresh.prepareRefresh() 方法"></a>refresh.prepareRefresh() 方法</h4><p> prepareRefresh() 方法:  可以看到该方法先是对closed/active参数进行设置,然后对Enviornment进行调用检验方法,接着判断this.earlyApplicationListeners是否有值来操作this.applicationListeners. 最后初始化earlyApplicationEvents这个集合.   这里大概还是进行一些初始化操作.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Prepare this context for refreshing, setting its startup date and</span></span><br><span class="line"><span class="comment"> * active flag as well as performing any initialization of property sources.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// Switch to active.</span></span><br><span class="line">   <span class="keyword">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line">  <span class="comment">// closed设置为false,active设置为true.  </span></span><br><span class="line">   <span class="keyword">this</span>.closed.set(<span class="keyword">false</span>);</span><br><span class="line">   <span class="keyword">this</span>.active.set(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 根据log级别来进行输出 </span></span><br><span class="line">   <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">      logger.info(<span class="string">"Refreshing "</span> + <span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Initialize any placeholder property sources in the context environment.</span></span><br><span class="line">   <span class="comment">// 目前该方法没有调用;目前没有做任何事情. 目测是应该留给子类之类的进行扩展的.</span></span><br><span class="line">   initPropertySources();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Validate that all properties marked as required are resolvable:</span></span><br><span class="line">   <span class="comment">// see ConfigurablePropertyResolver#setRequiredProperties</span></span><br><span class="line"><span class="comment">//先调用getEnvironment()获取this()方法中创建出来的Environment来,然后走validateRequiredProperties方法来进行一些检验,</span></span><br><span class="line"><span class="comment">//org.springframework.core.env.AbstractPropertyResolver#validateRequiredProperties</span></span><br><span class="line"><span class="comment">//最后是走到了这个方法,如果this.requiredProperties中是有值的话,那么这里就会抛出一个异常来    </span></span><br><span class="line">   getEnvironment().validateRequiredProperties();</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// Store pre-refresh ApplicationListeners...</span></span><br><span class="line"><span class="comment">// 这里是对 earlyApplicationListeners 进行判断,如果有值的话,就先会clear掉,然后再addAll</span></span><br><span class="line"><span class="comment">//如果是没有值的话,就会new一个集合,然后赋值给this.earlyApplicationListeners参数   </span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.earlyApplicationListeners == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.earlyApplicationListeners = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="keyword">this</span>.applicationListeners);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Reset local application listeners to pre-refresh state.</span></span><br><span class="line">      <span class="keyword">this</span>.applicationListeners.clear();</span><br><span class="line">      <span class="keyword">this</span>.applicationListeners.addAll(<span class="keyword">this</span>.earlyApplicationListeners);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Allow for the collection of early ApplicationEvents,</span></span><br><span class="line">   <span class="comment">// to be published once the multicaster is available...</span></span><br><span class="line"><span class="comment">// 最后初始化一下 this.earlyApplicationEvents 这个参数</span></span><br><span class="line">   <span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="refresh-obtainFreshBeanFactory-方法"><a href="#refresh-obtainFreshBeanFactory-方法" class="headerlink" title="refresh.obtainFreshBeanFactory()方法"></a>refresh.obtainFreshBeanFactory()方法</h4><p>这个方法是有方法一个BeanFactory回去的.   </p>
<p>该方法对beanFactory进行SerializationId,然后获取BeanFactory,最后返回这个BeanFactory.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line"><span class="comment"> *  告诉子类刷新内部Bean工厂</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the fresh BeanFactory instance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #refreshBeanFactory()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getBeanFactory()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//this.refreshed.compareAndSet(false, true)该方法如果返回的是false的话,就会有异常给抛出来</span></span><br><span class="line"><span class="comment">//不是false的话,接着就是对beanFactory设置SerializationId    </span></span><br><span class="line">   refreshBeanFactory();</span><br><span class="line"><span class="comment">// org.springframework.context.support.GenericApplicationContext#getBeanFactory</span></span><br><span class="line"><span class="comment">//该方法直接返回DefaultListableBeanFactory    </span></span><br><span class="line">   ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">"Bean factory for "</span> + getDisplayName() + <span class="string">": "</span> + beanFactory);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//返回获取的beanFactory.    </span></span><br><span class="line">   <span class="keyword">return</span> beanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="refresh-prepareBeanFactory-方法"><a href="#refresh-prepareBeanFactory-方法" class="headerlink" title="refresh.prepareBeanFactory() 方法"></a>refresh.prepareBeanFactory() 方法</h4><p>从这个方法来看,是对BeanFactory的准备. </p>
<p>该方法可以先是对classLoader,expressionResolver,propertyEditorRegistrar添加到beanFactory中去. 然后添加ApplicationContextAwareProcessor(BeanPostProcessor)到BeanFactory,然后忽略到一些接口的注入到beanFactory中去. </p>
<p>设置 BeanFactory , ResourceLoader , ApplicationEventPublisher, ApplicationContext等bean到BeanFactory中去.</p>
<p>最后就是一些environment,systemProperties,systemEnvironment等注入到BeanFactory中去.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Configure the factory's standard context characteristics,</span></span><br><span class="line"><span class="comment"> * such as the context's ClassLoader and post-processors.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanFactory the BeanFactory to configure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// Tell the internal bean factory to use the context's class loader etc.</span></span><br><span class="line"><span class="comment">//给beanFactory设置classLoader(加载bean) </span></span><br><span class="line">   beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line"><span class="comment">//这里根据classLoader来获取解析器,然后set到BeanFactory中去.(解析bean定义的表达式)</span></span><br><span class="line">   beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line"><span class="comment">//属性编辑注册器,set到BeanFactory中</span></span><br><span class="line">   beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> ResourceEditorRegistrar(<span class="keyword">this</span>, getEnvironment()));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Configure the bean factory with context callbacks.</span></span><br><span class="line"><span class="comment">//添加ApplicationContextAwareProcessor到BeanFactory中.该类是有实现BeanPostProcessor的</span></span><br><span class="line"><span class="comment">//BeanPostProcessor是在bean初始化完后,调用BeanPostProcessor进行扩展.</span></span><br><span class="line">   beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</span><br><span class="line"><span class="comment">//忽略掉EnvironmentAware/EmbeddedValueResolverAware....ApplicationContextAware</span></span><br><span class="line"><span class="comment">//这六个接口的注入(依赖). 因为ApplicationContextAwareProcessor中有做了这些事</span></span><br><span class="line">   beanFactory.ignoreDependencyInterface(EnvironmentAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ResourceLoaderAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   beanFactory.ignoreDependencyInterface(MessageSourceAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ApplicationContextAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// BeanFactory interface not registered as resolvable type in a plain factory.</span></span><br><span class="line">   <span class="comment">// MessageSource registered (and found for autowiring) as a bean.</span></span><br><span class="line"><span class="comment">// BeanFactory,ResourceLoader,ApplicationEventPublisher,ApplicationContext这四个接口</span></span><br><span class="line"><span class="comment">//对应的bean都set到beanFactory中去.    </span></span><br><span class="line">   beanFactory.registerResolvableDependency(BeanFactory<span class="class">.<span class="keyword">class</span>, <span class="title">beanFactory</span>)</span>;</span><br><span class="line">   beanFactory.registerResolvableDependency(ResourceLoader<span class="class">.<span class="keyword">class</span>, <span class="title">this</span>)</span>;</span><br><span class="line">   beanFactory.registerResolvableDependency(ApplicationEventPublisher<span class="class">.<span class="keyword">class</span>, <span class="title">this</span>)</span>;</span><br><span class="line">   beanFactory.registerResolvableDependency(ApplicationContext<span class="class">.<span class="keyword">class</span>, <span class="title">this</span>)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Register early post-processor for detecting inner beans as ApplicationListeners.</span></span><br><span class="line"><span class="comment">//添加ApplicationListenerDetector(BeanPostProcessor)到beanFactory中去.</span></span><br><span class="line">   beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found.</span></span><br><span class="line">   <span class="keyword">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">      <span class="comment">// Set a temporary ClassLoader for type matching.</span></span><br><span class="line">      beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Register default environment beans.</span></span><br><span class="line"><span class="comment">//如果beanFactory中没有ENVIRONMENT_BEAN_NAME这个bean的话,就注入一个进去</span></span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// SYSTEM_PROPERTIES_BEAN_NAME也是一样,注入到beanFactory中去</span></span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//SYSTEM_ENVIRONMENT_BEAN_NAME同上    </span></span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="refresh-postProcessBeanFactory-方法"><a href="#refresh-postProcessBeanFactory-方法" class="headerlink" title="refresh.postProcessBeanFactory() 方法"></a>refresh.postProcessBeanFactory() 方法</h4><p>该方法目前在单个 Spring中是没有做任何事情的。 等到看SpringBoot源码的时候,这里就会有代码走进来,是进行根据包来扫描来获取class等信息的. 满足条件的class,就会当为bd给注册到beanFactory中去.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Modify the application context's internal bean factory after its standard</span></span><br><span class="line"><span class="comment"> * initialization. All bean definitions will have been loaded, but no beans</span></span><br><span class="line"><span class="comment"> * will have been instantiated yet. This allows for registering special</span></span><br><span class="line"><span class="comment"> * BeanPostProcessors etc in certain ApplicationContext implementations.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanFactory the bean factory used by the application context</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="refresh-invokeBeanFactoryPostProcessors-方法"><a href="#refresh-invokeBeanFactoryPostProcessors-方法" class="headerlink" title="refresh.invokeBeanFactoryPostProcessors() 方法"></a>refresh.invokeBeanFactoryPostProcessors() 方法</h4><p>可以看到这个方法,借助PostProcessorRegistrationDelegate来对PostProcessor进行处理。</p>
<p>先是对BeanDefinitionRegistryPostProcessor进行从beanFactory中获取出相应的名字数组,然后迭代这个数组,然后处理PriorityOrdered—&gt;Ordered—&gt; 没有,这个顺序,最后还有一个while循环迭代来检查BeanDefinitionRegistryPostProcessor是否都处理完了.</p>
<p>再接着就是处理BeanFactoryPostProcessor,处理方式是和BeanDefinitionRegistryPostProcessor一样的,顺序也是一样的.</p>
<p>最后就是调用beanFactory.clearMetadataCache()清除.</p>
<p>当然,这个里面有些上面 PostProcessor等待阅读SpringBoot的时候给补上来,因为到时候SpringBoot这里会有很多PostProcessor,这里目前是没有的.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Instantiate and invoke all registered BeanFactoryPostProcessor beans,</span></span><br><span class="line"><span class="comment"> * respecting explicit order if given.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Must be called before singleton instantiation.</span></span><br><span class="line"><span class="comment">BeanFactoryPostProcessor: 用来修改Spring容器中已经存在的bean定义.</span></span><br><span class="line"><span class="comment">BeanDefinitionRegistryPostProcessor: 是BeanFactoryPostProcessor的子类,作用和父类是一样的,不同的是,该使用的是BeanDefinitionRegistry对bean进行处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"><span class="comment">//org.springframework.context.support.AbstractApplicationContext#getBeanFactoryPostProcessors,由于这里只是启动了单个Spring,返回的集合是没有值的.</span></span><br><span class="line">   List&lt;BeanFactoryPostProcessor&gt; postProcessorsList = getBeanFactoryPostProcessors();</span><br><span class="line">   <span class="comment">//System.out.println("postProcessorsList value ---&gt; " + postProcessorsList);</span></span><br><span class="line">   <span class="comment">// System.out.println("beanFactory  value 111111 ---&gt; " + beanFactory);</span></span><br><span class="line"><span class="comment">//借助PostProcessorRegistrationDelegate来处理PostProcessors.</span></span><br><span class="line"><span class="comment">//对传入postProcessorsList进行迭代,如果PostProcessor是BeanDefinitionRegistryPostProcessor的话,就会强转然后调用postProcessBeanDefinitionRegistry方法(传入参数是beanFacotry),添加到registryProcessors集合中.如果不是的话,就会添加到regularPostProcessors集合中.</span></span><br><span class="line"><span class="comment">//根据BeanDefinitionRegistryPostProcessor,从beanFactory中获取postProcessorNames,</span></span><br><span class="line"><span class="comment">//进行迭代,如果是有PriorityOrdered接口的子类的话,就会从beanFactory中根据bean名字,类.class来获取BeanDefinitionRegistryPostProcessor,并且添加到currentRegistryProcessors集合中,ppName(名字的值)也会添加到processedBeans该集合中</span></span><br><span class="line"><span class="comment">//对currentRegistryProcessors进行排序,全部添加到registryProcessors集合中,invokeBeanDefinitionRegistryPostProcessors()该方法是调用BeanDefinitionRegistryPostProcessors的,调用完了然后清空currentRegistryProcessors这个集合.</span></span><br><span class="line"><span class="comment">//同样方法获取postProcessorNames,processedBeans集合中不包含并且是Ordered的子类,然后添加到currentRegistryProcessors集合中,ppName也会添加到processedBeans集合中,同样的排序方式,添加到registryProcessors中,再调用invokeBeanDefinitionRegistryPostProcessors()方法,currentRegistryProcessors清空该集合.</span></span><br><span class="line"><span class="comment">// 也就是到这里,可以看出来,处理的顺序,先是处理PriorityOrdered,再处理Ordered.</span></span><br><span class="line"><span class="comment">// 然后使用一个while循环,继续获取BeanDefinitionRegistryPostProcessor对应的postProcessorNames,这个地方是为了防止有些没有调用到的,并且是processedBeans集合中不包含的,然后就会放入到currentRegistryProcessors这个集合中,排序currentRegistryProcessors集合,全部添加到registryProcessors中,调用invokeBeanDefinitionRegistryPostProcessors,也就是调用具体的PostProcessors.</span></span><br><span class="line"><span class="comment">//invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);</span></span><br><span class="line"><span class="comment">//invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);</span></span><br><span class="line"><span class="comment">// 之前的二个集合,registryProcessors和regularPostProcessors,在这里还是会继续调用.</span></span><br><span class="line"><span class="comment">//然后根据BeanFactoryPostProcessor.class获取postProcessorNames数组,与上面的也是同样的方法,</span></span><br><span class="line"><span class="comment">//对postProcessorNames进行迭代,如果是processedBeans(上面装的名字)如果包含了,就会跳过.</span></span><br><span class="line"><span class="comment">/** 如果ppName,也就是迭代的值,是有PriorityOrdered的子类的话,就会从走beanFactory.getBean(ppName, BeanFactoryPostProcessor.class)获取出BeanFactoryPostProcessor放入到priorityOrderedPostProcessors集合中.  如果是Ordered的子类,就将名字放入到orderedPostProcessorNames集合中,如果上面三种都不满足的话,就会放入到nonOrderedPostProcessorNames集合中.</span></span><br><span class="line"><span class="comment">然后先排序priorityOrderedPostProcessors,再走invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);</span></span><br><span class="line"><span class="comment">接着迭代orderedPostProcessorNames集合,然后从beanFactory中获取BeanFactoryPostProcessor,再就做与priorityOrderedPostProcessors一样的操作.</span></span><br><span class="line"><span class="comment">最后在做nonOrderedPostProcessors这个集合的,操作是与orderedPostProcessorNames一摸一样的.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">最后在调用一个beanFactory的clearMetadataCache方法.</span></span><br><span class="line"><span class="comment">可以看到这个方法是先对BeanDefinitionRegistryPostProcessor.class进行处理,然后根据顺序PriorityOrdered--&gt;Ordered---&gt;没有, 这样的顺序执行的.</span></span><br><span class="line"><span class="comment">然后再处理BeanFactoryPostProcessor.class,处理方式是和BeanDefinitionRegistryPostProcessor.class也是一样的,根据顺序来进行处理.</span></span><br><span class="line"><span class="comment">*/</span>    </span><br><span class="line">   PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, postProcessorsList);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime</span></span><br><span class="line">   <span class="comment">// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)</span></span><br><span class="line"><span class="comment">// 获取beanFactory的tempClassLoader加载,并且beanFactory是包含了loadTimeWeaver这个bean的,</span></span><br><span class="line"><span class="comment">//就会走if方法,可以看到是添加LoadTimeWeaverAwareProcessor到beanFactory的postProcessor中,</span></span><br><span class="line"><span class="comment">//然后添加一个ClassLoader到beanFactory中   </span></span><br><span class="line">   <span class="keyword">if</span> (beanFactory.getTempClassLoader() == <span class="keyword">null</span> &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">      beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="refresh-registerBeanPostProcessors-方法"><a href="#refresh-registerBeanPostProcessors-方法" class="headerlink" title="refresh.registerBeanPostProcessors() 方法"></a>refresh.registerBeanPostProcessors() 方法</h4><p>仔细看中这个方法,其实和上一个方法走的逻辑好像是有点类似的. 也是借助PostProcessorRegistrationDelegate来完成其逻辑的.</p>
<p>先是从BeanFactory中获取BeanPostProcessor对用的postProcessorNames数组。</p>
<p>然后分为 PriorityOrdered –&gt; Ordered –&gt; 既不是PriorityOrdered ,也不是Ordered  –&gt; MergedBeanDefinitionPostProcessor子类,  这样的先后顺序,走registerBeanPostProcessors,这个是将PostProcessros注册到Spring的beanFactory中(Spring容器).</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Instantiate and register all BeanPostProcessor beans,</span></span><br><span class="line"><span class="comment"> * respecting explicit order if given.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Must be called before any instantiation of application beans.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">   PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-------------------</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先是根据BeanPostProcessor获取出postProcessorNames数组,这个根据和上面的方法很相似.    </span></span><br><span class="line">		String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">				<span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Register BeanPostProcessorChecker that logs an info message when</span></span><br><span class="line">		<span class="comment">// a bean is created during BeanPostProcessor instantiation, i.e. when</span></span><br><span class="line">		<span class="comment">// a bean is not eligible for getting processed by all BeanPostProcessors.</span></span><br><span class="line"><span class="comment">//然后从beanFactory中获取出个数 + postProcessorNames数组长度再加上一个1.     </span></span><br><span class="line">		<span class="keyword">int</span> beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + <span class="number">1</span> + postProcessorNames.length;</span><br><span class="line"><span class="comment">//添加一个BeanPostProcessorChecker到beanFactory中.从名字上来,这个PostProcessor应该是进行检查的操作.</span></span><br><span class="line">		beanFactory.addBeanPostProcessor(<span class="keyword">new</span> BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Separate between BeanPostProcessors that implement PriorityOrdered,</span></span><br><span class="line">		<span class="comment">// Ordered, and the rest.</span></span><br><span class="line">		List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		List&lt;BeanPostProcessor&gt; internalPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 对 postProcessorNames 进行遍历;同时使用不同类型的集合来存储数据</span></span><br><span class="line"><span class="comment">//主要是根据是否是PriorityOrdered的子类,是的话就会放入到priorityOrderedPostProcessors集合中,接着在判断是否是MergedBeanDefinitionPostProcessor,如果是的话,就会放入到internalPostProcessors集合中</span></span><br><span class="line"><span class="comment">//是不是orderd的子类,是的话,就会放入到orderedPostProcessorNames集合中,</span></span><br><span class="line"><span class="comment">//如果上面二者都不的话,就会放入到nonOrderedPostProcessorNames集合中  </span></span><br><span class="line">		<span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">			<span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">				BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">				priorityOrderedPostProcessors.add(pp);</span><br><span class="line">				<span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">					internalPostProcessors.add(pp);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">				orderedPostProcessorNames.add(ppName);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// First, register the BeanPostProcessors that implement PriorityOrdered.</span></span><br><span class="line"><span class="comment">//先处理priorityOrderedPostProcessors这个集合中的数据.先排序,然后调用registerBeanPostPtocessors方法.</span></span><br><span class="line">		sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">		registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Next, register the BeanPostProcessors that implement Ordered.</span></span><br><span class="line"><span class="comment">//在处理orderedPostProcessorNames集合中的数据,发现如果也是MergedBeanDefinitionPostProcessor或者其子类的话,也就放入到internalPostProcessors集合中,也就是这里先不处理.</span></span><br><span class="line">		List&lt;BeanPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (String ppName : orderedPostProcessorNames) &#123;</span><br><span class="line">			BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">			orderedPostProcessors.add(pp);</span><br><span class="line">			<span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">				internalPostProcessors.add(pp);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//排序,处理上面不是MergedBeanDefinitionPostProcessor的或其子类,并且是 orderedPostProcessorNames集合中的数据</span></span><br><span class="line">		sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">		registerBeanPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Now, register all regular BeanPostProcessors.</span></span><br><span class="line"><span class="comment">//最后就处理既不是PriorityOrdered,也不是Ordered的,如果也是MergedBeanDefinitionPostProcessor或者其子类的话,这里也会放入到internalPostProcessors集合中 </span></span><br><span class="line">		List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (String ppName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">			BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">			nonOrderedPostProcessors.add(pp);</span><br><span class="line">			<span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">				internalPostProcessors.add(pp);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//这里先处理nonOrderedPostProcessorNames中的数据并且不是 MergedBeanDefinitionPostProcessor的子类.</span></span><br><span class="line">		registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Finally, re-register all internal BeanPostProcessors.</span></span><br><span class="line"><span class="comment">//最后排序下 MergedBeanDefinitionPostProcessor子类的集合,调用registerBeanPostProcessors方法,注册到BeanFactory中去.   </span></span><br><span class="line">		sortPostProcessors(internalPostProcessors, beanFactory);</span><br><span class="line">		registerBeanPostProcessors(beanFactory, internalPostProcessors);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Re-register post-processor for detecting inner beans as ApplicationListeners,</span></span><br><span class="line">		<span class="comment">// moving it to the end of the processor chain (for picking up proxies etc).</span></span><br><span class="line"><span class="comment">//最后添加一个ApplicationListenerDetector到beanFactory中去,并且ApplicationListenerDetector是有实现MergedBeanDefinitionPostProcessor接口的.</span></span><br><span class="line">		beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(applicationContext));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h4 id="refersh-initMessageSource-方法"><a href="#refersh-initMessageSource-方法" class="headerlink" title="refersh.initMessageSource() 方法"></a>refersh.initMessageSource() 方法</h4><p>  这个方法主要是对 MESSAGE_SOURCE_BEAN_NAME 是否在beanFactory中进行判断.如果已经在了的话,就会判断是不是HierarchicalMessageSource类型,继续判断其ParentMessageSource是不是null,如果是null的话,就会getInternalParentMessageSource调用初始化获取一些值给赋值进去.</p>
<p>  如果beanFactory中没有的话,就会先new一个,然后也会setParentMessageSource值进去,最后注册到beanFactory中去.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize the MessageSource.</span></span><br><span class="line"><span class="comment"> * Use parent's if none defined in this context.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initMessageSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//先获取BeanFactory.  </span></span><br><span class="line">   ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line"><span class="comment">// beanFactory中包含MESSAGE_SOURCE_BEAN_NAME</span></span><br><span class="line">   <span class="keyword">if</span> (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) &#123;</span><br><span class="line"> <span class="comment">//获取出出来的bean赋值给this.messageSource      </span></span><br><span class="line">      <span class="keyword">this</span>.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      <span class="comment">// Make MessageSource aware of parent MessageSource.</span></span><br><span class="line"><span class="comment">//this.parent不是null并且bean是HierarchicalMessageSource</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.parent != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.messageSource <span class="keyword">instanceof</span> HierarchicalMessageSource) &#123;</span><br><span class="line">        <span class="comment">//强转  </span></span><br><span class="line">         HierarchicalMessageSource hms = (HierarchicalMessageSource) <span class="keyword">this</span>.messageSource;</span><br><span class="line">  <span class="comment">// hms获取出来的parentMessageSource是null情况下,getInternalParentMessageSource()返回的值赋值给hms的ParentMessageSource属性  </span></span><br><span class="line">         <span class="keyword">if</span> (hms.getParentMessageSource() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Only set parent context as parent MessageSource if no parent MessageSource</span></span><br><span class="line">            <span class="comment">// registered already.</span></span><br><span class="line">            hms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">         logger.debug(<span class="string">"Using MessageSource ["</span> + <span class="keyword">this</span>.messageSource + <span class="string">"]"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// beanFactory中不包含MESSAGE_SOURCE_BEAN_NAME    </span></span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Use empty MessageSource to be able to accept getMessage calls.</span></span><br><span class="line"><span class="comment">//自己new一个DelegatingMessageSource,dms    </span></span><br><span class="line">      DelegatingMessageSource dms = <span class="keyword">new</span> DelegatingMessageSource();</span><br><span class="line"><span class="comment">//调用getInternalParentMessageSource()方法的返回值给set进去.  </span></span><br><span class="line">      dms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line">      <span class="keyword">this</span>.messageSource = dms;</span><br><span class="line"><span class="comment">// 注入到 beanFactroy中去       </span></span><br><span class="line">      beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, <span class="keyword">this</span>.messageSource);</span><br><span class="line"><span class="comment">// 根据log的级别来打印.       </span></span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">         logger.debug(<span class="string">"Unable to locate MessageSource with name '"</span> + MESSAGE_SOURCE_BEAN_NAME +</span><br><span class="line">               <span class="string">"': using default ["</span> + <span class="keyword">this</span>.messageSource + <span class="string">"]"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="refresh-initApplicationEventMulticaster-方法"><a href="#refresh-initApplicationEventMulticaster-方法" class="headerlink" title="refresh.initApplicationEventMulticaster() 方法"></a>refresh.initApplicationEventMulticaster() 方法</h4><p>  该方法可以看到也是对APPLICATION_EVENT_MULTICASTER_BEAN_NAME是否在bean的判断，如果有的话,就会get出来,没有的话,就会new一个出来,然后注册到beanFactory中去.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize the ApplicationEventMulticaster.</span></span><br><span class="line"><span class="comment"> * Uses SimpleApplicationEventMulticaster if none defined in the context.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.context.event.SimpleApplicationEventMulticaster</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initApplicationEventMulticaster</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 先获取beanFactory   </span></span><br><span class="line">   ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line"> <span class="comment">//判断beanFactory是不是有APPLICATION_EVENT_MULTICASTER_BEAN_NAME这个bean,</span></span><br><span class="line"> <span class="comment">//如果是有的话,就会获取出来.然后进行log的级别,判断要不要打印</span></span><br><span class="line">   <span class="keyword">if</span> (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.applicationEventMulticaster =</span><br><span class="line">            beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">         logger.debug(<span class="string">"Using ApplicationEventMulticaster ["</span> + <span class="keyword">this</span>.applicationEventMulticaster + <span class="string">"]"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="comment">//如果beanFactory是不包含的话,那么久new一个SimpleApplicationEventMulticaster出来,</span></span><br><span class="line"> <span class="comment">//然后注册到beanFactory中去,最后根据log的级别来判断打印</span></span><br><span class="line">  </span><br><span class="line">      <span class="keyword">this</span>.applicationEventMulticaster = <span class="keyword">new</span> SimpleApplicationEventMulticaster(beanFactory);</span><br><span class="line">      beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, <span class="keyword">this</span>.applicationEventMulticaster);</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">         logger.debug(<span class="string">"Unable to locate ApplicationEventMulticaster with name '"</span> +</span><br><span class="line">               APPLICATION_EVENT_MULTICASTER_BEAN_NAME +</span><br><span class="line">               <span class="string">"': using default ["</span> + <span class="keyword">this</span>.applicationEventMulticaster + <span class="string">"]"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="refresh-onRefresh-方法"><a href="#refresh-onRefresh-方法" class="headerlink" title="refresh.onRefresh() 方法"></a>refresh.onRefresh() 方法</h4><p> 该方法时留给子类的。 如果是SpringBoot启动的话,这里就会去new Tomcat,然后启动web相应的环境. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Template method which can be overridden to add context-specific refresh work.</span></span><br><span class="line"><span class="comment"> * Called on initialization of special beans, before instantiation of singletons.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This implementation is empty.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeansException in case of errors</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #refresh()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">   <span class="comment">// For subclasses: do nothing by default.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="refresh-registerListeners-方法"><a href="#refresh-registerListeners-方法" class="headerlink" title="refresh.registerListeners() 方法"></a>refresh.registerListeners() 方法</h4><p> 该方法是先获取 ApplicationListeners,如果是有值的话,就会添加到AbstractApplicationEventMulticaster的ListenerRetriever的applicationListeners集合中去.</p>
<p>根据ApplicationListener.class获取对应的bean信息,然后迭代,最后会添加到AbstractApplicationEventMulticaster的ListenerRetriever的applicationListenerBeans属性中去</p>
<p>最后是对this.earlyApplicationEvents中的事件进行发布</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add beans that implement ApplicationListener as listeners.</span></span><br><span class="line"><span class="comment"> * Doesn't affect other listeners, which can be added without being beans.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerListeners</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// Register statically specified listeners first.</span></span><br><span class="line"><span class="comment">//getApplicationListeners()获取AbstractApplicationContext中的applicationListeners</span></span><br><span class="line"><span class="comment">//getApplicationEventMulticaster()方法获取的applicationEventMulticaster,是在</span></span><br><span class="line"><span class="comment">//initApplicationEventMulticaster方法中有初始化的.    </span></span><br><span class="line"><span class="comment">//org.springframework.context.event.AbstractApplicationEventMulticaster#addApplicationListener,最后是走到了这里, </span></span><br><span class="line"><span class="comment">//this.defaultRetriever.applicationListeners.add(listener);最后listener是添加到</span></span><br><span class="line"><span class="comment">//其内部内ListenerRetriever的applicationListeners参数中去了.    </span></span><br><span class="line">   <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123;</span><br><span class="line">      getApplicationEventMulticaster().addApplicationListener(listener);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">   <span class="comment">// uninitialized to let post-processors apply to them!</span></span><br><span class="line"><span class="comment">//根据ApplicationListener获取相应的beanNames数组,这里可以看到和之前获取PostProcessor是一样的</span></span><br><span class="line">   String[] listenerBeanNames = getBeanNamesForType(ApplicationListener<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line"><span class="comment">//然后迭代, getApplicationListenerBean是走到了</span></span><br><span class="line"><span class="comment">//org.springframework.context.event.AbstractApplicationEventMulticaster#addApplicationListenerBean,也就是添加到了其内部类ListenerRetriever的applicationListenerBeans属性里面    </span></span><br><span class="line">   <span class="keyword">for</span> (String listenerBeanName : listenerBeanNames) &#123;</span><br><span class="line">      getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Publish early application events now that we finally have a multicaster...</span></span><br><span class="line"><span class="comment">//使用this.earlyApplicationEvents的集合的值,赋值给变量earlyEventsToProcess,</span></span><br><span class="line"><span class="comment">//然后给this.earlyApplicationEvents重置为null   </span></span><br><span class="line">   Set&lt;ApplicationEvent&gt; earlyEventsToProcess = <span class="keyword">this</span>.earlyApplicationEvents;</span><br><span class="line">   <span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">null</span>;</span><br><span class="line"> <span class="comment">//集合不是null并且是有值的话,   </span></span><br><span class="line">   <span class="keyword">if</span> (earlyEventsToProcess != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (ApplicationEvent earlyEvent : earlyEventsToProcess) &#123;</span><br><span class="line">  <span class="comment">//org.springframework.context.event.SimpleApplicationEventMulticaster#invokeListener,这里是走到了这里,可以看到是对这个事件进行发布.</span></span><br><span class="line"> <span class="comment">// 然后会根据ApplicationListener去走onApplicationEvent方法         </span></span><br><span class="line">         getApplicationEventMulticaster().multicastEvent(earlyEvent);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="refresh-finishBeanFactoryInitialization-方法"><a href="#refresh-finishBeanFactoryInitialization-方法" class="headerlink" title="refresh.finishBeanFactoryInitialization() 方法"></a>refresh.finishBeanFactoryInitialization() 方法</h4><p>该方法从名字上来,就是结束beanFactory的初始化,也就是我们前面准备的bd,postProcessor等信息,在这里都会使用到的.</p>
<p>可以看到该方法就是真正的实例化bean的方法。 大致就是getBean往下走,getBean如果是没有的话,就会走createBean,也就是没有就去创建嘛，就是这个意思。然后其创建的条件,是走各种beanPostProcessors来进行扩展bean. </p>
<p> beanFactory.preInstantiateSingletons() 是需要去阅读很多遍的. 不是一遍或者简单的几遍就ok了的.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Finish the initialization of this context's bean factory,</span></span><br><span class="line"><span class="comment"> * initializing all remaining singleton beans.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// Initialize conversion service for this context.</span></span><br><span class="line"><span class="comment">//如果beanFactory包含CONVERSION_SERVICE_BEAN_NAME,并且该CONVERSION_SERVICE_BEAN_NAME是</span></span><br><span class="line"><span class="comment">//ConversionService的子类的话,久满足条件,然后先从beanFactory中获取出bean,set给beanFactory中的conversionService属性    </span></span><br><span class="line">   <span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">         beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">      beanFactory.setConversionService(</span><br><span class="line">            beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Register a default embedded value resolver if no bean post-processor</span></span><br><span class="line">   <span class="comment">// (such as a PropertyPlaceholderConfigurer bean) registered any before:</span></span><br><span class="line">   <span class="comment">// at this point, primarily for resolution in annotation attribute values.</span></span><br><span class="line"><span class="comment">// beanFactory中没有EmbeddedValueResolver,也就是该方法返回的是false,然后就从environment中获取出来一个给add到beanFactory中去.    </span></span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">      beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span></span><br><span class="line"><span class="comment">//根据LoadTimeWeaverAware获取出对用的names数组</span></span><br><span class="line">   String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">         <span class="title">false</span>, <span class="title">false</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//然后迭代上面获取出来的数组,挨个调用getBean方法    </span></span><br><span class="line">   <span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;      </span><br><span class="line">      getBean(weaverAwareName);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Stop using the temporary ClassLoader for type matching.</span></span><br><span class="line"><span class="comment">// tempClassLoader,temp的ClassLoader设置为null    </span></span><br><span class="line">   beanFactory.setTempClassLoader(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Allow for caching all bean definition metadata, not expecting further changes.</span></span><br><span class="line"><span class="comment">//org.springframework.beans.factory.support.DefaultListableBeanFactory#freezeConfiguration,该方法时走的这里. 其中可以看到是给configurationFrozen设置为true,然后beanName的集合转化为数组,并且赋值给this.frozenBeanDefinitionNames这个数组    </span></span><br><span class="line">   beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line"><span class="comment">//这里面初始化bean,简单说一下逻辑. org.springframework.beans.factory.support.AbstractBeanFactory#getBean(java.lang.String)</span></span><br><span class="line"><span class="comment">//getBean() ---&gt; doGetBean() ---&gt;   createBean() ---&gt;  doCreateBean() </span></span><br><span class="line"><span class="comment">//然后再createBean和doCreateBean()方法之中,会根据条件上面的,获取BeanPostProcessors,然后判断走哦不走其各种BeanPostProceesors提供的方法.满足条件就会走,不满足也就自然不会走了.</span></span><br><span class="line"><span class="comment">//当然了这个方法的复杂程度是比较高的，是需要好好理解的。不是这个简简单单的几句话,还需要自己去读.</span></span><br><span class="line"><span class="comment">//起大致打代码走向就是这样,然后其中会走很多调用bean扩展的BeanPostProcessors，还有实现Init...接口后提供的afterS...等方法.    </span></span><br><span class="line">   beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="refresh-finishRefresh-方法"><a href="#refresh-finishRefresh-方法" class="headerlink" title="refresh.finishRefresh() 方法"></a>refresh.finishRefresh() 方法</h4><p>可以看到这个方法是清除了资源缓存, 然后 实现Lifecycle接口的子类,这里就会启动其start方法</p>
<p>发送一个ContextRefreshedEvent事件出去</p>
<p>最后将当前的 AbstractApplicationContext 添加到 LiveBeansView的applicationContexts集合中来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Finish the refresh of this context, invoking the LifecycleProcessor's</span></span><br><span class="line"><span class="comment"> * onRefresh() method and publishing the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.context.event.ContextRefreshedEvent&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// Clear context-level resource caches (such as ASM metadata from scanning).</span></span><br><span class="line">  <span class="comment">//清除资源缓存  </span></span><br><span class="line">   clearResourceCaches();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Initialize lifecycle processor for this context.</span></span><br><span class="line"><span class="comment">// 这个方法就会调用实现了 Lifecycle 接口的子类,并且执行其start方法    </span></span><br><span class="line">   initLifecycleProcessor();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Propagate refresh to lifecycle processor first.</span></span><br><span class="line">   getLifecycleProcessor().onRefresh();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Publish the final event.</span></span><br><span class="line"> <span class="comment">//发送一个刷新上下文的Event出去   </span></span><br><span class="line">   publishEvent(<span class="keyword">new</span> ContextRefreshedEvent(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Participate in LiveBeansView MBean, if active.</span></span><br><span class="line"><span class="comment">//org.springframework.context.support.LiveBeansView#applicationContexts</span></span><br><span class="line"><span class="comment">//将AbstractApplicationContext添加到liveBean的applicationContexts集合中    </span></span><br><span class="line">   LiveBeansView.registerApplicationContext(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="refresh-resetCommonCaches"><a href="#refresh-resetCommonCaches" class="headerlink" title="refresh.resetCommonCaches()"></a>refresh.resetCommonCaches()</h4><p>可以看到这个方法才是真正的清除各种集合缓存啥的操作. 是在finally代码快中,也就是说是必须要执行的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Reset Spring's common reflection metadata caches, in particular the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ReflectionUtils&#125;, &#123;<span class="doctag">@link</span> AnnotationUtils&#125;, &#123;<span class="doctag">@link</span> ResolvableType&#125;</span></span><br><span class="line"><span class="comment"> * and &#123;<span class="doctag">@link</span> CachedIntrospectionResults&#125; caches.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 4.2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ReflectionUtils#clearCache()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> AnnotationUtils#clearCache()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ResolvableType#clearCache()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> CachedIntrospectionResults#clearClassLoader(ClassLoader)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">resetCommonCaches</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   ReflectionUtils.clearCache();</span><br><span class="line">   AnnotationUtils.clearCache();</span><br><span class="line">   ResolvableType.clearCache();</span><br><span class="line">   CachedIntrospectionResults.clearClassLoader(getClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Java源码</tag>
      </tags>
  </entry>
  <entry>
    <title>LinkedList源码阅读记录</title>
    <url>/2020/04/29/java_list/LinkedList_Source/</url>
    <content><![CDATA[<p>虽然一般都是使用ArrayList集合比使用LinkedList集合要多,但是这并不妨碍我们对LinkedList的源码研究和学习</p>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>LinkedList 是一个双向链表的结构,这点可以直接看其内部内就可以非常明显的看出来. 静态私有的内部类,只提供一个构造函数.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然后我们看 LinkedList 自身的变量. size 肯定是记录这个链表的长度,不然到时候node.next.next….获取长度就很得不偿失了.  然后记录了一个头节点和尾节点，个人认为这是方便遍历。从头开始遍历就从first节点获取,从尾部开始遍历的话,就从last开始获取.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">transient int size &#x3D; 0;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Pointer to first node.</span><br><span class="line"> * Invariant: (first &#x3D;&#x3D; null &amp;&amp; last &#x3D;&#x3D; null) ||</span><br><span class="line"> *            (first.prev &#x3D;&#x3D; null &amp;&amp; first.item !&#x3D; null)</span><br><span class="line"> *&#x2F;</span><br><span class="line">transient Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Pointer to last node.</span><br><span class="line"> * Invariant: (first &#x3D;&#x3D; null &amp;&amp; last &#x3D;&#x3D; null) ||</span><br><span class="line"> *            (last.next &#x3D;&#x3D; null &amp;&amp; last.item !&#x3D; null)</span><br><span class="line"> *&#x2F;</span><br><span class="line">transient Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li><p>add 方法</p>
<p>add方法调用一个linkLast方法,然后就返回true了. 也就是说add(E e)就是默认从尾部开始插入元素进去.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Links e as last element.</span></span><br><span class="line"><span class="comment">       翻译 : 链接e作为最后一个元素。</span></span><br><span class="line"><span class="comment">       先对last赋值给 Node&lt;E&gt; l , 然后调用new Node&lt;&gt;(l,e,null);传入进去的上个节点,也就是l,上次保存的尾部节点,也就是从倒数第一变为了倒数二,这样理解。然后此时的newNode就是尾节点了,然后赋值给last,因为last每次记录的都是尾节点.</span></span><br><span class="line"><span class="comment">       if else 中是对之前的尾节点进行判断,如果是null的话,说明此时就是添加的第一个元素,first也赋值给newNode,否则的话,l.next 和 尾节点进行关联。</span></span><br><span class="line"><span class="comment">       size 长度加一</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">        last = newNode;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>  根据下标添加 add(int index,E  element)</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	1: 检查传入进来的下标是否越界了,如果下标越界的话,就会抛出 下标越界的异常</span></span><br><span class="line"><span class="comment">	2: 根据传入进来的下标值,判断是否和 size 相等,如果是相等的话,就说明是尾部插入,就不需要挨个迭代去获取对应的下标值对应的节点.满足条件,就会调用上面说到的 linkLast方法</span></span><br><span class="line"><span class="comment">	3: 不满足条件2的话,就会走lineBefore()方法,其中也调用到了.传入下标调用node方法.node会返回对应下标的值,根据返回的节点和当前的值调用lienkBefore方法.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkPositionIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isPositionIndex(index))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPositionIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	size &gt;&gt; 1 ; 是对 size 进行去半, 比如 6 &gt;&gt; 1 是 3， 5 &gt;&gt; 1 是2</span></span><br><span class="line"><span class="comment">	如果小于一半的话,就会从first节点开始遍历,也就是从头节点开始遍历,否则就是从尾节点开始遍历.</span></span><br><span class="line"><span class="comment">	这个方法可以看到,从头开始遍历的话,就是调用的next,如果尾部遍历的话,调用的就是prev。找到对应下标的节点并且返回回去.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">            Node&lt;E&gt; x = first;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">                x = x.next;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;E&gt; x = last;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">                x = x.prev;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	获取节点的上个节点赋值给pred，其实类似于pred这种,都是用于变量替换创建出来的.</span></span><br><span class="line"><span class="comment">	上一个节点,当前值e,succ节点来new一个新的节点出来.</span></span><br><span class="line"><span class="comment">	succ.prev 指向当前new出来的节点</span></span><br><span class="line"><span class="comment">	对pred判断是否是null,如果是null的话,就说明是第一个值,否则就是赋值上pred个节点的next</span></span><br><span class="line"><span class="comment">	,size ++ 就是对长度 ++ </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert succ != null;</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">        succ.prev = newNode;</span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pred.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>   头插入 和 尾插入</p>
<p>   头插入，将值插入到头部</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkFirst(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	先将first 赋值给 f ,  根据传入进来的值e 和 下一个节点f(前一个头节点),new一个新的newNode节点出来,first指向newNode.如果f是null的话就说明是初始化,如果不是null的话,f的上一个节点指向newNode,刚刚程序newNode出来的.就完成了头节点的插入</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);</span><br><span class="line">        first = newNode;</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">            last = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            f.prev = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>  尾节点插入;与头节点相似，也是利用变量last来实现尾部插入.</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void addLast(E e) &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void linkLast(E e) &#123;</span><br><span class="line">        final Node&lt;E&gt; l &#x3D; last;</span><br><span class="line">        final Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(l, e, null);</span><br><span class="line">        last &#x3D; newNode;</span><br><span class="line">        if (l &#x3D;&#x3D; null)</span><br><span class="line">            first &#x3D; newNode;</span><br><span class="line">        else</span><br><span class="line">            l.next &#x3D; newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>get 方法,获取值方法</p>
<p>根据下标来获取出值 ,然后调用node方法获取出节点,node.item就是我们需要的值,然后对其进行返回即可.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public E get(int index) &#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    return node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果输入index是小于0和大于size的话,就会爆出下标越界的错误.</span><br><span class="line">private void checkElementIndex(int index) &#123;</span><br><span class="line">        if (!isElementIndex(index))</span><br><span class="line">            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>​       </p>
<p>getFirst / getLast     可以看到first和 last都是直接从定义的变量中获取出对应的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">return</span> l.item;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>​    peek 方法;使用first节点,如果是null的话就会返回null，否则就是f.item. 这里是没有删除first元素,poll是弹出元素并且删除.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public E peek() &#123;</span><br><span class="line">    final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">    return (f &#x3D;&#x3D; null) ? null : f.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>​    poll 方法 :  这里主要看unlinkFirst方法.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   取出 f 的item,节点对应的值和 f的next个节点,如果下个节点是null的话,就说明是没有值的,如果不为null的话，说将next的上一个节点prev指向null,因为头节点的prev和尾节点的next都是null来进行区分。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert f == first &amp;&amp; f != null;</span></span><br><span class="line">        <span class="keyword">final</span> E element = f.item;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">        f.item = <span class="keyword">null</span>;</span><br><span class="line">        f.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">        first = next;</span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">            last = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            next.prev = <span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>​    offer 等方法都是内部调用了add / addFirst / addLast等方法.</p>
<ul>
<li><p>remove 方法</p>
<p>根据下标进来remove方法, node(index) 也是在上面进行讲到的,就是根据下标获取对应的node节点信息.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	这里获取出节点的 next 和 prev方法.</span></span><br><span class="line"><span class="comment">	该节点的上一个节点(prev)的next需要指向指向该节点的下个节点(next),该节点的下一个节点和prev的操作是相反的,因为这样的话,就删除了该节点,并且上一个节点和下一个节点关联起来了.	</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> <span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert x != null;</span></span><br><span class="line">        <span class="keyword">final</span> E element = x.item;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">            first = next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev.next = next;</span><br><span class="line">            x.prev = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            last = prev;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next.prev = prev;</span><br><span class="line">            x.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        x.item = <span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>  remove(Object o) 根据值来进行删除.这个可以看出来，如果有二个相同节点的值,调用一次这个方法是只可以删除一个,而不是二个.</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    if (o &#x3D;&#x3D; null) &#123;</span><br><span class="line">        for (Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; x &#x3D; x.next) &#123;</span><br><span class="line">            if (x.item &#x3D;&#x3D; null) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; x &#x3D; x.next) &#123;</span><br><span class="line">            if (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p> 好啦,今天的知识内容就更新到这里,虽然文字描述到很难理解,但是主要去理解 Node 节点的 双向指向,并且每次添加节点和删除添加，都是靠Node的prev和next来进行指向. 所以说LinkedList是删除快，查询慢的原因。</p>
]]></content>
      <categories>
        <category>Java集合源码</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>PriorityQueue源码阅读记录</title>
    <url>/2020/05/12/java_list/PriorityQueue_source/</url>
    <content><![CDATA[<p>​      PriorityQueue :  中文是优先队列 , 队列的特点就是数据 先进先出,   但是这个优先队列的特别是什么呢？ 首先肯定是有队列的基本特点，也就是有先进先出。  如果是先进先出的话,那么就和普通的有什么区别？优先二字又是体现在什么地方呢？  优先级队列的元素按照其自然顺序进行排序, 或者根据 构造队列时提供的 Comparator 进行排序.</p>
<hr>
<h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p>​    结构就是 PriorityQueue这个类的 全局变量参数, 因为这些参数是存储数据的, 所以只要理解了这些参数,就明白了这个 PriorityQueue这个是对数据是怎么样进行存储的, 还是比较好理解的. </p>
<p> 这里可以看到 priorityQueue的数据结构还是很简单的, 一眼扫过去没什么需要特别的理解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 存储数据的数组</span></span><br><span class="line"><span class="keyword">transient</span> Object[] queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录 priorityQueue的长度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个就是之前说提到的  可以根据 Comparator 进行排序</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>​    priorityQueue的构造方法相对于其他的集合的构造方法可能是比较多的.</p>
<p>​     </p>
<p>​    这里列举出来, 可以看到构造方法还是比较多的.</p>
<p>​    对构造函数的初始化赋值等操作还是很好理解的,并没有什么特别难理解的。  主要还是对数组/长度/或者传入进来的数组进行赋值操作.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 1   </span></span><br><span class="line"><span class="comment">// 这里是走到 4 的构造方法去了</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 这里是走到 4 的构造方法去了</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 这里是走到 4 的构造方法去了</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, comparator);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4 </span></span><br><span class="line"><span class="comment">/**  可以看到前面的三个都是走到了这里来了,</span></span><br><span class="line"><span class="comment">	 长度如果是小于1的话,就会报错.  </span></span><br><span class="line"><span class="comment">     this.queue 的数组长度就是 initialCapacity</span></span><br><span class="line"><span class="comment">     comparator 排序方法就是传入进来的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                         Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Note: This restriction of at least one is not actually needed,</span></span><br><span class="line">        <span class="comment">// but continues for 1.5 compatibility</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">this</span>.queue = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">        <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">/**  对传入进来的集合进行判断. 分为   SortedSet  或者  PriorityQueue  或者其他</span></span><br><span class="line"><span class="comment">     如果是 SortedSet 的话, 对 comparator 的值赋值为 传入进来集合的排序方式,然后走 initElementsFromCollection() 方法, 这里应该是对集合进行赋值操作.</span></span><br><span class="line"><span class="comment">     如果是 PriorityQueue , comparator 处理方式是和 SortedSet一样,然后走 initFromPriorityQueue 方法. </span></span><br><span class="line"><span class="comment">     否则就不上面的二种, comparator 复置为 null ,走 initFromCollection 方法.</span></span><br><span class="line"><span class="comment">     这里总结的话,就是传入进来不同的集合,走的方法也是不一样的,这个还是很好理解的.</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (c <span class="keyword">instanceof</span> SortedSet&lt;?&gt;) &#123;</span><br><span class="line">            SortedSet&lt;? extends E&gt; ss = (SortedSet&lt;? extends E&gt;) c;</span><br><span class="line">            <span class="keyword">this</span>.comparator = (Comparator&lt;? <span class="keyword">super</span> E&gt;) ss.comparator();</span><br><span class="line">            initElementsFromCollection(ss);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c <span class="keyword">instanceof</span> PriorityQueue&lt;?&gt;) &#123;</span><br><span class="line">            PriorityQueue&lt;? extends E&gt; pq = (PriorityQueue&lt;? extends E&gt;) c;</span><br><span class="line">            <span class="keyword">this</span>.comparator = (Comparator&lt;? <span class="keyword">super</span> E&gt;) pq.comparator();</span><br><span class="line">            initFromPriorityQueue(pq);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.comparator = <span class="keyword">null</span>;</span><br><span class="line">            initFromCollection(c);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6  这个对应上面的, 如果是传入进来 PriorityQueue 的处理方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(PriorityQueue&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.comparator = (Comparator&lt;? <span class="keyword">super</span> E&gt;) c.comparator();</span><br><span class="line">        initFromPriorityQueue(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7  这个也是对应上面的 SortedSet 处理方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(SortedSet&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.comparator = (Comparator&lt;? <span class="keyword">super</span> E&gt;) c.comparator();</span><br><span class="line">        initElementsFromCollection(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">----------------------   华丽分割线   --------------------</span><br><span class="line">上面的<span class="keyword">if</span> <span class="keyword">else</span> 里面提到的走不同的方法,还是有必要取看看的. </span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  对传入进来是  PriorityQueue  进行处理, 先判断确认 class是PriorityQueue ,是的话,调用toArray() 将数组赋值给 queue , 并且长度也进行复置给size.</span></span><br><span class="line"><span class="comment">  否则就走  initFromCollection 方法, 这个 if else 还是比较严谨的.进行多次判断处理</span></span><br><span class="line"><span class="comment">*/</span>    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initFromPriorityQueue</span><span class="params">(PriorityQueue&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (c.getClass() == PriorityQueue<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.queue = c.toArray();</span><br><span class="line">            <span class="keyword">this</span>.size = c.size();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            initFromCollection(c);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   这个对传入进来的集合, 将值转化为 数组a (Object []), 如果 comparator不是null的话,就会根据comparator来进行排序. 也就是对a进行排序,并且这个的值不可以为null的,如果出现了null的话,就会有空指针的异常出现.</span></span><br><span class="line"><span class="comment">   然后将数组a赋值给queue,长度也是调用 a.length 复置给size</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initElementsFromCollection</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="comment">// If c.toArray incorrectly doesn't return Object[], copy it.</span></span><br><span class="line">        <span class="keyword">if</span> (a.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            <span class="title">a</span> </span>= Arrays.copyOf(a, a.length, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">int</span> len = a.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span> || <span class="keyword">this</span>.comparator != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">                <span class="keyword">if</span> (a[i] == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.queue = a;</span><br><span class="line">        <span class="keyword">this</span>.size = a.length;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 可以看到这个方法是走了  initElementsFromCollection 这个方法, 然后再走 headify 方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initFromCollection</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        initElementsFromCollection(c);</span><br><span class="line">        heapify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>​     添加元素方法 ： </p>
<p>​      </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> offer(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	这里可以看到,如果值是null的话,就会抛出NPE的异常.</span></span><br><span class="line"><span class="comment">	如果size的大小比 queue数组的长度还大的话,就会进行扩容.</span></span><br><span class="line"><span class="comment">	然后size长度+1,如何i是0的话,就说明是第一个元素,不需要任何拍寻处理,直接赋值给第一个即可.</span></span><br><span class="line"><span class="comment">	如果不是第一个的话,就会走siftUp方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">int</span> i = size;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= queue.length)</span><br><span class="line">            grow(i + <span class="number">1</span>);</span><br><span class="line">        size = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">            queue[<span class="number">0</span>] = e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            siftUp(i, e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	如果 comparator是null的话,就走  siftUpUsingComparator 方法.</span></span><br><span class="line"><span class="comment">	否则就会走 siftUpComparable 方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">            siftUpUsingComparator(k, x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            siftUpComparable(k, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	这里先判断k是大于0的,也就是不是第一个的意思.</span></span><br><span class="line"><span class="comment">	然后通过 (k - 1) &gt;&gt;&gt; 1 计算出来下标位置,下标是parent的值,调用 comparator.compare(x,e)来进行比较,如果是大于0的话,就不需要做任何处理。</span></span><br><span class="line"><span class="comment">	否则的话,就会 queue[k] = e ; k = parent; 来进行下标数值的替换处理.</span></span><br><span class="line"><span class="comment">	最后queue[k] = x 的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUpUsingComparator</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            Object e = queue[parent];</span><br><span class="line">            <span class="keyword">if</span> (comparator.compare(x, (E) e) &gt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            queue[k] = e;</span><br><span class="line">            k = parent;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[k] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	这个方法其实也是和上面的处理方式是类似的,通过比较值来进行处理.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUpComparable</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">        Comparable&lt;? <span class="keyword">super</span> E&gt; key = (Comparable&lt;? <span class="keyword">super</span> E&gt;) x;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            Object e = queue[parent];</span><br><span class="line">            <span class="keyword">if</span> (key.compareTo((E) e) &gt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            queue[k] = e;</span><br><span class="line">            k = parent;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[k] = key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	这里顺路看下 grow 扩容方法吧。 </span></span><br><span class="line"><span class="comment">	肯定是根据 queue的长度来进行扩容,如果值太小了的话,就会进行 二倍扩容.  否则的话,就是1.5倍扩容.</span></span><br><span class="line"><span class="comment">	最后调用 Arrays.copyOf() 来进行扩容数组操作</span></span><br><span class="line"><span class="comment">	这个扩容还是想对比较简单的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> oldCapacity = queue.length;</span><br><span class="line">        <span class="comment">// Double size if small; else grow by 50%</span></span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + ((oldCapacity &lt; <span class="number">64</span>) ?</span><br><span class="line">                                         (oldCapacity + <span class="number">2</span>) :</span><br><span class="line">                                         (oldCapacity &gt;&gt; <span class="number">1</span>));</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        queue = Arrays.copyOf(queue, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>peek 方法</p>
<p>这里可以看清楚的看到，出队列方法的值,就是默认的第一个嘛，这么一眼看下去就是很清楚明了的.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (size == <span class="number">0</span>) ? <span class="keyword">null</span> : (E) queue[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>remove 方法 :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	删除元素的方法。</span></span><br><span class="line"><span class="comment">	indexOf 如果返回的不是-1的话,就说明是有值得,就会走到 removeAt 方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = indexOf(o);</span><br><span class="line">    <span class="keyword">if</span> (i == -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        removeAt(i);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	indexOf 这个方法就是判断在这个集合里面有没有 o 这个值, 如果有的话就会返回对应的下标,如果不存在的话,就会返回-1的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(queue[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	removeAt 方法就会将传入进来的i的下标的值重置为null,这是满足 i == --size 的情况下.</span></span><br><span class="line"><span class="comment">	然后会将要删除的下标 i 和 对应的值 moved 传入到 siftDown 这个方法中.</span></span><br><span class="line"><span class="comment">	siftUp()是在前面有讲解到的.</span></span><br><span class="line"><span class="comment">	这里还是很明显的看到, priorityQueue是一直在维护这排序的关系。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">removeAt</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert i &gt;= 0 &amp;&amp; i &lt; size;</span></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">int</span> s = --size;</span><br><span class="line">        <span class="keyword">if</span> (s == i) <span class="comment">// removed last element</span></span><br><span class="line">            queue[i] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            E moved = (E) queue[s];</span><br><span class="line">            queue[s] = <span class="keyword">null</span>;</span><br><span class="line">            siftDown(i, moved);</span><br><span class="line">            <span class="keyword">if</span> (queue[i] == moved) &#123;</span><br><span class="line">                siftUp(i, moved);</span><br><span class="line">                <span class="keyword">if</span> (queue[i] != moved)</span><br><span class="line">                    <span class="keyword">return</span> moved;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	根据comparator走不同的方法</span></span><br><span class="line"><span class="comment">	可以看到走的二个方法，其中的区别是 comparator.compare 和 comparator.compareTo 调用的api是不一样的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">            siftDownUsingComparator(k, x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            siftDownComparable(k, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDownUsingComparator</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">            <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            Object c = queue[child];</span><br><span class="line">            <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (right &lt; size &amp;&amp;</span><br><span class="line">                comparator.compare((E) c, (E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">                c = queue[child = right];</span><br><span class="line">            <span class="keyword">if</span> (comparator.compare(x, (E) c) &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            queue[k] = c;</span><br><span class="line">            k = child;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[k] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDownComparable</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">        Comparable&lt;? <span class="keyword">super</span> E&gt; key = (Comparable&lt;? <span class="keyword">super</span> E&gt;)x;</span><br><span class="line">        <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;        <span class="comment">// loop while a non-leaf</span></span><br><span class="line">        <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">            <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// assume left child is least</span></span><br><span class="line">            Object c = queue[child];</span><br><span class="line">            <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (right &lt; size &amp;&amp;</span><br><span class="line">                ((Comparable&lt;? <span class="keyword">super</span> E&gt;) c).compareTo((E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">                c = queue[child = right];</span><br><span class="line">            <span class="keyword">if</span> (key.compareTo((E) c) &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            queue[k] = c;</span><br><span class="line">            k = child;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[k] = key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​       PriorityQueue 的存储数据结构是采用一个数据来进行存储,也就是一直在操作这个数组，只是每次都对数据进行了维护排序的关系。</p>
<p>​        PriorityQueue  是线程不安全的队列，这里还是提一下吧,因为添加元素和删除元素的方法都是没有进行加锁处理，当然了,如果不使用作为全局变量的话，自然是没有任何问题的,在局部变量里面.</p>
<p>​        </p>
]]></content>
      <categories>
        <category>Java集合源码</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>PriorityQueue</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap 源码阅读记录</title>
    <url>/2020/05/22/java_list/HashMap_Source/</url>
    <content><![CDATA[<p>HashMap 这种Key,Value 的存储结构,是我们在写代码中经常使用到的.可以说使用是非常频繁的,不过现在使用JSONObject也是非常多的,二者都是实现了Map接口。</p>
<p>所以看下HashMap源码是非常有必要的.</p>
<hr>
<h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p> 这里我们要看下 HashMap的内部类.</p>
<p> 这里的 Node 节点就是 HashMap存放数据的结构. hash 计算出来的哈希值,key就是HashMap中的key,value就是key对应的value的值.  这个 next 就是 key 不一样,计算出来的hash却是一样的,这样就有了hash冲突,所以就将节点存放在next里面了,从尾部插入进去. java8 后,如果next的长度是大于8的话,就会转化了红黑树来存储,那样获取值的速度变快了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>TreeNode 这个内部类就是表示红黑树的. TODO 后续进行更新.</p>
<p>参数, 可以看到 HashMap 是使用了一个数组来进行存储 Node节点.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>​    构造函数</p>
<p>​    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity</span></span><br><span class="line"><span class="comment"> * (16) and the default load factor (0.75).</span></span><br><span class="line"><span class="comment"> 	当使用无参构造函数的时候,只是对 loadFactor 进行了赋值操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传递一个int类型的参数时候,就会计息往下调用构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	对值进行判断,怕你可能传入进来一个负数来测试玩玩哈哈哈。</span></span><br><span class="line"><span class="comment">	最后调用到了tableSizeFor方法,可以看到这个方法是对传入进来的参数,进行一连串的位运算.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">        <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入 Map 的实现类的话,就是往下继续调用 putMapEntries方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">        putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	传入 m.size()的长度,长度大于0就会走逻辑代码.最后可以看到 迭代了m,然后调用putVal来将值放入Map中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = m.size();</span><br><span class="line">        <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">                <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">                <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                         (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">                <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                    threshold = tableSizeFor(t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">                resize();</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">                K key = e.getKey();</span><br><span class="line">                V value = e.getValue();</span><br><span class="line">                putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>put 添加方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据传入进来的key来计算对应的hash值</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	putVal 就是 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义一些变量</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    	<span class="comment">// table 赋值给 tab 并判断是否等于null 或者 tab的长度是否等于0,如果是的话，就会调用resize来进行扩容</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	扩容方法</span></span><br><span class="line"><span class="comment">	table使用 oldTab来进行存储,拿出oldTab的长度(如果oldTab是null的话,对应的长度就是为0).</span></span><br><span class="line"><span class="comment">	oldThr 是 记录 threshold 之前的值, newCap / newThr就是需要扩容使用到的变量命名.</span></span><br><span class="line"><span class="comment">	这里分为 </span></span><br><span class="line"><span class="comment">	1 : oldCap 是大于0的。 如果比 MAXIMUM_CAPACITY 还是要大的话,就说明里面存储的元素是太多了,就直接返回oldTab.  还有一种就是 newCap等于oldCap的1.5倍并且小于MAXIMUM_CAPACITY和oldCap是大于默认16的,就会进行1.5倍的扩容</span></span><br><span class="line"><span class="comment">	2 : oldThr 大于 0, newCap(扩容新长度) 就是等于 oldThe的值.</span></span><br><span class="line"><span class="comment">	3 : 否则就是都使用默认的值大小</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr;</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">/**</span></span><br><span class="line"><span class="comment">    	使用扩容后的newCap来创建一个数组,oldTab不是null,然后就需要将老的值赋值到新的newTab里面来.</span></span><br><span class="line"><span class="comment">        使用下标来进行迭代,获取每个下标的Node节点的值,然oldTab[j]赋值给e后,然后将oldTab[j]重置为null.</span></span><br><span class="line"><span class="comment">        这里面的进行Node复制是有分为下面几种, Node的next节点是没有值得,next下面是由值,e节点转化为了红黑树.</span></span><br><span class="line"><span class="comment">        1 : 如果e.next是null,也就是没有值,newTab[e.hash &amp; (newCap - 1)] = e来赋值.</span></span><br><span class="line"><span class="comment">        2 : 如果e是TreeNode的话,就会调用((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap)方法.</span></span><br><span class="line"><span class="comment">        3 : 然后可以看到 do while 循环里面, while 里面的条件是 e.next != null 才会进去,也就是next是由值得情况下才会进入到这里面来.然后可以看到一些系取节点啊,赋值给变量啊,然后赋值给新创建的Node数组下标然后将之前的node节点重置为null。 这里就需要读者对这些代码来慢慢消化了.仔细想看,就是对node节点的取值,赋值,重置等操作.</span></span><br><span class="line"><span class="comment">    	*/</span></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>get 方法,是通过key来获取出对应的value.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入key来计算出哈希值</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	如果 table不是Null,并且长度是大于0的,能够根据 (n-1) &amp; hash 得出来的下标是在tab里面能获取到值得,才会进入逻辑代码,否则就是返回null.</span></span><br><span class="line"><span class="comment">	如果first的hash是于传入进来的hash相同,斌且给key的值也是相同的话,就会返回first节点.</span></span><br><span class="line"><span class="comment">	拿node的next节点,如果是TreeNode的类,就会走TreeNode对应的getTreeNode方法(链表的长度大于8就会转化为红黑树). 否则的话就就迭代这个Node,退出的条件就是 e.next == null,就说说明下面没有对应的节点了。</span></span><br><span class="line"><span class="comment">	这里拿值得逻辑,还是比较容易理解得。 先根据计算出来得hash值,去数组中是否可以获取到对应得值,如果有就先会对first进行判断,是否满足条件.如果不满足的话,就说明这个key的hash是由冲突的,也就是由二个不同的值,计算出来相同的hash值,这个时候就会用链表(Node)来进行存储,如果长度是大于8的话,就会转化为TreeNode的红黑树.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">                ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">return</span> first;</span><br><span class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">return</span> e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>isEmpty 方法,这里就直接使用 size == 0 来进行判断,如果你的map是null的话,直接调用这个方法就会出现空指针.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​    这里只是选用了 put  和 get方法来进行讲解,因为这二个是经常调用的,所以得明白是一个怎么样得大体流程走向才行.</p>
]]></content>
      <categories>
        <category>Java集合源码</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
</search>
