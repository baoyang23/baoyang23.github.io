<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/favicon.ico?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="I kown today that i am i">
<meta property="og:type" content="website">
<meta property="og:title" content="YangL">
<meta property="og:url" content="http://www.lwfby.cn/index.html">
<meta property="og:site_name" content="YangL">
<meta property="og:description" content="I kown today that i am i">
<meta property="article:author" content="YangL">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.lwfby.cn/"/>





  <title>YangL</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">YangL</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Write good code</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            分类
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.lwfby.cn/2020/12/31/spring/inject-bean-one/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YangL">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/timg.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YangL">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/12/31/spring/inject-bean-one/" itemprop="url">inject_bean_one</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-12-31T00:13:13+08:00">
                2020-12-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index">
                    <span itemprop="name">Spring</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  8.5k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  41
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h4><p>   我们在创建 Spring Bean 的时候，是可以通过很多种方式来创建的. 但是这么多种方式,又是怎么加载的？是不是又有顺序呢？ 所以对 Spring 的  Bean 创建还是很有必要的.</p>
<h4 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h4><p>我们可以通过自己创建 bd  , 然后调用 registerBeanDefinition 方法给注册到 Spring 中来.</p>
<p>那么创建bd的怎么创建的呢？可以看到下面的二种创建方式.</p>
<p>这是通过 bd 来的.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanDefinitionCreateAndRegister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 : 通过 BeanDefinitionBuilder 来创建 bd</span></span><br><span class="line">        BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder.genericBeanDefinition(Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        beanDefinitionBuilder.addPropertyValue(<span class="string">"id"</span>,<span class="number">9527</span>).addPropertyValue(<span class="string">"name"</span>,<span class="string">"GavinYang"</span>);</span><br><span class="line">        BeanDefinition beanDefinition = beanDefinitionBuilder.getBeanDefinition();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 : 通过 new GenericBeanDefinition 来创建 bd.</span></span><br><span class="line">        GenericBeanDefinition genericBeanDefinition = <span class="keyword">new</span> GenericBeanDefinition();</span><br><span class="line">        genericBeanDefinition.setBeanClass(Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        MutablePropertyValues mutablePropertyValues = <span class="keyword">new</span> MutablePropertyValues();</span><br><span class="line">        mutablePropertyValues.add(<span class="string">"id"</span>,<span class="number">1</span>).add(<span class="string">"name"</span>,<span class="string">"Peterwong"</span>);</span><br><span class="line">        genericBeanDefinition.setPropertyValues(mutablePropertyValues);</span><br><span class="line"></span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里是给 bd 给注册到 Spring 容器里面来.</span></span><br><span class="line">        <span class="comment">// context.registerBeanDefinition("person",beanDefinition);</span></span><br><span class="line">        context.registerBeanDefinition(<span class="string">"peterwong"</span>,genericBeanDefinition);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果这里不调用 refresh 是会有错误的.</span></span><br><span class="line">        context.refresh();</span><br><span class="line"></span><br><span class="line">        Person person = context.getBean(Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        person.say();</span><br><span class="line">        System.out.println(person.toString());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>通过我们常用的注解</p>
<p>这里主要是 @Import/@Bean/@Component+@ComponentScan 方式来注入对象到 Spring 容器中来.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import</span>(ImportBeanConfigMain.ImportConfig<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ComponentScan</span>(<span class="title">basePackages</span> </span>= <span class="string">"com.iyang.bean.bd"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImportBeanConfigMain</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ImportBeanConfigMain</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ImportBeanConfigMain 无参数构造函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        context.register(ImportBeanConfigMain<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        context.refresh();</span><br><span class="line"></span><br><span class="line">        ImportConfig importConfig = context.getBean(ImportConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        Person person = context.getBean(Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        AnnotConfig annotConfig = context.getBean(AnnotConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        ExternalConfig externalConfig = context.getBean(ExternalConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(importConfig);</span><br><span class="line">        System.out.println(person);</span><br><span class="line">        System.out.println(annotConfig);</span><br><span class="line">        System.out.println(externalConfig);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过 <span class="doctag">@Import</span> 导入进来.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImportConfig</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">importMe</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"这是导入自己的方法"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"ImportConfig 的 toString 方法"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ImportConfig</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"ImportConfig无参数构造函数"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 使用 <span class="doctag">@Bean</span> 注解 注入 Bean 进来.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Person <span class="title">importPerson</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="number">9527</span>,<span class="string">"GavinYang"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Component</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotConfig</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AnnotConfig</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"AnnotConfig无参数构造函数"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"使用注解来注入bean进来."</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExternalConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExternalConfig</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"externalConfig 无参构造函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"externalConfig 打印 toString() 方法"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----------------------------------------------</span><br><span class="line">ImportBeanConfigMain 无参数构造函数    </span><br><span class="line">externalConfig 无参构造函数</span><br><span class="line">AnnotConfig无参数构造函数</span><br><span class="line">ImportConfig无参数构造函数</span><br><span class="line">person 有参数构造函数</span><br><span class="line">ImportConfig 的 toString 方法</span><br><span class="line">Person&#123;id=<span class="number">9527</span>, name=<span class="string">'GavinYang'</span>&#125;</span><br><span class="line">使用注解来注入bean进来.</span><br><span class="line">externalConfig 打印 toString() 方法</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 这里可以看到new出来的对象打印顺序.</span></span><br></pre></td></tr></table></figure>



<p>如果是基于创建 bd 的方式的话，是说明下是可以通过这种方式来将我们自己创建的对象给注入到Spring容器中来.我们主要来分析第二种,是做了什么事情.</p>
<h4 id="Import-Bean-Component-ComponentScan-分析"><a href="#Import-Bean-Component-ComponentScan-分析" class="headerlink" title="@Import/@Bean/@Component+@ComponentScan 分析"></a>@Import/@Bean/@Component+@ComponentScan 分析</h4><p>在分析之前，我们看下我们的 beanClass 是怎么先注册到 Spring中来的,也就是在org.springframework.beans.factory.support.DefaultListableBeanFactory#beanDefinitionMap和org.springframework.beans.factory.support.DefaultListableBeanFactory#beanDefinitionNames中,可以看到一个是Map类型的,一个是集合类型的.</p>
<p>我们把断点打在 org.springframework.beans.factory.support.DefaultListableBeanFactory#registerBeanDefinition 进来的方法上就可以看到,然后看堆栈信息,就可以看到怎么一步一步给添加进来的.</p>
<h5 id="注册-Spring-中来走的方法"><a href="#注册-Spring-中来走的方法" class="headerlink" title="注册 Spring 中来走的方法"></a>注册 Spring 中来走的方法</h5><p>  这里只用关注我们自己自己定义的，Spring内部的就不需要管了。</p>
<p>  <strong>ImportBeanConfigMain</strong></p>
<p>  org.springframework.context.annotation.AnnotatedBeanDefinitionReader#registerBean(java.lang.Class&lt;?&gt;)     —-&gt;     org.springframework.beans.factory.support.BeanDefinitionReaderUtils#registerBeanDefinition   —-&gt;   org.springframework.context.support.GenericApplicationContext#registerBeanDefinition</p>
<p><strong>externalConfig</strong></p>
<p>org.springframework.context.support.AbstractApplicationContext#invokeBeanFactoryPostProcessors  —-&gt;</p>
<p>org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanDefinitionRegistryPostProcessors    —–&gt;   org.springframework.context.annotation.ConfigurationClassPostProcessor#processConfigBeanDefinitions  —-&gt;   org.springframework.context.annotation.ConfigurationClassParser#parse(org.springframework.core.type.AnnotationMetadata, java.lang.String)   —&gt;  org.springframework.context.annotation.ConfigurationClassParser#doProcessConfigurationClass   —-&gt;</p>
<p>org.springframework.context.annotation.ClassPathBeanDefinitionScanner#doScan   —&gt;  org.springframework.context.annotation.ClassPathBeanDefinitionScanner#registerBeanDefinition </p>
<p><strong>importBeanConfigMain.AnnotConfig</strong></p>
<p>org.springframework.context.support.AbstractApplicationContext#invokeBeanFactoryPostProcessors —-&gt;org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors(org.springframework.beans.factory.config.ConfigurableListableBeanFactory, java.util.List&lt;org.springframework.beans.factory.config.BeanFactoryPostProcessor&gt;)     —-&gt;   org.springframework.context.annotation.ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry —-&gt;  org.springframework.context.annotation.ConfigurationClassPostProcessor#processConfigBeanDefinitions  —&gt;  org.springframework.context.annotation.ConfigurationClassParser#parse(org.springframework.core.type.AnnotationMetadata, java.lang.String)   —&gt; org.springframework.context.annotation.ConfigurationClassParser#doProcessConfigurationClass  —&gt;  org.springframework.context.annotation.ClassPathBeanDefinitionScanner#doScan   —&gt; org.springframework.context.annotation.ClassPathBeanDefinitionScanner#registerBeanDefinition</p>
<p><strong>com.iyang.bean.bd.ImportBeanConfigMain$ImportConfig</strong></p>
<p>org.springframework.context.support.AbstractApplicationContext#invokeBeanFactoryPostProcessors  —&gt;  org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanDefinitionRegistryPostProcessors   —&gt; org.springframework.context.annotation.ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry  —-&gt; org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader#loadBeanDefinitions   —&gt; org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader#registerBeanDefinitionForImportedConfigurationClass </p>
<p><strong>importPerson</strong></p>
<p>org.springframework.context.support.AbstractApplicationContext#invokeBeanFactoryPostProcessors  —&gt; org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanDefinitionRegistryPostProcessors   —&gt;   org.springframework.context.annotation.ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry   —&gt; org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader#loadBeanDefinitions   —&gt; org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader#loadBeanDefinitionsForBeanMethod  </p>
<p>可以看到除了 ImportBeanConfigMain 在扫描的时候就被注册到 spring 容器里面来，后面的都是走的 AbstractApplicationContext#invokeBeanFactoryPostProcessors 方法给注册到 Spring 容器中来了. 是不是应该详细分析下 invokeBeanFactoryPostProcessors  方法到了做了什么或者说用了什么,将我们定义的对象给注册到 Spring 容器中来了呢？</p>
<h5 id="invokeBeanFactoryPostProcessors-方法解析"><a href="#invokeBeanFactoryPostProcessors-方法解析" class="headerlink" title="invokeBeanFactoryPostProcessors 方法解析"></a>invokeBeanFactoryPostProcessors 方法解析</h5><p>从上面来看，这个方法并不是我们想象中那么简单的.</p>
<p>org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors(org.springframework.beans.factory.config.ConfigurableListableBeanFactory, java.util.List&lt;org.springframework.beans.factory.config.BeanFactoryPostProcessor&gt;)   委托到这里来进行解析的,所以我们直接深度分析这个方法即可.</p>
<p>上面可以看到都是走的 PostProcessorRegistrationDelegate 这个类,但是我们并没有在这个方法中找到这个类.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Invoke BeanDefinitionRegistryPostProcessors first, if any.</span></span><br><span class="line">   Set&lt;String&gt; processedBeans = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> BeanDefinitionRegistry) &#123;</span><br><span class="line">      BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;</span><br><span class="line">      List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;</span><br><span class="line">         <span class="keyword">if</span> (postProcessor <span class="keyword">instanceof</span> BeanDefinitionRegistryPostProcessor) &#123;</span><br><span class="line">            BeanDefinitionRegistryPostProcessor registryProcessor =</span><br><span class="line">                  (BeanDefinitionRegistryPostProcessor) postProcessor;</span><br><span class="line">            registryProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">            registryProcessors.add(registryProcessor);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            regularPostProcessors.add(postProcessor);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">      <span class="comment">// uninitialized to let the bean factory post-processors apply to them!</span></span><br><span class="line">      <span class="comment">// Separate between BeanDefinitionRegistryPostProcessors that implement</span></span><br><span class="line">      <span class="comment">// PriorityOrdered, Ordered, and the rest.</span></span><br><span class="line">      List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">      String[] postProcessorNames =</span><br><span class="line">            beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line">      <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">         <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">            processedBeans.add(ppName);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">      registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line"><span class="comment">// Note : 我们根据 debug 是可以跟进到这里的, 我们直接在这里打上断点,再来仔细看看这个方法做了什么事情.   // currentRegistryProcessors : org.springframework.context.annotation.ConfigurationClassPostProcessor      </span></span><br><span class="line"><span class="comment">// registry :  DefaultableListFactory </span></span><br><span class="line"><span class="comment">// 走完这个方法,我们的bean信息都注册到 Spring 的 DefaultLitableFactory中来了.      </span></span><br><span class="line">      invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">      currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.</span></span><br><span class="line">      postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line">      <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">         <span class="keyword">if</span> (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">            processedBeans.add(ppName);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">      registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">      invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">      currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.</span></span><br><span class="line">      <span class="keyword">boolean</span> reiterate = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">while</span> (reiterate) &#123;</span><br><span class="line">         reiterate = <span class="keyword">false</span>;</span><br><span class="line">         postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line">         <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!processedBeans.contains(ppName)) &#123;</span><br><span class="line">               currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">               processedBeans.add(ppName);</span><br><span class="line">               reiterate = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">         registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">         invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">         currentRegistryProcessors.clear();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Now, invoke the postProcessBeanFactory callback of all processors handled so far.</span></span><br><span class="line">      invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);</span><br><span class="line">      invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Invoke factory processors registered with the context instance.</span></span><br><span class="line">      invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">   <span class="comment">// uninitialized to let the bean factory post-processors apply to them!</span></span><br><span class="line">   String[] postProcessorNames =</span><br><span class="line">         beanFactory.getBeanNamesForType(BeanFactoryPostProcessor<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,</span></span><br><span class="line">   <span class="comment">// Ordered, and the rest.</span></span><br><span class="line">   List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">      <span class="keyword">if</span> (processedBeans.contains(ppName)) &#123;</span><br><span class="line">         <span class="comment">// skip - already processed in first phase above</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">         priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">         orderedPostProcessorNames.add(ppName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">   sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">   invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Next, invoke the BeanFactoryPostProcessors that implement Ordered.</span></span><br><span class="line">   List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(orderedPostProcessorNames.size());</span><br><span class="line">   <span class="keyword">for</span> (String postProcessorName : orderedPostProcessorNames) &#123;</span><br><span class="line">      orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">   invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Finally, invoke all other BeanFactoryPostProcessors.</span></span><br><span class="line">   List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(nonOrderedPostProcessorNames.size());</span><br><span class="line">   <span class="keyword">for</span> (String postProcessorName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">      nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Clear cached merged bean definitions since the post-processors might have</span></span><br><span class="line">   <span class="comment">// modified the original metadata, e.g. replacing placeholders in values...</span></span><br><span class="line">   beanFactory.clearMetadataCache();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="org-springframework-context-annotation-ConfigurationClassPostProcessor-processConfigBeanDefinitions-方法"><a href="#org-springframework-context-annotation-ConfigurationClassPostProcessor-processConfigBeanDefinitions-方法" class="headerlink" title="org.springframework.context.annotation.ConfigurationClassPostProcessor#processConfigBeanDefinitions 方法"></a>org.springframework.context.annotation.ConfigurationClassPostProcessor#processConfigBeanDefinitions 方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Build and validate a configuration model based on the registry of</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Configuration&#125; classes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processConfigBeanDefinitions</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">   List&lt;BeanDefinitionHolder&gt; configCandidates = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   String[] candidateNames = registry.getBeanDefinitionNames();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (String beanName : candidateNames) &#123;</span><br><span class="line">      BeanDefinition beanDef = registry.getBeanDefinition(beanName);</span><br><span class="line">      <span class="keyword">if</span> (beanDef.getAttribute(ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTE) != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Bean definition has already been processed as a configuration class: "</span> + beanDef);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// 对是否满足配置类进行检查, 这里我们的bean是importBeanConfigMain,满足条件的,具体可以看下面该方法的分析.然后会构建一个 bdHolder,添加到集合中来.</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">         configCandidates.add(<span class="keyword">new</span> BeanDefinitionHolder(beanDef, beanName));</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Return immediately if no @Configuration classes were found</span></span><br><span class="line">   <span class="keyword">if</span> (configCandidates.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Sort by previously determined @Order value, if applicable</span></span><br><span class="line"><span class="comment">// 这里会根据 @Order 来进行排序下.</span></span><br><span class="line"><span class="comment">// 从 Integer.compare(i1, i2) 来分析，应该是从小到大的排序,也就是说,越小的话,优先级就约高. </span></span><br><span class="line">   configCandidates.sort((bd1, bd2) -&gt; &#123;</span><br><span class="line">      <span class="keyword">int</span> i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());</span><br><span class="line">      <span class="keyword">int</span> i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());</span><br><span class="line">      <span class="keyword">return</span> Integer.compare(i1, i2);</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Detect any custom bean name generation strategy supplied through the enclosing application context</span></span><br><span class="line">   SingletonBeanRegistry sbr = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (registry <span class="keyword">instanceof</span> SingletonBeanRegistry) &#123;</span><br><span class="line"><span class="comment">// 满足类型条件强转下.       </span></span><br><span class="line">      sbr = (SingletonBeanRegistry) registry;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.localBeanNameGeneratorSet) &#123;</span><br><span class="line"><span class="comment">// 这里不包含,所以返回的就是null.</span></span><br><span class="line"><span class="comment">//org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#getSingleton(java.lang.String, boolean)          </span></span><br><span class="line">         BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(</span><br><span class="line">               AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR);</span><br><span class="line">         <span class="keyword">if</span> (generator != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.componentScanBeanNameGenerator = generator;</span><br><span class="line">            <span class="keyword">this</span>.importBeanNameGenerator = generator;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 确保environment不是null.</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.environment == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.environment = <span class="keyword">new</span> StandardEnvironment();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Parse each @Configuration class</span></span><br><span class="line"><span class="comment">// 创建一个解析 @Configuration 的对象.</span></span><br><span class="line"><span class="comment">// 在创建ConfigurationClassParser的这个有参构造函数里面,是可以看到又new了二个对象的,一个是ComponentScanAnnotationParser,一个是ConditionEvaluator.</span></span><br><span class="line"><span class="comment">// ComponentScanAnnotationParser 这个从名字上看,可以理解为@ComponentScan注解的解析.  </span></span><br><span class="line">   ConfigurationClassParser parser = <span class="keyword">new</span> ConfigurationClassParser(</span><br><span class="line">         <span class="keyword">this</span>.metadataReaderFactory, <span class="keyword">this</span>.problemReporter, <span class="keyword">this</span>.environment,</span><br><span class="line">         <span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.componentScanBeanNameGenerator, registry);</span><br><span class="line"></span><br><span class="line">   Set&lt;BeanDefinitionHolder&gt; candidates = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(configCandidates);</span><br><span class="line">   Set&lt;ConfigurationClass&gt; alreadyParsed = <span class="keyword">new</span> HashSet&lt;&gt;(configCandidates.size());</span><br><span class="line">   <span class="keyword">do</span> &#123;</span><br><span class="line"><span class="comment">// org.springframework.context.annotation.ConfigurationClassParser#processConfigurationClass这里走到这里,主要看这个方法中的doProcessConfigurationClass方法.       </span></span><br><span class="line">      parser.parse(candidates);</span><br><span class="line"><span class="comment">// 这里对我们上面解析出来的bean进行valiate,如果validate失败的话,那么最后是会抛出一个异常来的.	       </span></span><br><span class="line">      parser.validate();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 装有我们解析出来的bean信息       </span></span><br><span class="line">      Set&lt;ConfigurationClass&gt; configClasses = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(parser.getConfigurationClasses());</span><br><span class="line"><span class="comment">// 移除已经解析过了的.       </span></span><br><span class="line">      configClasses.removeAll(alreadyParsed);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Read the model and create bean definitions based on its content</span></span><br><span class="line"><span class="comment">//如果this.reader是null的话,就会new一个ConfigurationClassBeanDefinitionReader出来.       </span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.reader == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">this</span>.reader = <span class="keyword">new</span> ConfigurationClassBeanDefinitionReader(</span><br><span class="line">               registry, <span class="keyword">this</span>.sourceExtractor, <span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.environment,</span><br><span class="line">               <span class="keyword">this</span>.importBeanNameGenerator, parser.getImportRegistry());</span><br><span class="line">      &#125;</span><br><span class="line"> <span class="comment">// 这里对我们获取的 bean 再进行一个 load.      </span></span><br><span class="line">      <span class="keyword">this</span>.reader.loadBeanDefinitions(configClasses);</span><br><span class="line"><span class="comment">// 解析过了的bean放入到 alreadyParsed 中来.       </span></span><br><span class="line">      alreadyParsed.addAll(configClasses);</span><br><span class="line"></span><br><span class="line">      candidates.clear();</span><br><span class="line"><span class="comment">// 扫描获取出来的bean个数大于 初始化传入进来的个数.       </span></span><br><span class="line">      <span class="keyword">if</span> (registry.getBeanDefinitionCount() &gt; candidateNames.length) &#123;</span><br><span class="line">        <span class="comment">// 获取出新扫描的bean信息.  </span></span><br><span class="line">         String[] newCandidateNames = registry.getBeanDefinitionNames();</span><br><span class="line">        <span class="comment">// 旧的bean信息  </span></span><br><span class="line">         Set&lt;String&gt; oldCandidateNames = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(candidateNames));</span><br><span class="line">        <span class="comment">// 表示已经注册过了的  </span></span><br><span class="line">         Set&lt;String&gt; alreadyParsedClasses = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">       <span class="comment">// 将外面的 alreadyParsed 中的元素的 metadata的className给放入到alreadyParsedClasses集合中来.    </span></span><br><span class="line">         <span class="keyword">for</span> (ConfigurationClass configurationClass : alreadyParsed) &#123;</span><br><span class="line">            alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());</span><br><span class="line">         &#125;</span><br><span class="line"> <span class="comment">// 对new的集合中元素进行迭代         </span></span><br><span class="line">         <span class="keyword">for</span> (String candidateName : newCandidateNames) &#123;</span><br><span class="line">       <span class="comment">// 老的集合中不包含      </span></span><br><span class="line">            <span class="keyword">if</span> (!oldCandidateNames.contains(candidateName)) &#123;</span><br><span class="line">               BeanDefinition bd = registry.getBeanDefinition(candidateName);</span><br><span class="line">                </span><br><span class="line">       <span class="comment">// alreadyParsedClasses 中不包含并且检验出需要配置的,比如有一些@Configuration等特殊注解，这个方法在之前是有提到的.         </span></span><br><span class="line">               <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, <span class="keyword">this</span>.metadataReaderFactory) &amp;&amp;</span><br><span class="line">                     !alreadyParsedClasses.contains(bd.getBeanClassName())) &#123;</span><br><span class="line">           <span class="comment">// 满足上面这些条件就会放入到candidates集合中来.         </span></span><br><span class="line">                  candidates.add(<span class="keyword">new</span> BeanDefinitionHolder(bd, candidateName));</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         candidateNames = newCandidateNames;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// candidates 是 empty 就跳出while循环,否则就认为还有bean需要解析.    </span></span><br><span class="line">   <span class="keyword">while</span> (!candidates.isEmpty());</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes</span></span><br><span class="line"><span class="comment">// org.springframework.context.annotation.ConfigurationClassPostProcessor.importRegistry sbr不包含importRegistry的话,就会注册一个进去.   </span></span><br><span class="line">   <span class="keyword">if</span> (sbr != <span class="keyword">null</span> &amp;&amp; !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) &#123;</span><br><span class="line">      sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.metadataReaderFactory <span class="keyword">instanceof</span> CachingMetadataReaderFactory) &#123;</span><br><span class="line">      <span class="comment">// Clear cache in externally provided MetadataReaderFactory; this is a no-op</span></span><br><span class="line">      <span class="comment">// for a shared cache since it'll be cleared by the ApplicationContext.</span></span><br><span class="line"> <span class="comment">// 这里是清除缓存,也是清除一些集合.      </span></span><br><span class="line">      ((CachingMetadataReaderFactory) <span class="keyword">this</span>.metadataReaderFactory).clearCache();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>走完这个方法,如果是debug模式的话,就可以在 registry(也就是DefaultListableBeanFactory)的 beanDefintionMap和beanDefinitionNames这二个集合中是可以看到我们的bean名字已经bean对应的class信息的.</strong></p>
<h6 id="org-springframework-context-annotation-ConfigurationClassParser-doProcessConfigurationClass方法"><a href="#org-springframework-context-annotation-ConfigurationClassParser-doProcessConfigurationClass方法" class="headerlink" title="org.springframework.context.annotation.ConfigurationClassParser#doProcessConfigurationClass方法"></a>org.springframework.context.annotation.ConfigurationClassParser#doProcessConfigurationClass方法</h6><p>可以看到这个方法就是对 configuration 类进行处理的.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Apply processing and build a complete &#123;<span class="doctag">@link</span> ConfigurationClass&#125; by reading the</span></span><br><span class="line"><span class="comment"> * annotations, members and methods from the source class. This method can be called</span></span><br><span class="line"><span class="comment"> * multiple times as relevant sources are discovered.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> configClass the configuration class being build</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceClass a source class</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the superclass, or &#123;<span class="doctag">@code</span> null&#125; if none found or previously processed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> SourceClass <span class="title">doProcessConfigurationClass</span><span class="params">(ConfigurationClass configClass, SourceClass sourceClass)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是不是有 @Component 注解.  </span></span><br><span class="line">   <span class="keyword">if</span> (configClass.getMetadata().isAnnotated(Component<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())) </span>&#123;</span><br><span class="line">      <span class="comment">// Recursively process any member (nested) classes first</span></span><br><span class="line">      processMemberClasses(configClass, sourceClass);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Process any @PropertySource annotations</span></span><br><span class="line"><span class="comment">// 接着再处理 @PropertySources 注解. 可以看到这个注解貌似是和 Environment 有关系.   </span></span><br><span class="line">   <span class="keyword">for</span> (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">         sourceClass.getMetadata(), PropertySources<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">         <span class="title">org</span>.<span class="title">springframework</span>.<span class="title">context</span>.<span class="title">annotation</span>.<span class="title">PropertySource</span>.<span class="title">class</span>)) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.environment <span class="keyword">instanceof</span> ConfigurableEnvironment) &#123;</span><br><span class="line">         processPropertySource(propertySource);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         logger.info(<span class="string">"Ignoring @PropertySource annotation on ["</span> + sourceClass.getMetadata().getClassName() +</span><br><span class="line">               <span class="string">"]. Reason: Environment must implement ConfigurableEnvironment"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Process any @ComponentScan annotations</span></span><br><span class="line"><span class="comment">// 获取@ComponentScan 注解,我们这里是有的.    </span></span><br><span class="line">   Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">         sourceClass.getMetadata(), ComponentScans<span class="class">.<span class="keyword">class</span>, <span class="title">ComponentScan</span>.<span class="title">class</span>)</span>;</span><br><span class="line">   <span class="keyword">if</span> (!componentScans.isEmpty() &amp;&amp;</span><br><span class="line">         !<span class="keyword">this</span>.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123;</span><br><span class="line">      <span class="keyword">for</span> (AnnotationAttributes componentScan : componentScans) &#123;</span><br><span class="line">         <span class="comment">// The config class is annotated with @ComponentScan -&gt; perform the scan immediately</span></span><br><span class="line">          </span><br><span class="line"><span class="comment">// org.springframework.context.annotation.ComponentScanAnnotationParser#parse</span></span><br><span class="line"><span class="comment">// parse 方法内部是使用 ClassPathBeanDefinitionScanner 扫描器的,对resourcePattern/includeFilters/excludeFilters/lazyInit 是否有进行处理.</span></span><br><span class="line"><span class="comment">// 获取注解上的属性 basePackages/basePackageClasses的值,添加一个AbstractTypeHierarchyTraversingFilter,这个是ExcludeFilter</span></span><br><span class="line"><span class="comment">//最后来org.springframework.context.annotation.ClassPathBeanDefinitionScanner#doScan做扫描操作.</span></span><br><span class="line"><span class="comment">//doScan做了什么事情呢? 显示通过传入进来的包,调用findCandidateComponents获取出bd的集合来,ScopeMetadata设置也是默认的,用beanNameGenerator生成bean对应的beanName</span></span><br><span class="line"><span class="comment">//如果bd是AbstractBeanDefinition,再走一下postProcessBeanDefinition方法</span></span><br><span class="line"><span class="comment">//如果bd是AnnotatedBeanDefinition,会走AnnotationConfigUtils.processCommonDefinitionAnnotations()方法,也是对一些注解的属性进行设置值操作. 走个checkCandidat检查方法,确保bd再registry中不存在的,如果存在的话,那就说明是已经注册过了的.     //如果是不存在的话,就会new一个BeanDefinitionHolder来,然后走registerBeanDefinition给注册到Spring容器中来. 最后返回扫描获取到的bdHolder集合来.     </span></span><br><span class="line">         Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =</span><br><span class="line">               <span class="keyword">this</span>.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());</span><br><span class="line">         <span class="comment">// Check the set of scanned definitions for any further config classes and parse recursively if needed</span></span><br><span class="line">         <span class="keyword">for</span> (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123;</span><br><span class="line">            BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();</span><br><span class="line">            <span class="keyword">if</span> (bdCand == <span class="keyword">null</span>) &#123;</span><br><span class="line">               bdCand = holder.getBeanDefinition();</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// 可以看到这里, 我们在最初进入到processConfigBeanDefinitions来的时候,其实就已经是调用了这个方法,那么我们这里扫描获取的bean在此调用这个方法. 也就是确保,扫描获取的bean,也是有一些配置的注解并且也是需要解析的.           </span></span><br><span class="line">            <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line"><span class="comment">// org.springframework.context.annotation.ConfigurationClassParser#processConfigurationClass这里最后也是走到这里了.</span></span><br><span class="line"><span class="comment">// 最初我们是从parse.parse() 进来的,也是走的ConfigurationClassParser#processConfigurationClas,这里又走到了该方法.</span></span><br><span class="line"><span class="comment">// 也就说我们是调用这个方法,只要满足条件的话,就会一直调用这个方法,直到不满足条件为止.                </span></span><br><span class="line">               parse(bdCand.getBeanClassName(), holder.getBeanName());</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Process any @Import annotations</span></span><br><span class="line"><span class="comment">// 这里是对 @Import 注解进行处理. 该方法是有利用 importStack 来控制,</span></span><br><span class="line"><span class="comment">// 其内部又分为 @ImportSelector/@ImportBeanDefinitionRegistrar/无注解这三种情况.</span></span><br><span class="line"><span class="comment">// 获取完 bean 信息后,就又走到了org.springframework.context.annotation.ConfigurationClassParser#processConfigurationClass方法来.</span></span><br><span class="line"><span class="comment">// 最后importStack 调用 pop 给数据给弹出来.    </span></span><br><span class="line">   processImports(configClass, sourceClass, getImports(sourceClass), <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Process any @ImportResource annotations</span></span><br><span class="line"><span class="comment">// 对@ImportResource是否有进行判断.    </span></span><br><span class="line">   AnnotationAttributes importResource =</span><br><span class="line">         AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   <span class="keyword">if</span> (importResource != <span class="keyword">null</span>) &#123;</span><br><span class="line">      String[] resources = importResource.getStringArray(<span class="string">"locations"</span>);</span><br><span class="line">      Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(<span class="string">"reader"</span>);</span><br><span class="line">      <span class="keyword">for</span> (String resource : resources) &#123;</span><br><span class="line">         String resolvedResource = <span class="keyword">this</span>.environment.resolveRequiredPlaceholders(resource);</span><br><span class="line">         configClass.addImportedResource(resolvedResource, readerClass);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Process individual @Bean methods</span></span><br><span class="line"><span class="comment">// @Bean 注解处理.</span></span><br><span class="line"><span class="comment">//org.springframework.context.annotation.ConfigurationClassParser#retrieveBeanMethodMetadata , </span></span><br><span class="line"><span class="comment">// 这里对于主入口类进来,是没有这个配置的.    </span></span><br><span class="line">   Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);</span><br><span class="line">   <span class="keyword">for</span> (MethodMetadata methodMetadata : beanMethods) &#123;</span><br><span class="line">      configClass.addBeanMethod(<span class="keyword">new</span> BeanMethod(methodMetadata, configClass));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Process default methods on interfaces</span></span><br><span class="line"><span class="comment">// 对接口的进行处理. 这里目前也是没有的.    </span></span><br><span class="line">   processInterfaces(configClass, sourceClass);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Process superclass, if any</span></span><br><span class="line"><span class="comment">// 先是判断是不是有父类.    </span></span><br><span class="line">   <span class="keyword">if</span> (sourceClass.getMetadata().hasSuperClass()) &#123;</span><br><span class="line"><span class="comment">// 获取出父类信息       </span></span><br><span class="line">      String superclass = sourceClass.getMetadata().getSuperClassName();</span><br><span class="line"><span class="comment">// 父类不是null,不是java开头并且knownSuperclasses中不存在,就满满足条件.       </span></span><br><span class="line">      <span class="keyword">if</span> (superclass != <span class="keyword">null</span> &amp;&amp; !superclass.startsWith(<span class="string">"java"</span>) &amp;&amp;</span><br><span class="line">            !<span class="keyword">this</span>.knownSuperclasses.containsKey(superclass)) &#123;</span><br><span class="line">         <span class="keyword">this</span>.knownSuperclasses.put(superclass, configClass);</span><br><span class="line">         <span class="comment">// Superclass found, return its annotation metadata and recurse</span></span><br><span class="line">         <span class="keyword">return</span> sourceClass.getSuperClass();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// No superclass -&gt; processing is complete</span></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这里可以看到 doProcessConfigurationClass方法,是传入进来主类入口进行解析, 然后没满足一个条件的bean,都会在走一遍解析的方法,直到都走到没满足条件的.</strong></p>
<h6 id="org-springframework-context-annotation-ConfigurationClassUtils-checkConfigurationClassCandidate方法"><a href="#org-springframework-context-annotation-ConfigurationClassUtils-checkConfigurationClassCandidate方法" class="headerlink" title="org.springframework.context.annotation.ConfigurationClassUtils#checkConfigurationClassCandidate方法"></a>org.springframework.context.annotation.ConfigurationClassUtils#checkConfigurationClassCandidate方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Check whether the given bean definition is a candidate for a configuration class</span></span><br><span class="line"><span class="comment"> * (or a nested component class declared within a configuration/component class,</span></span><br><span class="line"><span class="comment"> * to be auto-registered as well), and mark it accordingly.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanDef the bean definition to check</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> metadataReaderFactory the current factory in use by the caller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> whether the candidate qualifies as (any kind of) configuration class</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkConfigurationClassCandidate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      BeanDefinition beanDef, MetadataReaderFactory metadataReaderFactory)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 先获取 beanName 出来</span></span><br><span class="line">   String className = beanDef.getBeanClassName();</span><br><span class="line">   <span class="keyword">if</span> (className == <span class="keyword">null</span> || beanDef.getFactoryMethodName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   AnnotationMetadata metadata;</span><br><span class="line"><span class="comment">// 判断 bd 是不是AnnotatedBeanDefinition 并且 确认 beanName是不是与前面获取出来的classsName是一样的.    </span></span><br><span class="line">   <span class="keyword">if</span> (beanDef <span class="keyword">instanceof</span> AnnotatedBeanDefinition &amp;&amp;</span><br><span class="line">         className.equals(((AnnotatedBeanDefinition) beanDef).getMetadata().getClassName())) &#123;</span><br><span class="line">      <span class="comment">// Can reuse the pre-parsed metadata from the given BeanDefinition...</span></span><br><span class="line"><span class="comment">// 获取类上的注解.我们这里获取出来的是 @Import 和 @ComponentScan       </span></span><br><span class="line">      metadata = ((AnnotatedBeanDefinition) beanDef).getMetadata();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (beanDef <span class="keyword">instanceof</span> AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) beanDef).hasBeanClass()) &#123;</span><br><span class="line">      <span class="comment">// Check already loaded Class if present...</span></span><br><span class="line">      <span class="comment">// since we possibly can't even load the class file for this Class.</span></span><br><span class="line">      Class&lt;?&gt; beanClass = ((AbstractBeanDefinition) beanDef).getBeanClass();</span><br><span class="line">      <span class="keyword">if</span> (BeanFactoryPostProcessor<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">beanClass</span>) ||</span></span><br><span class="line"><span class="class">            <span class="title">BeanPostProcessor</span>.<span class="title">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">beanClass</span>) ||</span></span><br><span class="line"><span class="class">            <span class="title">AopInfrastructureBean</span>.<span class="title">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">beanClass</span>) ||</span></span><br><span class="line"><span class="class">            <span class="title">EventListenerFactory</span>.<span class="title">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">beanClass</span>)) </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      metadata = AnnotationMetadata.introspect(beanClass);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(className);</span><br><span class="line">         metadata = metadataReader.getAnnotationMetadata();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Could not find class file for introspecting configuration annotations: "</span> +</span><br><span class="line">                  className, ex);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 获取@Configuration,我们这里没有,所以获取出来的null.   </span></span><br><span class="line">   Map&lt;String, Object&gt; config = metadata.getAnnotationAttributes(Configuration<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">   <span class="keyword">if</span> (config != <span class="keyword">null</span> &amp;&amp; !Boolean.FALSE.equals(config.get(<span class="string">"proxyBeanMethods"</span>))) &#123;</span><br><span class="line">      beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_FULL);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 注意这里的 isConfigurationCandidate方法,org.springframework.context.annotation.ConfigurationClassUtils#isConfigurationCandidate</span></span><br><span class="line"><span class="comment">// @Component/@ComponentScan/@Import/@ImportResource,只要有其中的一种的话，那么返回的就是true. </span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (config != <span class="keyword">null</span> || isConfigurationCandidate(metadata)) &#123;</span><br><span class="line"><span class="comment">// CONFIGURATION_CLASS_ATTRIBUTE 对应的值是org.springframework.context.annotation.ConfigurationClassPostProcessor.configurationClass       </span></span><br><span class="line">      beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_LITE);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// It's a full or lite configuration candidate... Let's determine the order value, if any.</span></span><br><span class="line"><span class="comment">// 获取 order,如果有的话,就会set进去.    </span></span><br><span class="line">   Integer order = getOrder(metadata);</span><br><span class="line">   <span class="keyword">if</span> (order != <span class="keyword">null</span>) &#123;</span><br><span class="line">      beanDef.setAttribute(ORDER_ATTRIBUTE, order);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可以看到这个方法最主的就是对一些类上是否有注解进行判断, 如果满足 @Configuration/@Component/@ComponentScan/@Import/@ImportResource,那么返回的就是会true,同时也会set一个CONFIGURATION_CLASS_ATTRIBUTE属性到bd里面来.</strong></p>
<h4 id="getBean方法分析"><a href="#getBean方法分析" class="headerlink" title="getBean方法分析"></a>getBean方法分析</h4><p>​    getBean 不仅仅是获取bean的效果,更是创建bean的，可以看到getBean最后走到了createBean方法来.</p>
<p>​    org.springframework.beans.factory.support.DefaultListableBeanFactory#preInstantiateSingletons : 这里我们直接定位到这个方法,来看下是怎么调用的,调用之前/实例化bean等过程,又做了什么事情？</p>
<h5 id="preInstantiateSingletons-方法"><a href="#preInstantiateSingletons-方法" class="headerlink" title="preInstantiateSingletons 方法"></a>preInstantiateSingletons 方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">      logger.trace(<span class="string">"Pre-instantiating singletons in "</span> + <span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span></span><br><span class="line">   <span class="comment">// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span></span><br><span class="line"><span class="comment">// 从 beanDefinitionNames 中获取出 beanName的集合.</span></span><br><span class="line"><span class="comment">// 这里获取出来的 beanNameList 不仅仅有Spring内部的,还有我们自己的.    </span></span><br><span class="line">   List&lt;String&gt; beanNames = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Trigger initialization of all non-lazy singleton beans...</span></span><br><span class="line">   <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">      RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line"><span class="comment">// bd不是抽象的,是单列的,不是赖加载的,就进入到这里来.       </span></span><br><span class="line">      <span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">    <span class="comment">// 判断是不是 FactoryBean      </span></span><br><span class="line">         <span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">            Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">            <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> FactoryBean) &#123;</span><br><span class="line">               <span class="keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line">               <span class="keyword">boolean</span> isEagerInit;</span><br><span class="line">               <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">                  isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)</span><br><span class="line">                              ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class="line">                        getAccessControlContext());</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span> &#123;</span><br><span class="line">                  isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">                        ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">                  getBean(beanName);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果不是 FactroyBean的话,就直接走 getBean方法.       </span></span><br><span class="line">            getBean(beanName);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Trigger post-initialization callback for all applicable beans...</span></span><br><span class="line"><span class="comment">// 根据 beanNames 来进行迭代.    </span></span><br><span class="line">   <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">   <span class="comment">// 根据 beanName 来获取对象.    </span></span><br><span class="line"><span class="comment">// org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#getSingleton(java.lang.String, boolean)       </span></span><br><span class="line">      Object singletonInstance = getSingleton(beanName);</span><br><span class="line">  <span class="comment">// 满足是 SmartInitializingSingleton 接口的子类. 最后就都会调用 afterSingletonsInstantiated 方法, 这个也算是bean自身实现SmartInitializingSingleton接口来做的一种扩展.  </span></span><br><span class="line">      <span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">         <span class="keyword">final</span> SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">         <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">               smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;, getAccessControlContext());</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 preInstanitateSingletons方法，根据beanDefinitionNames中注册过的beanName集合,调用getBean方法来创建这个bean. 当创建完所有的bean后,判断是不是有实现 SmartInitializingSingleton 接口的bean,如果有的话, 就会调用这个bean 的afterSingletonsInstantiated方法. </p>
<h6 id="doGetBean-方法"><a href="#doGetBean-方法" class="headerlink" title="doGetBean() 方法"></a>doGetBean() 方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return an instance, which may be shared or independent, of the specified bean.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name the name of the bean to retrieve</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> requiredType the required type of the bean to retrieve</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args arguments to use when creating a bean instance using explicit arguments</span></span><br><span class="line"><span class="comment"> * (only applied when creating a new instance as opposed to retrieving an existing one)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> typeCheckOnly whether the instance is obtained for a type check,</span></span><br><span class="line"><span class="comment"> * not for actual use</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> an instance of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeansException if the bean could not be created</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, @Nullable <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span></span><br><span class="line"><span class="function"><span class="params">      @Nullable <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="comment">// 获取beanName</span></span><br><span class="line">   <span class="keyword">final</span> String beanName = transformedBeanName(name);</span><br><span class="line">   Object bean;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span><br><span class="line"> <span class="comment">//   这里是判断是不是手动给添加到单例池里面去的.</span></span><br><span class="line">   Object sharedInstance = getSingleton(beanName);</span><br><span class="line">   <span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         <span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            logger.trace(<span class="string">"Returning eagerly cached instance of singleton bean '"</span> + beanName +</span><br><span class="line">                  <span class="string">"' that is not fully initialized yet - a consequence of a circular reference"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.trace(<span class="string">"Returning cached instance of singleton bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// 如果是从单例池里面获取出来的,就走这个方法.    </span></span><br><span class="line">      bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Fail if we're already creating this bean instance:</span></span><br><span class="line">      <span class="comment">// We're assumably within a circular reference.</span></span><br><span class="line">  <span class="comment">// 判断这个bean当前是不是已经在注册了,如果是的话,就会抛出异常来.  </span></span><br><span class="line"><span class="comment">//org.springframework.beans.factory.support.AbstractBeanFactory#prototypesCurrentlyInCreation,利用ThreadLocal来记录值,如果beanName是相同的话就会返回ture,否则就返回flase,这里返回的是false.       </span></span><br><span class="line">      <span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Check if bean definition exists in this factory.</span></span><br><span class="line"> <span class="comment">//  org.springframework.beans.factory.support.AbstractBeanFactory#getParentBeanFactory获取父工厂,这里返回的是null,也就是说是没有的.所以下面的if条件也就不会进去.     </span></span><br><span class="line">      BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line">      <span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">         <span class="comment">// Not found -&gt; check parent.</span></span><br><span class="line">         String nameToLookup = originalBeanName(name);</span><br><span class="line">         <span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(</span><br><span class="line">                  nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line">            <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (requiredType != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line">            <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// typeCheckOnly 在此处的值是 false.</span></span><br><span class="line"><span class="comment">//org.springframework.beans.factory.support.AbstractBeanFactory#alreadyCreated,利用Set集合来标记是否创建,可以看到往alreadyCreated中添加元素进去的时候,还使用了synchronized来加锁判断并且使用了双重if,可以看到我们在接触单例模式的时候，也是有使用  synchronized + 双重if的.      </span></span><br><span class="line">      <span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">         markBeanAsCreated(beanName);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 获取出 bd 来,org.springframework.beans.factory.support.AbstractBeanFactory#mergedBeanDefinitions,从这个ConcurrentHashMap中获取出来,也就是说这个mergedBeanDefinitions Map 中,key就是beanName,value就是对应的bd.          </span></span><br><span class="line">         <span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">          </span><br><span class="line"><span class="comment">// 对 bd 进行检查,如果是抽象的话,就会抛出异常来.          </span></span><br><span class="line">         checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Guarantee initialization of beans that the current bean depends on.</span></span><br><span class="line"> <span class="comment">// 获取 @DependsOn 注解.并且对 @Depends进行处理.         </span></span><br><span class="line">         String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">         <span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">               <span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                        <span class="string">"Circular depends-on relationship between '"</span> + beanName + <span class="string">"' and '"</span> + dep + <span class="string">"'"</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               registerDependentBean(dep, beanName);</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                  getBean(dep);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                        <span class="string">"'"</span> + beanName + <span class="string">"' depends on missing bean '"</span> + dep + <span class="string">"'"</span>, ex);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Create bean instance.</span></span><br><span class="line"> <span class="comment">// 确保 bd 是单例的.     </span></span><br><span class="line">         <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">            sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                  <span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line">                  <span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line">                  <span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">                  destroySingleton(beanName);</span><br><span class="line">                  <span class="keyword">throw</span> ex;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">             </span><br><span class="line"><span class="comment">// 获取bean实例             </span></span><br><span class="line">            bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">         &#125;</span><br><span class="line"><span class="comment">// 这里是实例化一个 多列的 bean</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">            <span class="comment">// It's a prototype -&gt; create a new instance.</span></span><br><span class="line">            Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               beforePrototypeCreation(beanName);</span><br><span class="line">               prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">               afterPrototypeCreation(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 这里操作的,不仅单列也不是多列.</span></span><br><span class="line">            String scopeName = mbd.getScope();</span><br><span class="line">            <span class="keyword">final</span> Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line">            <span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No Scope registered for scope name '"</span> + scopeName + <span class="string">"'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               Object scopedInstance = scope.get(beanName, () -&gt; &#123;</span><br><span class="line">                  beforePrototypeCreation(beanName);</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                     <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">finally</span> &#123;</span><br><span class="line">                     afterPrototypeCreation(beanName);</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">               bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line">                     <span class="string">"Scope '"</span> + scopeName + <span class="string">"' is not active for the current thread; consider "</span> +</span><br><span class="line">                     <span class="string">"defining a scoped proxy for this bean if you intend to refer to it from a singleton"</span>,</span><br><span class="line">                     ex);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">         cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Check if required type matches the type of the actual bean instance.</span></span><br><span class="line"> <span class="comment">// 不满足条件,所以没进入到这里.   </span></span><br><span class="line">   <span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">         <span class="keyword">if</span> (convertedBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> convertedBean;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">"Failed to convert bean '"</span> + name + <span class="string">"' to required type '"</span> +</span><br><span class="line">                  ClassUtils.getQualifiedName(requiredType) + <span class="string">"'"</span>, ex);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接返回了 bean 信息.    </span></span><br><span class="line">   <span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>doGetBean方法 :  可以看到该方法主要是对 bean 分为三种类型来进行初始化 , 分别是 mbd.isSingleton/mbd.isPrototype()/非前二者 这三种情况. 在分这三种情况之前,还对@DependsOn 注解来进行分析,也就说当你初始化这个bean的时候,如果它依赖了一个宁外的bean,就会先去初始化宁外一个bean,也就是调用了 getBean 方法, 而getBean方法就是走的 doGetBean()   —&gt; createBean()  也就是走到了自身这里,是一种递归调用. </p>
<p>然后我们这里是单例的,自然就往下走了 createBean 方法.</p>
<h6 id="createBean-方法"><a href="#createBean-方法" class="headerlink" title="createBean() 方法"></a>createBean() 方法</h6><p>从名字来看,还是可以很很闲的感受到,是创建bean的方法.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Central method of this class: creates a bean instance,</span></span><br><span class="line"><span class="comment"> * populates the bean instance, applies post-processors, etc.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #doCreateBean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">      logger.trace(<span class="string">"Creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   RootBeanDefinition mbdToUse = mbd;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Make sure bean class is actually resolved at this point, and</span></span><br><span class="line">   <span class="comment">// clone the bean definition in case of a dynamically resolved Class</span></span><br><span class="line">   <span class="comment">// which cannot be stored in the shared merged bean definition.</span></span><br><span class="line"><span class="comment">// 确定bean的class, 如果bd有beanClass的信息,就会直接返回.    </span></span><br><span class="line">   Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"><span class="comment">//如果这里从bd获取出来的class是有值的,然后bd是没有beanCalss,获取出来的beanClassName也是null的话,那么这里就会重新来构建出一个bd,并且设置上 beanClass信息.    </span></span><br><span class="line">   <span class="keyword">if</span> (resolvedClass != <span class="keyword">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      mbdToUse = <span class="keyword">new</span> RootBeanDefinition(mbd);</span><br><span class="line">      mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Prepare method overrides.</span></span><br><span class="line"><span class="comment">// 准备重写的方法信息,先判断是不是有重写的方法,    </span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      mbdToUse.prepareMethodOverrides();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(mbdToUse.getResourceDescription(),</span><br><span class="line">            beanName, <span class="string">"Validation of method overrides failed"</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 这是 Spring 系统默认的后置处理器,是有六个的.       </span></span><br><span class="line"><span class="comment">// ApplicationContextAwareProcessor ,  ConfigurationClassPostProcessor$ImportAwareBeanPostProcessor , PostProcessorRegistrationDelegate$BeanPostProcessorCheck , CommonAnnotationBeanPostProcessor ,  AutowiredAnnotationBeanPostProcessor ,  ApplicationListenerDetector ,        </span></span><br><span class="line">       </span><br><span class="line">      <span class="comment">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span></span><br><span class="line"><span class="comment">// Apply before-instantiation post-processors, resolving whether there is a before-instantiation shortcut for the specified bean. 可以看到这里有个应用实例化前的处理器,</span></span><br><span class="line"><span class="comment">//org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#resolveBeforeInstantiation,可以看到这个方法里面,满足条件的话,会调用applyBeanPostProcessorsBeforeInstantiation() / applyBeanPostProcessorsAfterInitialization() 这二个方法的.</span></span><br><span class="line"><span class="comment">// 走完 applyBeanPostProcessorsBeforeInstantiation 方法,如果前置处理器能够返回bean回来并且不是null的话,就会继续走applyBeanPostProcessorsAfterInitialization方法.</span></span><br><span class="line"><span class="comment">// 我们这里返回的 bean 是null,如果不是null的话,就会直接返回的.       </span></span><br><span class="line">      Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">      <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> bean;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line">            <span class="string">"BeanPostProcessor before instantiation of bean failed"</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的前置处理器applyBeanPostProcessorsBeforeInstantiation返回的bean是null的话,就会接着这个下面继续往下走.  于是就有了走 doCreateBean 方法.   </span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(<span class="string">"Finished creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"> <span class="comment">// 返回 bean 对象回去.      </span></span><br><span class="line">      <span class="keyword">return</span> beanInstance;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (BeanCreationException | ImplicitlyAppearedSingletonException ex) &#123;</span><br><span class="line">      <span class="comment">// A previously detected exception with proper bean creation context already,</span></span><br><span class="line">      <span class="comment">// or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.</span></span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">            mbdToUse.getResourceDescription(), beanName, <span class="string">"Unexpected exception during bean creation"</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>createBean 方法  :   可以看到createBean在创建之前走了前置处理器,如果前置处理器返回的bean不是null,那么也就没有下面的doCreateBean什么事情了.  如果返回的bean是null的话,那么就会走到下面的doCreateBean方法,可以理解为这个方法才是真正调用反射去获取 bean 对象实例的方法 , 并且其返回值 beanInstance 是直接返回返回去了,也没有做什么其他的处理.</p>
<h6 id="doCreateBean-方法"><a href="#doCreateBean-方法" class="headerlink" title="doCreateBean() 方法"></a>doCreateBean() 方法</h6><p>可以感觉到 doCreateBean 就是真正实例化bean的方法, 是不是Spring 加上了 do 开头的方法,才是真正干活的.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Actually create the specified bean. Pre-creation processing has already happened</span></span><br><span class="line"><span class="comment"> * at this point, e.g. checking &#123;<span class="doctag">@code</span> postProcessBeforeInstantiation&#125; callbacks.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Differentiates between default bean instantiation, use of a</span></span><br><span class="line"><span class="comment"> * factory method, and autowiring a constructor.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mbd the merged bean definition for the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args explicit arguments to use for constructor or factory method invocation</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a new instance of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeanCreationException if the bean could not be created</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #instantiateBean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #instantiateUsingFactoryMethod</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #autowireConstructor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Instantiate the bean.</span></span><br><span class="line">   BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 确定是单例,    </span></span><br><span class="line">   <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line"><span class="comment">// 从org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#factoryBeanInstanceCache缓存中remove掉.       </span></span><br><span class="line">      instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line"> <span class="comment">// 创建 bean 的实例对象.</span></span><br><span class="line"> <span class="comment">// 先根据 bd 获取出 beanClass,根据beanClass获取出如果是null并且不是public并且无参数构造函数不是public的话,就会抛出一个BeanCreationException异常来. </span></span><br><span class="line"><span class="comment">// 从bd获取出实例提供者信息,这里获取出来的是Null,所以也就不会往下走.</span></span><br><span class="line"><span class="comment">// 获取 mbd.getFactoryMethodName() 操作</span></span><br><span class="line"><span class="comment">// 用变量resolved/autowireNecessary布尔类型的来控制一些流程,  用传入进来的args参数来决定是走无参构造函数还是在有参构造函数,如果args是null的话,就走无参数构造函数.</span></span><br><span class="line"><span class="comment">// org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#determineConstructorsFromBeanPostProcessors, 该方法是获取出全部的 后置处理器,如果后置处理器是继承了SmartInstantiationAwareBeanPostProcessor的话,就会走到后置处理器的determineCandidateConstructors方法来,  根据 Constructor&lt;?&gt;[] ctors = ibp.determineCandidateConstructors(beanClass, beanName) 可以看到,最后返回的是一个构造方法,可以看到org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor#determineCandidateConstructors这个地方来. 这里目测是对@Autowired注解注入的对象进行操作.</span></span><br><span class="line"><span class="comment">//最后,看到这个方法:org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#instantiateBean   ----&gt;   org.springframework.beans.factory.support.SimpleInstantiationStrategy#instantiate(org.springframework.beans.factory.support.RootBeanDefinition, java.lang.String, org.springframework.beans.factory.BeanFactory) 走到这里, 先判断没有重写的方法,接着判断如果是接口的话,就会抛出异常来,用constructorToUse = clazz.getDeclaredConstructor();获取出构造方法,最后用BeanUtils.instantiateClass(constructorToUse)来实例化对象,可以看到这行代码走完,我们在无参构造函数中的输出语句就可以打印出来了.  将我们实例化出来的对象beanInstance用BeanWrapperImpl包装下,所以这里最后返回的就是   BeanWrapperImpl , 是对我们的目标对象进行一层包装过了的.     </span></span><br><span class="line">      instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 从包装了beanInstance的BeanWrapperImpl中获取出来bean和beanType来,    </span></span><br><span class="line">   <span class="keyword">final</span> Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">   Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 赋值beanType给mbd.resolvedTargetType    </span></span><br><span class="line">   <span class="keyword">if</span> (beanType != NullBean<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">      mbd.resolvedTargetType = beanType;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line">   <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="comment">// 这里后走了一个调用后置处理器的方法,是MergedBeanDefinitionPostProcessor接口的子类,就会调用到后置处理器的postProcessMergedBeanDefinition方法.从名字上看,是对bd进行合并的处理操作.	            </span></span><br><span class="line">            applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                  <span class="string">"Post-processing of merged bean definition failed"</span>, ex);</span><br><span class="line">         &#125;</span><br><span class="line">         mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line">   <span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line"><span class="comment">//  bd是单例的并且是循环引用的并且单例是创建的,就满足这个条件,这里是处理循环依赖问题?还是用于实现BeanFactoryAware这种来避免循环依赖?    </span></span><br><span class="line">   <span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">         isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">   <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(<span class="string">"Eagerly caching bean '"</span> + beanName +</span><br><span class="line">               <span class="string">"' to allow for resolving potential circular references"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//  添加到 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#registeredSingletons 中来.       </span></span><br><span class="line">      addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Initialize the bean instance.</span></span><br><span class="line">   Object exposedObject = bean;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 构建bean,这里走了 InstantiationAwareBeanPostProcessor 接口的实现类的后置处理器,如果满足条件就会走处理器的postProcessAfterInstantiation方法,该方法会返回一个布尔类型的值,如果是false的话,就会跳出循环来的.</span></span><br><span class="line"><span class="comment">// 下面还会走一个InstantiationAwareBeanPostProcessor接口的子类的后置处理器,满足条件就会走后置处理器的postProcessProperties方法,如果获取出来的PropertyValues pvsToUse是null的话,会继续走后置处理器的postProcessPropertyValues方法.       </span></span><br><span class="line">      populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line"><span class="comment">//  这里调用每个后置处理器的 postProcessBeforeInitialization 方法,</span></span><br><span class="line"><span class="comment">// org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#invokeInitMethods 该方法可以看到(InitializingBean) bean).afterPropertiesSet();对于afterPropertiesSet方法还是有点熟悉的.</span></span><br><span class="line"><span class="comment">//  接着就是调用每个后置处理器的postProcessAfterInitialization方法,       </span></span><br><span class="line">      exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">       </span><br><span class="line"><span class="comment">// 可以看到这二个方法都是在调用后置处理器来进行扩展.       </span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">         <span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">               mbd.getResourceDescription(), beanName, <span class="string">"Initialization of bean failed"</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//  earlySingletonExposure is true.  </span></span><br><span class="line">   <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line"><span class="comment">// 从单例池中根据 beanName 来获取对象.       </span></span><br><span class="line">      Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">       </span><br><span class="line"><span class="comment">// 获取出来的对象不是null的话,就会进入到这里来.       </span></span><br><span class="line">      <span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">            exposedObject = earlySingletonReference;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">            String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">            Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(dependentBeans.length);</span><br><span class="line">            <span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">               <span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">                  actualDependentBeans.add(dependentBean);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,</span><br><span class="line">                     <span class="string">"Bean with name '"</span> + beanName + <span class="string">"' has been injected into other beans ["</span> +</span><br><span class="line">                     StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">                     <span class="string">"] in its raw version as part of a circular reference, but has eventually been "</span> +</span><br><span class="line">                     <span class="string">"wrapped. This means that said other beans do not use the final version of the "</span> +</span><br><span class="line">                     <span class="string">"bean. This is often the result of over-eager type matching - consider using "</span> +</span><br><span class="line">                     <span class="string">"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Register bean as disposable.</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="comment">// 如果有必要的话,注册任意bean信息.      </span></span><br><span class="line">      registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">            mbd.getResourceDescription(), beanName, <span class="string">"Invalid destruction signature"</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>doCreateBean() 方法 : 该方法才是正在去走反射来实例化bean的. 并且在实例化这个bean之前和之后,都是有调用许多后置处理器的,也就是这个bean进行一些增强或者其他的处理. 从现在来看,都是Spring内置的处理器.我们后面可以跟着Spring里面的写法,来做相同的扩展处理.</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​    其实可以看到,我们通过这种方式给我们定义的 bean 给注入到 Spring 容器中, 先是通过我们定义的 @ComponentScan(basePackages = “com.iyang.bean.bd”) 来扫描，然后将扫描得到的信息给添加到Spring的信息池里面,也就是添加到集合中来了.  最后在getBean 方法中, 通过扫描获取到的beanNames集合进行迭代，然后挨个调用getBean()方法来实例化bean,  getBean()  方法中又走了  doGetBean () —-&gt; createBean()  —&gt;  doCreateBean()  方法， 然后每个方法有各自要做的事情，并且也会走相应的后置处理器.</p>
<p>​    最后，这是一个比较详细的getBean分析，但是还有更深入的 , 比如 : @Autowired / @DependsOn / 循环依赖等注入，需要扩展来讲.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.lwfby.cn/2020/12/29/spring/spring-refresh-work-flow/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YangL">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/timg.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YangL">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/12/29/spring/spring-refresh-work-flow/" itemprop="url">spring_refresh_work_flow</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-12-29T00:02:02+08:00">
                2020-12-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index">
                    <span itemprop="name">Spring</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  9k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  42
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>  这里是相对上一次再次的阅读和记录,比上次有了更深入的理解.</p>
<p>   这里是再次整理的阅读 Spring 的源码, 相对比上次的阅读，我希望这次可以更清晰&amp;更深刻的理解Spring,也不仅仅会从一个案例来进行分析，会结合多方面的知识来进行整理分析.</p>
<p>​    这里放上之前阅读的比例 :    <a href="https://github.com/baoyang23/source-notes/tree/master/java/spring_bean" target="_blank" rel="noopener">https://github.com/baoyang23/source-notes/tree/master/java/spring_bean</a></p>
<p>​    该目录下面有 :  bean/get/extend  三个主要地方的分析. </p>
<p>​    此模块还是讲述 整体的 flow,后面会对单个进行分析&amp;Spring提供怎么样的扩展方式来进行增强扩展等.</p>
<p> 案例入门操作的话,可以参考之前的博客.</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>​    这里我们先不忙这其他类型的bean分析, 就对我们作为 config 的 bean 进行分析. 先单个分析容易理解些.</p>
<p>​    入口类 : </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitWorkFlowSpring</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        AnnotationConfigApplicationContext context =</span><br><span class="line">                <span class="keyword">new</span> AnnotationConfigApplicationContext(YangBeanScannerConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        YangBeanScannerConfig yangBeanScannerConfig = context.getBean(YangBeanScannerConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        yangBeanScannerConfig.say();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>​    配置类:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span>(basePackages = <span class="string">"com.iyang.spring"</span>)</span><br><span class="line"><span class="meta">@Description</span>(value = <span class="string">"This is GavinYang DemoWorld."</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YangBeanScannerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">YangBeanScannerConfig</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"配置扫描初始化打印"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是从Spring容器中获取出来的"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，当我们启动 main 方法的时候，是可以看到 YangBeanScannerConfig 中构造函数打印的内容和调用say方法打印出来的内容.</p>
<p>基于这个基础上,我们debug一层一层的走进去看,Spring做了什么事情.</p>
<p>先进入到我们new出来的AnnotationConfigApplicationContext中来</p>
<p>调用自身的无参构造函数</p>
<p>调用 register 注册方法</p>
<p>最后调用一个 refresh, refresh 方法中是做了很多事的.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>();</span><br><span class="line">   register(componentClasses);</span><br><span class="line">   refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么有了入口，我们就根据这些方法来一个一个的分析.</p>
<h4 id="this-方法-—-gt-org-springframework-context-annotation-AnnotationConfigApplicationContext-AnnotationConfigApplicationContext"><a href="#this-方法-—-gt-org-springframework-context-annotation-AnnotationConfigApplicationContext-AnnotationConfigApplicationContext" class="headerlink" title="this() 方法 —&gt;  org.springframework.context.annotation.AnnotationConfigApplicationContext#AnnotationConfigApplicationContext()"></a>this() 方法 —&gt;  org.springframework.context.annotation.AnnotationConfigApplicationContext#AnnotationConfigApplicationContext()</h4><p>先来看 this 方法做了什么事情.</p>
<p>创建了二个对象，分别是 注解bd读取/类路口db扫描.</p>
<p>比如有意思的是,传入this(AnnotationConfigApplicationContext), 然后返回来的reader/scanner又属于this.也是相互之间各自都持有各自的引用.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.reader = <span class="keyword">new</span> AnnotatedBeanDefinitionReader(<span class="keyword">this</span>);</span><br><span class="line">   <span class="keyword">this</span>.scanner = <span class="keyword">new</span> ClassPathBeanDefinitionScanner(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="new-AnnotatedBeanDefinitionReader"><a href="#new-AnnotatedBeanDefinitionReader" class="headerlink" title="new AnnotatedBeanDefinitionReader"></a>new AnnotatedBeanDefinitionReader</h5><p>来，看下new一个对象做了什么事情.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotatedBeanDefinitionReader</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 这里的 getOrCreateEnvironment 方法中,AnnotationConfigApplicationContext是EnvironmentCapable的子类,</span></span><br><span class="line"><span class="comment">// 所以Environment也是从AnnotationConfigApplicationContext中获取出来的.    </span></span><br><span class="line">   <span class="keyword">this</span>(registry, getOrCreateEnvironment(registry));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--------------</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotatedBeanDefinitionReader</span><span class="params">(BeanDefinitionRegistry registry, Environment environment)</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 检验 registry/environment都不能为null.   </span></span><br><span class="line">		Assert.notNull(registry, <span class="string">"BeanDefinitionRegistry must not be null"</span>);</span><br><span class="line">		Assert.notNull(environment, <span class="string">"Environment must not be null"</span>);</span><br><span class="line">		<span class="keyword">this</span>.registry = registry;</span><br><span class="line"><span class="comment">// 这里将 registry/environment 给传入构造到 org.springframework.context.annotation.ConditionEvaluator 中来.</span></span><br><span class="line"><span class="comment">// ConditionEvaluator又借助org.springframework.context.annotation.ConditionEvaluator.ConditionContextImpl#ConditionContextImpl 来存储这些信息,所以这里最后的信息是在ConditionContextImpl中来了.    </span></span><br><span class="line">		<span class="keyword">this</span>.conditionEvaluator = <span class="keyword">new</span> ConditionEvaluator(registry, environment, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// org.springframework.context.annotation.AnnotationConfigUtils#registerAnnotationConfigProcessors(org.springframework.beans.factory.support.BeanDefinitionRegistry, java.lang.Object)</span></span><br><span class="line"><span class="comment">// 从该方法的名字上看,是对注册注解配置进行处理.    </span></span><br><span class="line">		AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="keyword">this</span>.registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="org-springframework-context-annotation-AnnotationConfigUtils-registerAnnotationConfigProcessors-org-springframework-beans-factory-support-BeanDefinitionRegistry-java-lang-Object-分析"><a href="#org-springframework-context-annotation-AnnotationConfigUtils-registerAnnotationConfigProcessors-org-springframework-beans-factory-support-BeanDefinitionRegistry-java-lang-Object-分析" class="headerlink" title="org.springframework.context.annotation.AnnotationConfigUtils#registerAnnotationConfigProcessors(org.springframework.beans.factory.support.BeanDefinitionRegistry, java.lang.Object) 分析"></a>org.springframework.context.annotation.AnnotationConfigUtils#registerAnnotationConfigProcessors(org.springframework.beans.factory.support.BeanDefinitionRegistry, java.lang.Object) 分析</h6><p>这里根据我们的案列，传入进来的source是null.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">registerAnnotationConfigProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      BeanDefinitionRegistry registry, @Nullable Object source)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 根据 registry 的类型来获取 DefaultListableBeanFactory.</span></span><br><span class="line"><span class="comment">// 这里的registry属于GenericApplicationContext,调用其getDefaultListableBeanFactory来获取.    </span></span><br><span class="line">   DefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);</span><br><span class="line">   <span class="keyword">if</span> (beanFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// beanFactory.getDependencyComparator() 返回的是null,满足条件.       </span></span><br><span class="line">      <span class="keyword">if</span> (!(beanFactory.getDependencyComparator() <span class="keyword">instanceof</span> AnnotationAwareOrderComparator)) &#123;</span><br><span class="line"><span class="comment">// 设置 AnnotationAwareOrderComparator 到beanFactory中来          </span></span><br><span class="line">         beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// get方法获取出来的是SimpleAutowireCandidateResolver,       </span></span><br><span class="line">      <span class="keyword">if</span> (!(beanFactory.getAutowireCandidateResolver() <span class="keyword">instanceof</span> ContextAnnotationAutowireCandidateResolver)) &#123;</span><br><span class="line"><span class="comment">// 设置ContextAnnotationAutowireCandidateResolver到beanFactory中来.          </span></span><br><span class="line">         beanFactory.setAutowireCandidateResolver(<span class="keyword">new</span> ContextAnnotationAutowireCandidateResolver());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Set&lt;BeanDefinitionHolder&gt; beanDefs = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以看到每个都有 internal 来特意表明内部的意思.    </span></span><br><span class="line"><span class="comment">// org.springframework.context.annotation.internalConfigurationAnnotationProcessor ---&gt;  ConfigurationClassPostProcessor</span></span><br><span class="line"><span class="comment">// org.springframework.context.annotation.internalAutowiredAnnotationProcessor  --&gt; AutowiredAnnotationBeanPostProcessor</span></span><br><span class="line"><span class="comment">// org.springframework.context.annotation.internalCommonAnnotationProcessor   ---&gt; CommonAnnotationBeanPostProcessor </span></span><br><span class="line"><span class="comment">// org.springframework.context.annotation.internalPersistenceAnnotationProcessor  ---&gt; PersistenceAnnotationBeanPostProcessor</span></span><br><span class="line"><span class="comment">// org.springframework.context.event.internalEventListenerProcessor   ---&gt; EventListenerMethodProcessor</span></span><br><span class="line"><span class="comment">// org.springframework.context.event.internalEventListenerFactory  --- &gt; DefaultEventListenerFactory</span></span><br><span class="line">   <span class="keyword">if</span> (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">      RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(ConfigurationClassPostProcessor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      def.setSource(source);</span><br><span class="line">      beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">      RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(AutowiredAnnotationBeanPostProcessor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      def.setSource(source);</span><br><span class="line">      beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Check for JSR-250 support, and if present add the CommonAnnotationBeanPostProcessor.</span></span><br><span class="line">   <span class="keyword">if</span> (jsr250Present &amp;&amp; !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">      RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(CommonAnnotationBeanPostProcessor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      def.setSource(source);</span><br><span class="line">      beanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor.</span></span><br><span class="line">   <span class="keyword">if</span> (jpaPresent &amp;&amp; !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">      RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         def.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME,</span><br><span class="line">               AnnotationConfigUtils<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()))</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">               <span class="string">"Cannot load optional framework class: "</span> + PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      def.setSource(source);</span><br><span class="line">      beanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">      RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(EventListenerMethodProcessor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      def.setSource(source);</span><br><span class="line">      beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) &#123;</span><br><span class="line">      RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(DefaultEventListenerFactory<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      def.setSource(source);</span><br><span class="line">      beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> beanDefs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里都是先判断这些内部的bean,是不是已经在 registry 中已经存在了,如果没有存在的话，就会利用类信息来构造出一个RootBeanDefinition来,接着就是调用 registerPostProcessor 方法给注册到 registry  中来.</p>
<p>最后返回一个注册过的 bean 的 Set 集合回去.</p>
<p>总结下这里就是为了给spring容器中注册一些内部的 bean 进去. 这些注册进去的bean,都是在后面初始化bean&amp;解析bean等情况有使用到的.</p>
<h5 id="new-ClassPathBeanDefinitionScanner-方法"><a href="#new-ClassPathBeanDefinitionScanner-方法" class="headerlink" title="new ClassPathBeanDefinitionScanner() 方法"></a>new ClassPathBeanDefinitionScanner() 方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathBeanDefinitionScanner</span><span class="params">(BeanDefinitionRegistry registry, <span class="keyword">boolean</span> useDefaultFilters)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>(registry, useDefaultFilters, getOrCreateEnvironment(registry));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------</span><br><span class="line"><span class="comment">// 最后走到 org.springframework.context.annotation.ClassPathBeanDefinitionScanner#ClassPathBeanDefinitionScanner(org.springframework.beans.factory.support.BeanDefinitionRegistry, boolean, org.springframework.core.env.Environment, org.springframework.core.io.ResourceLoader) 构造函数来.    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathBeanDefinitionScanner</span><span class="params">(BeanDefinitionRegistry registry, <span class="keyword">boolean</span> useDefaultFilters,</span></span></span><br><span class="line"><span class="function"><span class="params">			Environment environment, @Nullable ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		Assert.notNull(registry, <span class="string">"BeanDefinitionRegistry must not be null"</span>);</span><br><span class="line"><span class="comment">// 赋值 registry 来.    </span></span><br><span class="line">		<span class="keyword">this</span>.registry = registry;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (useDefaultFilters) &#123;</span><br><span class="line"><span class="comment">// 添加 filter 到 includeFilters 中来.</span></span><br><span class="line"><span class="comment">// AnnotationTypeFilter(Component.class)</span></span><br><span class="line"><span class="comment">// AnnotationTypeFilter(((Class&lt;? extends Annotation&gt;) ClassUtils.forName("javax.annotation.ManagedBean", cl)     </span></span><br><span class="line"><span class="comment">// 等信息进来      </span></span><br><span class="line">			registerDefaultFilters();</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">// org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#setEnvironment</span></span><br><span class="line"><span class="comment">// 设置 enviornment到父类中来.    </span></span><br><span class="line">		setEnvironment(environment);</span><br><span class="line"><span class="comment">// 这里也是这是到父类来了.</span></span><br><span class="line"><span class="comment">// 返回的resourcePatternResolver是AnnotationConfigApplicationContext.</span></span><br><span class="line"><span class="comment">// metadataReaderFactory 是 CachingMetadataReaderFactory 对象来.</span></span><br><span class="line"><span class="comment">// componentsIndex 是 null.    </span></span><br><span class="line">		setResourceLoader(resourceLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法可以看到,添加了三个 filter 到 includeFilters 中来.</p>
<p>设置environment / resource 到 其父类org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider 中来.</p>
<p>也就是setXXX方法是调用的父类.</p>
<h4 id="register-componentClasses-方法"><a href="#register-componentClasses-方法" class="headerlink" title="register(componentClasses)  方法"></a>register(componentClasses)  方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//  检验传入进来的 comonpentClasses是一定要有值的. </span></span><br><span class="line">   Assert.notEmpty(componentClasses, <span class="string">"At least one component class must be specified"</span>);</span><br><span class="line">   <span class="keyword">this</span>.reader.register(componentClasses);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-------------------------</span><br><span class="line"><span class="comment">// 这里从名字上就可以很容易看出是注册 bean 的    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (Class&lt;?&gt; componentClass : componentClasses) &#123;</span><br><span class="line">			registerBean(componentClass);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">-----------------------------</span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">doRegisterBean</span><span class="params">(Class&lt;T&gt; beanClass, @Nullable String name,</span></span></span><br><span class="line"><span class="function"><span class="params">			@Nullable Class&lt;? extends Annotation&gt;[] qualifiers, @Nullable Supplier&lt;T&gt; supplier,</span></span></span><br><span class="line"><span class="function"><span class="params">			@Nullable BeanDefinitionCustomizer[] customizers)</span> </span>&#123;</span><br><span class="line"><span class="comment">// new 一个 bd 出来.</span></span><br><span class="line">		AnnotatedGenericBeanDefinition abd = <span class="keyword">new</span> AnnotatedGenericBeanDefinition(beanClass);</span><br><span class="line"><span class="comment">// 这里没有 @Conditional 注解和 metadata 是 null 就会直接返回 false 来.    </span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.conditionEvaluator.shouldSkip(abd.getMetadata())) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		abd.setInstanceSupplier(supplier);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 在对象上获取 @Scope 注解,这里没有,所以就不会往下走.</span></span><br><span class="line"><span class="comment">// 这里返回的 ScopeMetadata应该是默认的,scopeName是singleton,scopedProxyMode是No/1    </span></span><br><span class="line">		ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(abd);</span><br><span class="line">		abd.setScope(scopeMetadata.getScopeName());</span><br><span class="line"><span class="comment">// 获取 beanName 来    </span></span><br><span class="line">		String beanName = (name != <span class="keyword">null</span> ? name : <span class="keyword">this</span>.beanNameGenerator.generateBeanName(abd, <span class="keyword">this</span>.registry));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对一些注解的处理.</span></span><br><span class="line"><span class="comment">// @Lazy , @Primary , @DependsOn , @Role , @Description 如果有这些注解的话,就会进行处理.</span></span><br><span class="line"><span class="comment">// 根据注解的名字,来调用相应的set方法.    </span></span><br><span class="line">		AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);</span><br><span class="line">    </span><br><span class="line"> <span class="comment">// 这里是对是否有 @Primary / @Lazy /   @Qualifier 注解进行判断.</span></span><br><span class="line">		<span class="keyword">if</span> (qualifiers != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (Class&lt;? extends Annotation&gt; qualifier : qualifiers) &#123;</span><br><span class="line">				<span class="keyword">if</span> (Primary<span class="class">.<span class="keyword">class</span> </span>== qualifier) &#123;</span><br><span class="line">					abd.setPrimary(<span class="keyword">true</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (Lazy<span class="class">.<span class="keyword">class</span> </span>== qualifier) &#123;</span><br><span class="line">					abd.setLazyInit(<span class="keyword">true</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					abd.addQualifier(<span class="keyword">new</span> AutowireCandidateQualifier(qualifier));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//这里 BeanDefinitionCustomizer[] customizers 数组如果有值的话,</span></span><br><span class="line"><span class="comment">// 会调用 customizer 的 customize 方法传入 bd.</span></span><br><span class="line"><span class="comment">// TODO , 这里由于没有具体的值,也不是很清楚做了什么事情.    </span></span><br><span class="line">		<span class="keyword">if</span> (customizers != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (BeanDefinitionCustomizer customizer : customizers) &#123;</span><br><span class="line">				customizer.customize(abd);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 bd 和 bean的名字，创建出一个 bd 的持有者.    </span></span><br><span class="line">		BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(abd, beanName);</span><br><span class="line"><span class="comment">// 这里由于传入进来的 scopeMetadata的值是NO,所以就直接返回bdHolder的持有者了.</span></span><br><span class="line"><span class="comment">// 可以看到返回下面的代码,是满足一个增强类的概念的.    </span></span><br><span class="line">		definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry); </span><br><span class="line"><span class="comment">// org.springframework.beans.factory.support.DefaultListableBeanFactory#registerBeanDefinition</span></span><br><span class="line"><span class="comment">//走到beanFactory中的registerBeanDefinition方法来,先是对bd进行校验,然后利用org.springframework.beans.factory.support.DefaultListableBeanFactory#beanDefinitionMap+beaName来判断是不是已经包含了该bean</span></span><br><span class="line"><span class="comment">// 此时如果你是debug的话,你会发现有五个内置的bean已经在该beanDefinitionMap中了.这也是对应了AnnotatedBeanDefinitionReader中处理的内置的bean.</span></span><br><span class="line"><span class="comment">//如果beanDefinitionMap中没有的话,就分为是不是已经开始创建bean了.</span></span><br><span class="line"><span class="comment">//如果没有已经开始创建了,就添加到beanDefinitionMap中来,beanName也会添加到beanDefinitionNames,其实这里有个问题, beanDefinitionMap的key集合就已经是beanName集合了,为什么还单独使用一个集合来维护呢？</span></span><br><span class="line"><span class="comment">// 这样这个bean的信息和bd就放入到 BeanFactory中来了.    </span></span><br><span class="line"><span class="comment">// 如果有别名的注解或者配置的话,就会走到registry.registerAlias(beanName, alias);来进行别名的注册. </span></span><br><span class="line">		BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p>这里可以总结下看到 register 方法就是对我们的配置类进行扫描, 然后对是否有一些注解进行判断等. 最后使用 BeanDefinitionReaderUtils 工具类的方法将 bd 给 注册到 Spring 容器中来, 注意这时候是没有实例化我们的 YangBeanScannerConfig,只是封装成 bd  + beanName 给注册到 BeanFactory 的 beanDefinitionMap 中来了.</p>
<h4 id="refresh-方法"><a href="#refresh-方法" class="headerlink" title="refresh() 方法"></a>refresh() 方法</h4><p>​    更新方法，可以看到这个方法内部是走了很多方法,其逻辑也是比较绕的. 不过没事，我们一个一个方法的来看.</p>
<p> org.springframework.context.support.AbstractApplicationContext#refresh() </p>
<p>可以看到其内部的每个方法上面都是有一行注释的.  </p>
<p>于是我们挨个方法来debug进来分析.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用 Object 来当锁对象,避免多个线程同时调用到 refresh 方法来.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object startupShutdownMonitor = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">      <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">  </span><br><span class="line">      prepareRefresh();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">      prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">         postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">         invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">         registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">         initMessageSource();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">         initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">         onRefresh();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">         registerListeners();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">         finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">         finishRefresh();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line">                  <span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">         destroyBeans();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Reset 'active' flag.</span></span><br><span class="line">         cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">// Reset common introspection caches in Spring's core, since we</span></span><br><span class="line">         <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">         resetCommonCaches();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="prepareRefresh-方法"><a href="#prepareRefresh-方法" class="headerlink" title="prepareRefresh() 方法"></a>prepareRefresh() 方法</h5><p>从注释来看, 设置startup数据 &amp; 标识active来表示状态,同时也会初始化一些资源.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Prepare this context for refreshing, setting its startup date and</span></span><br><span class="line"><span class="comment"> * active flag as well as performing any initialization of property sources.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// Switch to active.</span></span><br><span class="line">   <span class="keyword">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line"><span class="comment">// 对状态标识的设置.    </span></span><br><span class="line">   <span class="keyword">this</span>.closed.set(<span class="keyword">false</span>);</span><br><span class="line">   <span class="keyword">this</span>.active.set(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(<span class="string">"Refreshing "</span> + <span class="keyword">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         logger.debug(<span class="string">"Refreshing "</span> + getDisplayName());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Initialize any placeholder property sources in the context environment.</span></span><br><span class="line"><span class="comment">// 这里暂时没有实现来做事情.    </span></span><br><span class="line">   initPropertySources();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Validate that all properties marked as required are resolvable:</span></span><br><span class="line">   <span class="comment">// see ConfigurablePropertyResolver#setRequiredProperties</span></span><br><span class="line"><span class="comment">// org.springframework.core.env.AbstractEnvironment#validateRequiredProperties</span></span><br><span class="line"><span class="comment">// 对 org.springframework.core.env.AbstractPropertyResolver#requiredProperties 进行检验,如果检验到有问题的话,就会抛出异常来.</span></span><br><span class="line"><span class="comment">// 这里是对 properties 进行检验.    </span></span><br><span class="line">   getEnvironment().validateRequiredProperties();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Store pre-refresh ApplicationListeners...</span></span><br><span class="line"><span class="comment">// earlyApplicationListeners是null的话,利用applicationListeners来初始化.   </span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.earlyApplicationListeners == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.earlyApplicationListeners = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="keyword">this</span>.applicationListeners);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 如果已经存在值了,就对  applicationListeners 清空，然后全部添加applicationListeners来.     </span></span><br><span class="line">      <span class="comment">// Reset local application listeners to pre-refresh state.</span></span><br><span class="line">      <span class="keyword">this</span>.applicationListeners.clear();</span><br><span class="line">      <span class="keyword">this</span>.applicationListeners.addAll(<span class="keyword">this</span>.earlyApplicationListeners);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Allow for the collection of early ApplicationEvents,</span></span><br><span class="line">   <span class="comment">// to be published once the multicaster is available...</span></span><br><span class="line">   <span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到该方法的话,对状态标识进行设置.  接着地 propertySources 资源来进行初始化, 于是就对property来进行检验.   接下来是对 earlyApplicationListeners/earlyApplicationEvents根据条件来初始化操作.</p>
<h5 id="obtainFreshBeanFactroy"><a href="#obtainFreshBeanFactroy" class="headerlink" title="obtainFreshBeanFactroy()"></a>obtainFreshBeanFactroy()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   refreshBeanFactory();</span><br><span class="line">   <span class="keyword">return</span> getBeanFactory();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---------------------------</span><br><span class="line">org.springframework.context.support.GenericApplicationContext#refreshBeanFactory</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 看到 compareAndSet 有点cas 的味道.    </span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException </span>&#123;    </span><br><span class="line">		<span class="keyword">if</span> (!<span class="keyword">this</span>.refreshed.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">					<span class="string">"GenericApplicationContext does not support multiple refresh attempts: just call 'refresh' once"</span>);</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">// private String id = ObjectUtils.identityToString(this);</span></span><br><span class="line"><span class="comment">// 这里获取出来的id在这个类被new或者子类调用父类的super()构造方法的时候,就已经被初始化值了的.    </span></span><br><span class="line">		<span class="keyword">this</span>.beanFactory.setSerializationId(getId());</span><br><span class="line">	&#125;    </span><br><span class="line">    </span><br><span class="line">-----------------</span><br><span class="line">org.springframework.context.support.GenericApplicationContext#getBeanFactory</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里就直接返回了 DefaultListableBeanFactory.   </span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ConfigurableListableBeanFactory <span class="title">getBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.beanFactory;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>该方法 设置了一个 SerializationId 到 beanFactory 中来. 最后也是返回了一个 DefaultListableBeanFactory 来.</p>
<h5 id="prepareBeanFactory-方法"><a href="#prepareBeanFactory-方法" class="headerlink" title="prepareBeanFactory() 方法"></a>prepareBeanFactory() 方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Configure the factory's standard context characteristics,</span></span><br><span class="line"><span class="comment"> * such as the context's ClassLoader and post-processors.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanFactory the BeanFactory to configure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// Tell the internal bean factory to use the context's class loader etc.</span></span><br><span class="line"><span class="comment">// org.springframework.core.io.DefaultResourceLoader#getClassLoader   </span></span><br><span class="line"><span class="comment">// 设置 class 加载器&amp;赋值进去.    </span></span><br><span class="line">   beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line"><span class="comment">// 将 beanClassLoader放入SpelParserConfiguration中来,SpelExpressionParser中有含有SpelParserConfiguration作为configuration,StandardBeanExpressionResolver属性又含有SpelExpressionParser. 这也就可以理解为beanClassLoader最后是放入到SpelParserConfiguration来.</span></span><br><span class="line">   beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 传入applicationContext和environment到ResourceEditorRegistrar对象来.</span></span><br><span class="line"><span class="comment">//然后添加到beanFactory中来.    </span></span><br><span class="line">   beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> ResourceEditorRegistrar(<span class="keyword">this</span>, getEnvironment()));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Configure the bean factory with context callbacks.</span></span><br><span class="line"><span class="comment">// 添加ApplicationContextAwareProcessor后置处理器到org.springframework.beans.factory.support.AbstractBeanFactory#beanPostProcessors中来.</span></span><br><span class="line"><span class="comment">// 在添加后置处理器到Spring容器之前,会判断这个后置处理起是不是InstantiationAwareBeanPostProcessor/DestructionAwareBeanPostProcessor 这二种情况.</span></span><br><span class="line"><span class="comment">// 最后添加到 beanPostProcessors 中来.    </span></span><br><span class="line">   beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</span><br><span class="line"><span class="comment">// 然后这里忽略了六种情况的接口. 为什么要忽略呢? 看一个地方.</span></span><br><span class="line"><span class="comment">// org.springframework.context.support.ApplicationContextAwareProcessor#postProcessBeforeInitialization &amp;  org.springframework.context.support.ApplicationContextAwareProcessor#invokeAwareInterfaces 结合这二个方法来看,是已经对这六种情况的接口做了处理的.    </span></span><br><span class="line">   beanFactory.ignoreDependencyInterface(EnvironmentAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ResourceLoaderAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   beanFactory.ignoreDependencyInterface(MessageSourceAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ApplicationContextAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// BeanFactory interface not registered as resolvable type in a plain factory.</span></span><br><span class="line">   <span class="comment">// MessageSource registered (and found for autowiring) as a bean.</span></span><br><span class="line"><span class="comment">// private final Map&lt;Class&lt;?&gt;, Object&gt; resolvableDependencies = new ConcurrentHashMap&lt;&gt;(16);    </span></span><br><span class="line"><span class="comment">// org.springframework.beans.factory.support.DefaultListableBeanFactory#resolvableDependencies,这里将 BeanFactory.class和beanFactory给添加到 resolvableDependencies中来了,这里可以看到resolvableDependencies的key是一个Class类型.</span></span><br><span class="line">   beanFactory.registerResolvableDependency(BeanFactory<span class="class">.<span class="keyword">class</span>, <span class="title">beanFactory</span>)</span>;</span><br><span class="line">   beanFactory.registerResolvableDependency(ResourceLoader<span class="class">.<span class="keyword">class</span>, <span class="title">this</span>)</span>;</span><br><span class="line">   beanFactory.registerResolvableDependency(ApplicationEventPublisher<span class="class">.<span class="keyword">class</span>, <span class="title">this</span>)</span>;</span><br><span class="line">   beanFactory.registerResolvableDependency(ApplicationContext<span class="class">.<span class="keyword">class</span>, <span class="title">this</span>)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Register early post-processor for detecting inner beans as ApplicationListeners.</span></span><br><span class="line"><span class="comment">// 这里又添加了一个后置处理器.</span></span><br><span class="line"><span class="comment">// 传入一个 ApplicationContext 给后置处理器,然后添加到BeanFactory中来.</span></span><br><span class="line"><span class="comment">// org.springframework.beans.factory.support.AbstractBeanFactory#beanPostProcessors,也即是添加到专门存放 后置处理器的集合中来了.    </span></span><br><span class="line">   beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found.</span></span><br><span class="line"><span class="comment">// beanFactory如果有loadTimeWeaver,那么就添加 LoadTimeWeaverAwareProcessor 后置处理器进来   </span></span><br><span class="line">   <span class="keyword">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">      <span class="comment">// Set a temporary ClassLoader for type matching.</span></span><br><span class="line">      beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Register default environment beans.</span></span><br><span class="line"><span class="comment">// 不包含environment/systemProperties/systemEnvironment，就会添加到org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#singletonObjects中来.    </span></span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看到,prepareBeanFactory 中做了这些事情 :  添加了 beanClassLoader,添加了二个后置处理器,然后注册了四个 BeanFactory/ResourceLoader/ApplicationEventPublisher/ApplicationContext 到DefaultListableBeanFactory#resolvableDependencies中来了.</p>
<p>最后判断beanFactory是不是不包含一些关于环境的bean,如果是的话,那就调用registerSingleton方法给注册进来.</p>
<p>还是可以看到，这里都是在为环境做准备工作.</p>
<h5 id="postProcessBeanFactory-方法"><a href="#postProcessBeanFactory-方法" class="headerlink" title="postProcessBeanFactory() 方法"></a>postProcessBeanFactory() 方法</h5><p>略略略, 该方法暂无实现类来搞事情…..</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Modify the application context's internal bean factory after its standard</span></span><br><span class="line"><span class="comment"> * initialization. All bean definitions will have been loaded, but no beans</span></span><br><span class="line"><span class="comment"> * will have been instantiated yet. This allows for registering special</span></span><br><span class="line"><span class="comment"> * BeanPostProcessors etc in certain ApplicationContext implementations.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanFactory the bean factory used by the application context</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="invokeBeanFactoryPostProcessors-方法"><a href="#invokeBeanFactoryPostProcessors-方法" class="headerlink" title="invokeBeanFactoryPostProcessors 方法"></a>invokeBeanFactoryPostProcessors 方法</h5><p>这些是对beanFactoryPostProcessors进行处理. 是借用了 PostProcessorRegistrationDelegate.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Instantiate and invoke all registered BeanFactoryPostProcessor beans,</span></span><br><span class="line"><span class="comment"> * respecting explicit order if given.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Must be called before singleton instantiation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"><span class="comment">// getBeanFactoryPostProcessors() 获取出来的是空集合.    </span></span><br><span class="line">   PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime</span></span><br><span class="line">   <span class="comment">// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)</span></span><br><span class="line">   <span class="keyword">if</span> (beanFactory.getTempClassLoader() == <span class="keyword">null</span> &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">      beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="org-springframework-context-support-PostProcessorRegistrationDelegate-invokeBeanFactoryPostProcessors-org-springframework-beans-factory-config-ConfigurableListableBeanFactory-java-util-List-lt-org-springframework-beans-factory-config-BeanFactoryPostProcessor-gt"><a href="#org-springframework-context-support-PostProcessorRegistrationDelegate-invokeBeanFactoryPostProcessors-org-springframework-beans-factory-config-ConfigurableListableBeanFactory-java-util-List-lt-org-springframework-beans-factory-config-BeanFactoryPostProcessor-gt" class="headerlink" title="org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors(org.springframework.beans.factory.config.ConfigurableListableBeanFactory, java.util.List&lt;org.springframework.beans.factory.config.BeanFactoryPostProcessor&gt;)"></a>org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors(org.springframework.beans.factory.config.ConfigurableListableBeanFactory, java.util.List&lt;org.springframework.beans.factory.config.BeanFactoryPostProcessor&gt;)</h6><p>该方法从代码上来看,还是做了蛮多的事情.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Invoke BeanDefinitionRegistryPostProcessors first, if any.</span></span><br><span class="line">   Set&lt;String&gt; processedBeans = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里是满足条件的    </span></span><br><span class="line">   <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> BeanDefinitionRegistry) &#123;</span><br><span class="line">      BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;</span><br><span class="line">      List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对 beanFactory的后置处理器进行迭代处理操作.       </span></span><br><span class="line">      <span class="keyword">for</span> (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;</span><br><span class="line">         <span class="keyword">if</span> (postProcessor <span class="keyword">instanceof</span> BeanDefinitionRegistryPostProcessor) &#123;</span><br><span class="line">            BeanDefinitionRegistryPostProcessor registryProcessor =</span><br><span class="line">                  (BeanDefinitionRegistryPostProcessor) postProcessor;</span><br><span class="line">            registryProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">            registryProcessors.add(registryProcessor);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            regularPostProcessors.add(postProcessor);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">      <span class="comment">// uninitialized to let the bean factory post-processors apply to them!</span></span><br><span class="line">      <span class="comment">// Separate between BeanDefinitionRegistryPostProcessors that implement</span></span><br><span class="line">      <span class="comment">// PriorityOrdered, Ordered, and the rest.</span></span><br><span class="line">      List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.</span></span><br><span class="line"><span class="comment">// 根据 BeanDefinitionRegistryPostProcessor.class 来获取beanNames数组,</span></span><br><span class="line"><span class="comment">// org.springframework.context.annotation.internalConfigurationAnnotationProcessor 这里是获取到了一个内置的BeanFactroyPostProcessor.      </span></span><br><span class="line">      String[] postProcessorNames =</span><br><span class="line">            beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line">      <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line"> <span class="comment">// 判断是不是有PriorityOrdered,         </span></span><br><span class="line">         <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line"> <span class="comment">// 这里的getBean就已经对bean进行初始化，是真正的走反射构造函数拿出来的实例对象.</span></span><br><span class="line"> <span class="comment">// getBean需要仔细分析下，因为其内部在 createBean是走了很多后置处理起来进行增强的. </span></span><br><span class="line"><span class="comment">// ConfigurationClassPostProcessor 给添加进来.             </span></span><br><span class="line">            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line"><span class="comment">// beanName 添加到 processedBeans集合中来了.             </span></span><br><span class="line">            processedBeans.add(ppName);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// 对集合进行排序,从beanFactory中获取出dependencyComparator来,如果没有的话,就用OrderComparator.INSTANCE默认的</span></span><br><span class="line">      sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line"><span class="comment">// 全部添加到 registryProcessors 中来.       </span></span><br><span class="line">      registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line"><span class="comment">// org.springframework.context.annotation.ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry</span></span><br><span class="line"><span class="comment">//这里是进入到ConfigurationClassPostProcessor中来了,可以看到其接口 BeanDefinitionRegistryPostProcessor,是重写了接口的方法. </span></span><br><span class="line"><span class="comment">// ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry 做了什么事情呢?</span></span><br><span class="line"><span class="comment">// 用System.identityHashCode(registry);计算出registryId来,如果在org.springframework.context.annotation.ConfigurationClassPostProcessor#registriesPostProcessed/factoriesPostProcessed(二个集合)中已经包含了的话,就会抛出已经被调用过的异常来.如果没有的话,就会添加到registriesPostProcessed中来</span></span><br><span class="line"><span class="comment">// 继续看 org.springframework.context.annotation.ConfigurationClassPostProcessor#processConfigBeanDefinitions 方法,</span></span><br><span class="line"><span class="comment">//先从registry中获取beanNames来,这其中就有Spring内置的和我们自己定义的yangBeanScannerConfig</span></span><br><span class="line"><span class="comment">//对beanNames迭代处理,接着就用ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)来判断要不要添加到List&lt;BeanDefinitionHolder&gt; configCandidates集合中来,最后是我们定义的beanName给添加进来了.</span></span><br><span class="line"><span class="comment">// 对configCandidates集合进行排序,</span></span><br><span class="line"><span class="comment">// 创建一个ConfigurationClassParser对象来解析每个@Configuration注解类.调用其parse和validate方法,解析完后就是一个ConfigurationClass的Set集合,接着就是new了一个ConfigurationClassBeanDefinitionReader对象来,</span></span><br><span class="line"><span class="comment">// this.reader.loadBeanDefinitions(configClasses); 这行代码有点根据Config去解析bean的意思.    </span></span><br><span class="line"><span class="comment">// 具体要等到后面深度解析再反过来定位每行代码的意思.</span></span><br><span class="line"><span class="comment">// 最后再清除下缓存.       </span></span><br><span class="line">      invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line"><span class="comment">// 清空 currentRegistryProcessors 集合      </span></span><br><span class="line">      currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.</span></span><br><span class="line">      postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line">      <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line"><span class="comment">// 如果processedBeans集合中不包含并且type是Ordered.class才满足进来的条件.          </span></span><br><span class="line">         <span class="keyword">if</span> (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">            processedBeans.add(ppName);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// 所以这里的currentRegistryProcessors集合是空集合.       </span></span><br><span class="line">      sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">      registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">      invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">      currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.</span></span><br><span class="line"><span class="comment">// 这里用 while 循环来最后解析,判断从getBeanNamesForType获取出来的bean是不是被解析过了的. </span></span><br><span class="line"><span class="comment">// 也是用 processedBeans 集合来进行控制的. </span></span><br><span class="line">      <span class="keyword">boolean</span> reiterate = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">while</span> (reiterate) &#123;</span><br><span class="line">         reiterate = <span class="keyword">false</span>;</span><br><span class="line">         postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line">         <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!processedBeans.contains(ppName)) &#123;</span><br><span class="line">               currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">               processedBeans.add(ppName);</span><br><span class="line">               reiterate = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">         registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">         invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">         currentRegistryProcessors.clear();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Now, invoke the postProcessBeanFactory callback of all processors handled so far.</span></span><br><span class="line"><span class="comment">// org.springframework.context.annotation.ConfigurationClassPostProcessor#postProcessBeanFactory,这里是走到了postProcessBeanFactory回调方法来了.用org.springframework.context.annotation.ConfigurationClassPostProcessor#factoriesPostProcessed集合来控制是否解析过了.用registriesPostProcessed集合来判断上次是否进入到postProcessBeanDefinitionRegistry方法中来. 如果没有的话,就会再走一边processConfigBeanDefinitions,可以看到 postProcessBeanDefinitionRegistry 方法最后也是走到了processConfigBeanDefinitions中来了.</span></span><br><span class="line"><span class="comment">//org.springframework.context.annotation.ConfigurationClassPostProcessor#enhanceConfigurationClasses 该方法判断是不是需要代理来增强,这里是没有的,所以就直接return掉了.</span></span><br><span class="line"><span class="comment">// 最后添加一个 ImportAwareBeanPostProcessor 后置处理器进来.       </span></span><br><span class="line">      invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);</span><br><span class="line"><span class="comment">// 这里的regularPostProcessors 集合是empty.       </span></span><br><span class="line">      invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Invoke factory processors registered with the context instance.</span></span><br><span class="line">      invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">   <span class="comment">// uninitialized to let the bean factory post-processors apply to them!</span></span><br><span class="line"> <span class="comment">// org.springframework.context.annotation.internalConfigurationAnnotationProcessor和org.springframework.context.event.internalEventListenerProcessor这里获取出来的是二个.   </span></span><br><span class="line">   String[] postProcessorNames =</span><br><span class="line">         beanFactory.getBeanNamesForType(BeanFactoryPostProcessor<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,</span></span><br><span class="line">   <span class="comment">// Ordered, and the rest.</span></span><br><span class="line">   List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line"> <span class="comment">// 这里是对上面已经处理过了的进行过滤处理.      </span></span><br><span class="line">      <span class="keyword">if</span> (processedBeans.contains(ppName)) &#123;</span><br><span class="line">         <span class="comment">// skip - already processed in first phase above</span></span><br><span class="line">      &#125;</span><br><span class="line">       </span><br><span class="line"><span class="comment">// 这里分为 PriorityOrdered&amp;Ordered&amp;非前二者,分这三种情况分别放入到三个不同的集合中.</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">         priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">         orderedPostProcessorNames.add(ppName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里是可以看到先是对PriorityOrdered进行处理,再对Ordered处理,最后对非前二者进行处理.    </span></span><br><span class="line">   <span class="comment">// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">   sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">   invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Next, invoke the BeanFactoryPostProcessors that implement Ordered.</span></span><br><span class="line">   List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(orderedPostProcessorNames.size());</span><br><span class="line">   <span class="keyword">for</span> (String postProcessorName : orderedPostProcessorNames) &#123;</span><br><span class="line"> <span class="comment">// 注意这里是调用了getBean方法.      </span></span><br><span class="line">      orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 排序    </span></span><br><span class="line">   sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">   invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Finally, invoke all other BeanFactoryPostProcessors.</span></span><br><span class="line">   List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(nonOrderedPostProcessorNames.size());</span><br><span class="line">   <span class="keyword">for</span> (String postProcessorName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line"> <span class="comment">// 注意这里也是调用了 getBean 方法的.      </span></span><br><span class="line">      nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// org.springframework.context.event.EventListenerMethodProcessor#postProcessBeanFactory</span></span><br><span class="line"><span class="comment">// 这里由于只有一个EventListenerMethodProcessor处理器,所以对应起来的走到其postProcessBeanFactory方法中来.</span></span><br><span class="line"><span class="comment">// 这里也是调用 postProcessBeanFactory 方法的意思,也就是回调方法.    </span></span><br><span class="line">   invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Clear cached merged bean definitions since the post-processors might have</span></span><br><span class="line">   <span class="comment">// modified the original metadata, e.g. replacing placeholders in values...</span></span><br><span class="line"><span class="comment">// org.springframework.beans.factory.support.DefaultListableBeanFactory#clearMetadataCache</span></span><br><span class="line"><span class="comment">// 对 一些集合等进行清除.    </span></span><br><span class="line">   beanFactory.clearMetadataCache();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>至此就可以看到,该方法主要是对BeanDefinitionRegistryPostProcessor.class和BeanFactoryPostProcessor.class来进行处理.</p>
<p>BeanDefinitionRegistryPostProcessor 又是先处理PriorityOrdered,然后会将处理过的放入processedBeans集合中做一个总的记录，再处理非再processedBeans集合记录中的和是Ordered的,最后用while循环来再确认一遍是不是有还没处理的,这个时候控制条件也是通过 processedBeans来控制是不是处理过了的. 这里注意, 实例化是通过调用 getBean方法来实现的,所以你会发现再调用invokeBeanDefinitionRegistryPostProcessors方法之前,都是会有调用getBean方法的.</p>
<p>BeanFactoryPostProcessor 的处理,这里是一次获取出,然后分为 PriorityOrdered/Ordered/非前二者，分别放入三个集合中进行处理,前提是都没再 processedBeans 集合中.  这里可以看到,如果是PriorityOrdered类型的话，那么在分类的时候就已经调用getBean方法来实例化这个对象了，其他二者都是最后迭代遍历的时候调用getBean方法的. 最后都是sortPostProcessors走下排序，然后调用invokeBeanFactoryPostProcessors方法，这个方法的意思，也就是调用 重写的  postProcessBeanFactory 的方法.</p>
<h5 id="registerBeanPostProcessors-方法"><a href="#registerBeanPostProcessors-方法" class="headerlink" title="registerBeanPostProcessors 方法"></a>registerBeanPostProcessors 方法</h5><p>该方法传入 beanFactory进来,然后直接借助 PostProcessorRegistrationDelegate 来实现.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">   PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="registerBeanPostProcessors-方法-1"><a href="#registerBeanPostProcessors-方法-1" class="headerlink" title="registerBeanPostProcessors 方法"></a>registerBeanPostProcessors 方法</h6><p>从名字上不难理解，注册 Bean的后置处理器进来.</p>
<p>这里传入进来的  beanFactory 是 DefaultListableBeanFactory , applicationContext是AnnotationConfigApplicationContext</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取出 BeanPostProcessor 的名字.</span></span><br><span class="line"><span class="comment">// org.springframework.context.annotation.internalAutowiredAnnotationProcessor</span></span><br><span class="line"><span class="comment">// org.springframework.context.annotation.internalCommonAnnotationProcessor</span></span><br><span class="line"><span class="comment">// 这里获取出来的是二个内部的后置处理器,因为我这里并没有扩展,只是简单的进行说明了下,后面会详细分析。</span></span><br><span class="line"><span class="comment">// 就是这行代码获取的是什么.    </span></span><br><span class="line">   String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Register BeanPostProcessorChecker that logs an info message when</span></span><br><span class="line">   <span class="comment">// a bean is created during BeanPostProcessor instantiation, i.e. when</span></span><br><span class="line">   <span class="comment">// a bean is not eligible for getting processed by all BeanPostProcessors.</span></span><br><span class="line"> <span class="comment">// 6   </span></span><br><span class="line">   <span class="keyword">int</span> beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + <span class="number">1</span> + postProcessorNames.length;</span><br><span class="line"><span class="comment">// 传入beanFactory和个数,创建出一个检查bean的后置处理器来.</span></span><br><span class="line"><span class="comment">// org.springframework.context.support.PostProcessorRegistrationDelegate.BeanPostProcessorChecker</span></span><br><span class="line"><span class="comment">// 有兴趣的同学可以看到该后置处理器重写的方法做了什么事情.</span></span><br><span class="line"><span class="comment">// 最后添加到 beanFactory 中来.    </span></span><br><span class="line">   beanFactory.addBeanPostProcessor(<span class="keyword">new</span> BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Separate between BeanPostProcessors that implement PriorityOrdered,</span></span><br><span class="line">   <span class="comment">// Ordered, and the rest.</span></span><br><span class="line">   List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   List&lt;BeanPostProcessor&gt; internalPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line"> <span class="comment">// 对后置处理器进行迭代   </span></span><br><span class="line">   <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">      <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">   <span class="comment">// 注意这里调用 getBean 方法是已经实例化这个后置处理起了.</span></span><br><span class="line"><span class="comment">// AutowiredAnnotationBeanPostProcessor</span></span><br><span class="line"><span class="comment">// CommonAnnotationBeanPostProcessor</span></span><br><span class="line"> <span class="comment">// 这里实例化的是Spring内置的二个         </span></span><br><span class="line">         BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">         priorityOrderedPostProcessors.add(pp);</span><br><span class="line">      <span class="comment">// 内部的二个后置处理器都是有实现   MergedBeanDefinitionPostProcessor 的. </span></span><br><span class="line">         <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">            internalPostProcessors.add(pp);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">         orderedPostProcessorNames.add(ppName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// First, register the BeanPostProcessors that implement PriorityOrdered.</span></span><br><span class="line"><span class="comment">// 排序    </span></span><br><span class="line">   sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line"><span class="comment">// 添加到 org.springframework.beans.factory.support.AbstractBeanFactory#beanPostProcessors,也就是添加到Spring的BanFactory中来.    </span></span><br><span class="line">   registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Next, register the BeanPostProcessors that implement Ordered.</span></span><br><span class="line"><span class="comment">// 这里是对实现了 Ordered 类型的处理，很显然我这里是没有的.    </span></span><br><span class="line">   List&lt;BeanPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(orderedPostProcessorNames.size());</span><br><span class="line">   <span class="keyword">for</span> (String ppName : orderedPostProcessorNames) &#123;</span><br><span class="line">      BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      orderedPostProcessors.add(pp);</span><br><span class="line">      <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">         internalPostProcessors.add(pp);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">   registerBeanPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Now, register all regular BeanPostProcessors.</span></span><br><span class="line"><span class="comment">// 最后是对非 PriorityOrdered和Ordered的处理，    </span></span><br><span class="line">   List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(nonOrderedPostProcessorNames.size());</span><br><span class="line">   <span class="keyword">for</span> (String ppName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">      BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      nonOrderedPostProcessors.add(pp);</span><br><span class="line">      <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">         internalPostProcessors.add(pp);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Finally, re-register all internal BeanPostProcessors.</span></span><br><span class="line"><span class="comment">// 这里可以看到,最后对内部的后置处理器又重新注册了一遍.    </span></span><br><span class="line">   sortPostProcessors(internalPostProcessors, beanFactory);</span><br><span class="line">   registerBeanPostProcessors(beanFactory, internalPostProcessors);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Re-register post-processor for detecting inner beans as ApplicationListeners,</span></span><br><span class="line">   <span class="comment">// moving it to the end of the processor chain (for picking up proxies etc).</span></span><br><span class="line"><span class="comment">// ApplicationListenerDetector 这里也是对  ApplicationListenerDetector 也是重新注册一遍.   </span></span><br><span class="line">   beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(applicationContext));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>该方法 借助 org.springframework.context.support.PostProcessorRegistrationDelegate#registerBeanPostProcessors(org.springframework.beans.factory.config.ConfigurableListableBeanFactory, org.springframework.context.support.AbstractApplicationContext) 来，获取BeanPostProcessor的后置处理器,也是分为 PriorityOrdered / Ordered/ 前二者都没有，在 PriorityOrdered  分类的时候，就已经调用了 getBean方法来获取出 bean 对象来(这里依然是分为了三个集合来装数据&amp;处理).  然后调用getBean方法后,就调用registerBeanPostProcessors方法，将后置处理器给注册到 Spring 的BeanFactory 中来.</p>
<p>最后还会最内部的 BeanPost后置处理器 &amp; ApplicationListenerDetector 再重新注册一遍.</p>
<p>可能会比较好奇这个后置处理器是干什么用的 ？ 在后面实例化 bean 的时候，就可以看到是有走很多后置处理器的.</p>
<p>所以该方法是对 beanPost的后置处理器进行实例化并且注册到 Spring 的 BeanFactory 中来的.</p>
<h5 id="initMessageSource-方法"><a href="#initMessageSource-方法" class="headerlink" title="initMessageSource () 方法"></a>initMessageSource () 方法</h5><p>初始化 messageSource .</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize the MessageSource.</span></span><br><span class="line"><span class="comment"> * Use parent's if none defined in this context.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initMessageSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 获取出 beanFactory   </span></span><br><span class="line">   ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line"><span class="comment">// 如果 beanFactory 包含了名字是messageSource的本地bean.    </span></span><br><span class="line">   <span class="keyword">if</span> (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) &#123;</span><br><span class="line">  <span class="comment">// 从 beanFactory 中获取出来.     </span></span><br><span class="line">      <span class="keyword">this</span>.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      <span class="comment">// Make MessageSource aware of parent MessageSource.</span></span><br><span class="line"><span class="comment">// this.parent不是null并且   messageSource是   HierarchicalMessageSource类型 </span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.parent != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.messageSource <span class="keyword">instanceof</span> HierarchicalMessageSource) &#123;</span><br><span class="line">  <span class="comment">// 强转,判断  getParentMessageSource 是不是null,如果是null的话,就调用 getInternalParentMessageSource() 将获取出来的值给set进去.     </span></span><br><span class="line">         HierarchicalMessageSource hms = (HierarchicalMessageSource) <span class="keyword">this</span>.messageSource;</span><br><span class="line">         <span class="keyword">if</span> (hms.getParentMessageSource() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Only set parent context as parent MessageSource if no parent MessageSource</span></span><br><span class="line">            <span class="comment">// registered already.</span></span><br><span class="line">            hms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(<span class="string">"Using MessageSource ["</span> + <span class="keyword">this</span>.messageSource + <span class="string">"]"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 这里是不包含的情况.       </span></span><br><span class="line">      <span class="comment">// Use empty MessageSource to be able to accept getMessage calls.</span></span><br><span class="line">      DelegatingMessageSource dms = <span class="keyword">new</span> DelegatingMessageSource();</span><br><span class="line"><span class="comment">// getInternalParentMessageSource() 返回的是null       </span></span><br><span class="line">      dms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line">      <span class="keyword">this</span>.messageSource = dms;</span><br><span class="line"><span class="comment">// 注册到 beanFactory 中来       </span></span><br><span class="line">      beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, <span class="keyword">this</span>.messageSource);</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(<span class="string">"No '"</span> + MESSAGE_SOURCE_BEAN_NAME + <span class="string">"' bean, using ["</span> + <span class="keyword">this</span>.messageSource + <span class="string">"]"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>该方法可以看到是对 messageSource 的初始化进行操作.</p>
<h5 id="initApplicationEventMulticaster-方法"><a href="#initApplicationEventMulticaster-方法" class="headerlink" title="initApplicationEventMulticaster 方法"></a>initApplicationEventMulticaster 方法</h5><p>这里如果了解过 Spring 的Event 机制的话,是可以比较清晰的感觉到,是对 ApplicationEventMulticaster 的初始化.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize the ApplicationEventMulticaster.</span></span><br><span class="line"><span class="comment"> * Uses SimpleApplicationEventMulticaster if none defined in the context.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.context.event.SimpleApplicationEventMulticaster</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initApplicationEventMulticaster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取出 beanFactory 来.  </span></span><br><span class="line">   ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line"><span class="comment">// 判断 beanFactory 是否包含  applicationEventMulticaster    </span></span><br><span class="line">   <span class="keyword">if</span> (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) &#123;</span><br><span class="line"><span class="comment">// 如果包含的话，就直接从beanFactroy中获取出来,并且赋值给  applicationEventMulticaster  </span></span><br><span class="line">      <span class="keyword">this</span>.applicationEventMulticaster =</span><br><span class="line">            beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(<span class="string">"Using ApplicationEventMulticaster ["</span> + <span class="keyword">this</span>.applicationEventMulticaster + <span class="string">"]"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="comment">// 如果不包含的话,传入beanFactory接着就是new一个SimpleApplicationEventMulticaster出来      </span></span><br><span class="line">      <span class="keyword">this</span>.applicationEventMulticaster = <span class="keyword">new</span> SimpleApplicationEventMulticaster(beanFactory);</span><br><span class="line"><span class="comment">// 然后注册到 beanFactory 中来.      </span></span><br><span class="line">      beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, <span class="keyword">this</span>.applicationEventMulticaster);</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(<span class="string">"No '"</span> + APPLICATION_EVENT_MULTICASTER_BEAN_NAME + <span class="string">"' bean, using "</span> +</span><br><span class="line">               <span class="string">"["</span> + <span class="keyword">this</span>.applicationEventMulticaster.getClass().getSimpleName() + <span class="string">"]"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里可以看到, 主要是对 applicationEventMulticaster 的初始化.  </p>
<p>如果beanFactory有的话，就从其中拿，如果没有就自己new一个,最后注册到beanFactory中来.</p>
<h5 id="onRefresh-方法"><a href="#onRefresh-方法" class="headerlink" title="onRefresh() 方法"></a>onRefresh() 方法</h5><p>这里是没有做任何事情的，如果是SpringBoot的源码的，这里就是启动tomcat的.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Template method which can be overridden to add context-specific refresh work.</span></span><br><span class="line"><span class="comment"> * Called on initialization of special beans, before instantiation of singletons.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This implementation is empty.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeansException in case of errors</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #refresh()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">   <span class="comment">// For subclasses: do nothing by default.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h5 id="registerListeners-方法"><a href="#registerListeners-方法" class="headerlink" title="registerListeners() 方法"></a>registerListeners() 方法</h5><p>从名字来看,这里是注册监听器的意思.</p>
<p>org.springframework.context.event.AbstractApplicationEventMulticaster.ListenerRetriever#applicationListeners 这里是存放监听器的地方。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add beans that implement ApplicationListener as listeners.</span></span><br><span class="line"><span class="comment"> * Doesn't affect other listeners, which can be added without being beans.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerListeners</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// Register statically specified listeners first.</span></span><br><span class="line"><span class="comment">// getApplicationListeners() 获取出来的是空集合.    </span></span><br><span class="line">   <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123;</span><br><span class="line">      getApplicationEventMulticaster().addApplicationListener(listener);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">   <span class="comment">// uninitialized to let post-processors apply to them!</span></span><br><span class="line"><span class="comment">// 根据ApplicationListener来获取出监听器，这也也是没有的.     </span></span><br><span class="line">   String[] listenerBeanNames = getBeanNamesForType(ApplicationListener<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line">   <span class="keyword">for</span> (String listenerBeanName : listenerBeanNames) &#123;</span><br><span class="line">      getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Publish early application events now that we finally have a multicaster...</span></span><br><span class="line"><span class="comment">// 这里也是获取早初始的 ApplicationEvent.    </span></span><br><span class="line">   Set&lt;ApplicationEvent&gt; earlyEventsToProcess = <span class="keyword">this</span>.earlyApplicationEvents;</span><br><span class="line">   <span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (earlyEventsToProcess != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (ApplicationEvent earlyEvent : earlyEventsToProcess) &#123;</span><br><span class="line">         getApplicationEventMulticaster().multicastEvent(earlyEvent);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>org.springframework.context.event.SimpleApplicationEventMulticaster#multicastEvent(org.springframework.context.ApplicationEvent, org.springframework.core.ResolvableType) 可以看下这个方法或者后续我们再详细的看，Spring是如何发送event的，以及那些监听器是怎么获取到 event 的.</p>
<p>TODO :  这里后面是有待详细的讲解的.</p>
<h5 id="finishBeanFactoryInitialization-方法"><a href="#finishBeanFactoryInitialization-方法" class="headerlink" title="finishBeanFactoryInitialization() 方法"></a>finishBeanFactoryInitialization() 方法</h5><p>从名字理解上,这里是对 beanFactory的初始化结束.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Finish the initialization of this context's bean factory,</span></span><br><span class="line"><span class="comment"> * initializing all remaining singleton beans.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// Initialize conversion service for this context.</span></span><br><span class="line"> <span class="comment">// 如果beanFactroy包含conversionService并且type是ConversionService.class的话，</span></span><br><span class="line">   <span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">         beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line"><span class="comment">// 就会从beanFactory中获取出对象设置到beanFactory的ConversionService来.       </span></span><br><span class="line">      beanFactory.setConversionService(</span><br><span class="line">            beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Register a default embedded value resolver if no bean post-processor</span></span><br><span class="line">   <span class="comment">// (such as a PropertyPlaceholderConfigurer bean) registered any before:</span></span><br><span class="line">   <span class="comment">// at this point, primarily for resolution in annotation attribute values.</span></span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line"><span class="comment">//org.springframework.beans.factory.support.AbstractBeanFactory#addEmbeddedValueResolver //添加到org.springframework.beans.factory.support.AbstractBeanFactory#embeddedValueResolvers中来.      </span></span><br><span class="line">      beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span></span><br><span class="line"><span class="comment">// 根据  LoadTimeWeaverAware.class 来获取信息.   </span></span><br><span class="line"><span class="comment">// 很明显这里我们是没有配置的,所以也就是没有的.    </span></span><br><span class="line">   String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware<span class="class">.<span class="keyword">class</span>, <span class="title">false</span>, <span class="title">false</span>)</span>;</span><br><span class="line">   <span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">      getBean(weaverAwareName);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Stop using the temporary ClassLoader for type matching.</span></span><br><span class="line">   beanFactory.setTempClassLoader(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Allow for caching all bean definition metadata, not expecting further changes.</span></span><br><span class="line"><span class="comment">//org.springframework.beans.factory.support.DefaultListableBeanFactory#freezeConfiguration</span></span><br><span class="line"><span class="comment">// 设置configurationFrozen是true,</span></span><br><span class="line"><span class="comment">// 将beanDefinitionNames集合转哈为String类型的数组. StringUtils.toStringArray(this.beanDefinitionNames);使用这个方法即可.    </span></span><br><span class="line">   beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">   beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="preInstantiateSingletons-方法"><a href="#preInstantiateSingletons-方法" class="headerlink" title="preInstantiateSingletons 方法"></a>preInstantiateSingletons 方法</h6><p>这里就是对 单例池 里面的对象进行初始化,可以看到是有 getBean 方法的.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">      logger.trace(<span class="string">"Pre-instantiating singletons in "</span> + <span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span></span><br><span class="line">   <span class="comment">// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span></span><br><span class="line"><span class="comment">// 这里获取出来的 beanNames 是有6个的,其中五个是包含了内部的</span></span><br><span class="line"><span class="comment">//org.springframework.context.annotation.internalConfigurationAnnotationProcessor</span></span><br><span class="line"><span class="comment">//org.springframework.context.annotation.internalAutowiredAnnotationProcessor</span></span><br><span class="line"><span class="comment">//org.springframework.context.annotation.internalCommonAnnotationProcessor</span></span><br><span class="line"><span class="comment">//org.springframework.context.event.internalEventListenerProcessor</span></span><br><span class="line"><span class="comment">//org.springframework.context.event.internalEventListenerFactory</span></span><br><span class="line"><span class="comment">//yangBeanScannerConfig    </span></span><br><span class="line">   List&lt;String&gt; beanNames = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Trigger initialization of all non-lazy singleton beans...</span></span><br><span class="line">   <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">      RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">       </span><br><span class="line">  <span class="comment">// bd 不是抽象的&amp;是单例的&amp;不是赖加载的     </span></span><br><span class="line">      <span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">  <span class="comment">// 判断是不是 FactroyBean        </span></span><br><span class="line">         <span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">            Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">            <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> FactoryBean) &#123;</span><br><span class="line">               <span class="keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line">               <span class="keyword">boolean</span> isEagerInit;</span><br><span class="line">               <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">                  isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)</span><br><span class="line">                              ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class="line">                        getAccessControlContext());</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span> &#123;</span><br><span class="line">                  isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">                        ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">                  getBean(beanName);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 这里不是 FactoryBean  </span></span><br><span class="line"><span class="comment">// 可以看到当我走到yangBeanScannerConfig,我们定义的类的时候,走完这个方法，就可以看到com.iyang.spring.config.YangBeanScannerConfig#YangBeanScannerConfig中打印的语句了,也就是说走完这里，我们定义的bean就已经被Spring被实例化了.             </span></span><br><span class="line">            getBean(beanName);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Trigger post-initialization callback for all applicable beans...</span></span><br><span class="line"><span class="comment">// 这里再对 beanNames 进行迭代,如果是 SmartInitializingSingleton 的话，就会再调用    afterSingletonsInstantiated 方法.</span></span><br><span class="line">   <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">      Object singletonInstance = getSingleton(beanName);</span><br><span class="line">      <span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">         <span class="keyword">final</span> SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">         <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">               smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;, getAccessControlContext());</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以对我们定义的 bean 进行实例化，最后是调用了 getBean 方法， getBean 方法表面看上去是获取，其实如果没有的话，调用的是createBean方法, 也就是会实例化我们的bean。当然它肯定不会很简单的去调用反射就实例化完一个我们的bean,肯定是有一系列的走Spring内置的或者我们自己定义的后置处理器等操作.</p>
<p>getBean 方法需要后面专门领出来分析，不能简单的过，这里对 Spring 容器进行大致的flow过,所以还是比较轻描淡写的写过去.</p>
<h5 id="finishRefresh-方法"><a href="#finishRefresh-方法" class="headerlink" title="finishRefresh 方法"></a>finishRefresh 方法</h5><p>中文式的英语 : 结束刷新方法.</p>
<p>显示清除缓存,再是init了LifecycleProcessor,调用其onRefresh()方法,接近就是发送一个ContextRefreshedEvent事件出来.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Finish the refresh of this context, invoking the LifecycleProcessor's</span></span><br><span class="line"><span class="comment"> * onRefresh() method and publishing the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.context.event.ContextRefreshedEvent&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// Clear context-level resource caches (such as ASM metadata from scanning).</span></span><br><span class="line"><span class="comment">//对org.springframework.core.io.DefaultResourceLoader#resourceCaches进行清除.    </span></span><br><span class="line">   clearResourceCaches();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Initialize lifecycle processor for this context.</span></span><br><span class="line">   initLifecycleProcessor();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Propagate refresh to lifecycle processor first.</span></span><br><span class="line"><span class="comment">//org.springframework.context.support.DefaultLifecycleProcessor</span></span><br><span class="line"><span class="comment">//org.springframework.context.support.DefaultLifecycleProcessor#startBeans</span></span><br><span class="line">    </span><br><span class="line">   getLifecycleProcessor().onRefresh();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Publish the final event.</span></span><br><span class="line"><span class="comment">// 推送Event,这里的Event是 ContextRefreshedEvent.    </span></span><br><span class="line">   publishEvent(<span class="keyword">new</span> ContextRefreshedEvent(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Participate in LiveBeansView MBean, if active.</span></span><br><span class="line"><span class="comment">//org.springframework.context.support.LiveBeansView#registerApplicationContext</span></span><br><span class="line"><span class="comment">//先根据key:spring.liveBeansView.mbeanDomain获取value,这里获取出来的是null,</span></span><br><span class="line"><span class="comment">// 所以也就是没有下文了.    </span></span><br><span class="line">   LiveBeansView.registerApplicationContext(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="initLifecycleProcessor-方法"><a href="#initLifecycleProcessor-方法" class="headerlink" title="initLifecycleProcessor 方法 ()"></a>initLifecycleProcessor 方法 ()</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize the LifecycleProcessor.</span></span><br><span class="line"><span class="comment"> * Uses DefaultLifecycleProcessor if none defined in the context.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.context.support.DefaultLifecycleProcessor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initLifecycleProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取出 beanFactory 来.  </span></span><br><span class="line">   ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line"><span class="comment">// 判断beanFactory中是否包含lifecycleProcessor    </span></span><br><span class="line">   <span class="keyword">if</span> (beanFactory.containsLocalBean(LIFECYCLE_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line"><span class="comment">// 包含的话,就会获取出来,指向this.lifecycleProcessor       </span></span><br><span class="line">      <span class="keyword">this</span>.lifecycleProcessor =</span><br><span class="line">            beanFactory.getBean(LIFECYCLE_PROCESSOR_BEAN_NAME, LifecycleProcessor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(<span class="string">"Using LifecycleProcessor ["</span> + <span class="keyword">this</span>.lifecycleProcessor + <span class="string">"]"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// 如果不包含的话，就自己new一个,然后注册到Spring容器中来.    </span></span><br><span class="line">      DefaultLifecycleProcessor defaultProcessor = <span class="keyword">new</span> DefaultLifecycleProcessor();</span><br><span class="line">      defaultProcessor.setBeanFactory(beanFactory);</span><br><span class="line">      <span class="keyword">this</span>.lifecycleProcessor = defaultProcessor;</span><br><span class="line">      beanFactory.registerSingleton(LIFECYCLE_PROCESSOR_BEAN_NAME, <span class="keyword">this</span>.lifecycleProcessor);</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(<span class="string">"No '"</span> + LIFECYCLE_PROCESSOR_BEAN_NAME + <span class="string">"' bean, using "</span> +</span><br><span class="line">               <span class="string">"["</span> + <span class="keyword">this</span>.lifecycleProcessor.getClass().getSimpleName() + <span class="string">"]"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="publishEvent-方法"><a href="#publishEvent-方法" class="headerlink" title="publishEvent 方法"></a>publishEvent 方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Publish the given event to all listeners.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> event the event to publish (may be an &#123;<span class="doctag">@link</span> ApplicationEvent&#125;</span></span><br><span class="line"><span class="comment"> * or a payload object to be turned into a &#123;<span class="doctag">@link</span> PayloadApplicationEvent&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> eventType the resolved event type, if known</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 4.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(Object event, @Nullable ResolvableType eventType)</span> </span>&#123;</span><br><span class="line">   Assert.notNull(event, <span class="string">"Event must not be null"</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Decorate event as an ApplicationEvent if necessary</span></span><br><span class="line">   ApplicationEvent applicationEvent;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 对传入进来的 event 进行类型的判断.    </span></span><br><span class="line">   <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ApplicationEvent) &#123;</span><br><span class="line">      applicationEvent = (ApplicationEvent) event;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      applicationEvent = <span class="keyword">new</span> PayloadApplicationEvent&lt;&gt;(<span class="keyword">this</span>, event);</span><br><span class="line">      <span class="keyword">if</span> (eventType == <span class="keyword">null</span>) &#123;</span><br><span class="line">         eventType = ((PayloadApplicationEvent&lt;?&gt;) applicationEvent).getResolvableType();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Multicast right now if possible - or lazily once the multicaster is initialized</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.earlyApplicationEvents != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.earlyApplicationEvents.add(applicationEvent);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//org.springframework.context.event.SimpleApplicationEventMulticaster#multicastEvent(org.springframework.context.ApplicationEvent, org.springframework.core.ResolvableType)</span></span><br><span class="line"><span class="comment">//走到了这里来发送event的,       </span></span><br><span class="line">      getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Publish event via parent context as well...</span></span><br><span class="line"><span class="comment">// 这里的 parent是null.    </span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.parent <span class="keyword">instanceof</span> AbstractApplicationContext) &#123;</span><br><span class="line">         ((AbstractApplicationContext) <span class="keyword">this</span>.parent).publishEvent(event, eventType);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">this</span>.parent.publishEvent(event);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是发送ContextRefreshedEvent事件出来.</p>
<h5 id="resetCommonCaches-方法"><a href="#resetCommonCaches-方法" class="headerlink" title="resetCommonCaches 方法()"></a>resetCommonCaches 方法()</h5><p>可以看到  finally 代码块中是疯狂的清除各种缓存.</p>
<p>可以大家可以点进去详细的看下，具体就不仔细描述了.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Reset Spring's common reflection metadata caches, in particular the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ReflectionUtils&#125;, &#123;<span class="doctag">@link</span> AnnotationUtils&#125;, &#123;<span class="doctag">@link</span> ResolvableType&#125;</span></span><br><span class="line"><span class="comment"> * and &#123;<span class="doctag">@link</span> CachedIntrospectionResults&#125; caches.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 4.2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ReflectionUtils#clearCache()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> AnnotationUtils#clearCache()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ResolvableType#clearCache()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> CachedIntrospectionResults#clearClassLoader(ClassLoader)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">resetCommonCaches</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   ReflectionUtils.clearCache();</span><br><span class="line">   AnnotationUtils.clearCache();</span><br><span class="line">   ResolvableType.clearCache();</span><br><span class="line">   CachedIntrospectionResults.clearClassLoader(getClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>  最后总结下,Spring在加载 bean &amp; 处理内置的一些配置 &amp; 内部处理器的时候,是下了很多的功夫。可以看着这些方法一步一步的分析下去,理解起来，个人感觉这里还不是特别深入的跟进去了代码，只是一个简单的大概描述，更深入的知识需要更加详细的理解等了.</p>
<p>  这里只是简单的对这个整个flow来进行描述，还不是特别有详细的那种.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.lwfby.cn/2020/12/27/mybatis/mybatis-springboot/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YangL">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/timg.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YangL">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/12/27/mybatis/mybatis-springboot/" itemprop="url">mybatis-springboot</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-12-27T22:10:47+08:00">
                2020-12-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MyBatis/" itemprop="url" rel="index">
                    <span itemprop="name">MyBatis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3.3k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  14
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h4><p>​    MyBatis 与 SpringBoot 整合操作.  在这次整合的过程中,再次明白自己毫无疑问的是一个比较手残的同学了.</p>
<p>​    这里我们是基于 sql 语句写在 xml 里面进行整合的操作.</p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h4><p>​      这里说下创建一个 入门 项目的大致流程.</p>
<p>​       先创建一个 SpringBoot 项目 ,  引入依赖 :   <a href="https://github.com/baoyang23/mybtatis-analysis/blob/master/mybatis-spring-boot-hello/pom.xml" target="_blank" rel="noopener">https://github.com/baoyang23/mybtatis-analysis/blob/master/mybatis-spring-boot-hello/pom.xml</a></p>
<p>​        创建 MyBatis 的配置文件信息 :     <a href="https://github.com/baoyang23/mybtatis-analysis/blob/master/mybatis-spring-boot-hello/src/main/resources/mybatis-config.xml" target="_blank" rel="noopener">https://github.com/baoyang23/mybtatis-analysis/blob/master/mybatis-spring-boot-hello/src/main/resources/mybatis-config.xml</a></p>
<p>​        创建查询的 sql 语句，也就是我们的 mapper 文件 : <a href="https://github.com/baoyang23/mybtatis-analysis/tree/master/mybatis-spring-boot-hello/src/main/resources/mapper" target="_blank" rel="noopener">https://github.com/baoyang23/mybtatis-analysis/tree/master/mybatis-spring-boot-hello/src/main/resources/mapper</a></p>
<p>​       application.properties :  <a href="https://github.com/baoyang23/mybtatis-analysis/blob/master/mybatis-spring-boot-hello/src/main/resources/application.properties" target="_blank" rel="noopener">https://github.com/baoyang23/mybtatis-analysis/blob/master/mybatis-spring-boot-hello/src/main/resources/application.properties</a></p>
<p>​      扫描 mapper 接口 :  @MapperScan(basePackages = {“com.iyang.mybatis.springboot.hello.mapper”})  <a href="https://github.com/baoyang23/mybtatis-analysis/blob/master/mybatis-spring-boot-hello/src/main/java/com/iyang/mybatis/springboot/hello/MybatisSpringBootHelloApplication.java" target="_blank" rel="noopener">https://github.com/baoyang23/mybtatis-analysis/blob/master/mybatis-spring-boot-hello/src/main/java/com/iyang/mybatis/springboot/hello/MybatisSpringBootHelloApplication.java</a></p>
<p>这里是没有引入 web 依赖的 , 直接启动 main 方法 ,  然后就可以看到我们查询出来的结果了.</p>
<p>如果你熟悉 SpringBoot 源码的话，就会晓得有一个自动装配的操作.</p>
<p>如果不熟悉的话，那么就只能通过 @MapperScan(basePackages =  {“com.iyang.mybatis.springboot.hello.mapper”}) 去看 ,  这样有些是依赖自动装配（spring.factories） 中的配置加载的,  所以这里建议在看之前，如果是有一点 SpringBoot  扩展的知识了解是很好的。如果没有怎么办呢？没有就来看我接下来的内容。</p>
<p>其实这个地方你仔细想下，在 MyBatis 与 Spring 整合的时候，通过 xml 的方式给 MyBatis 的bean 已经  mybatis-spring 中自己写的扫描类，最后将扫描出来的 bd 在还没初始化之前，将bd 的beanClass 替换为我们的代理类.</p>
<p>那么，SpringBoot 与 MyBatis 整合的时候，最后要做的事情是不是也是将 MyBatis 的信息注入到 SpringBoot 来呢？只不过，SpringBoot 就不像 Spring 一样了，还将 bean 的信息配置到 xml 文件中.</p>
<p>于是，接下来跟我的阅读&amp;分析来一步一步的往下看.</p>
<h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4><h4 id="方法分析"><a href="#方法分析" class="headerlink" title="方法分析"></a>方法分析</h4><p>​     <strong>关注点一</strong> :   这里我们点入到    org.mybatis.spring.annotation.MapperScan 注解里面来，可以看到有一个   @Import(MapperScannerRegistrar.class) , 于是我们顺手跟进来 :   org.mybatis.spring.annotation.MapperScannerRegistrar ,  从名字上来，这个类就做了一个扫描mapper并且将mapper注入到Spring容器中来的事情.</p>
<p>​    <strong>关注点二</strong> :   我们从引入进来的依赖来看,    mybatis-spring-boot-starter-2.1.2.jar  跟进到 这个包来，可以看到这个包也是引入一些进来.   mybatis/mybatis-spring/spring-boot-starter-jdbc  这三个依赖我们应该不是很陌生的，mybatis-spring-boot-autoconfigure主要来看这个。    spring.factories 的作用大家可以去了解下，SpringBoot很多 EnableAutoConfiguration  的配置都是放入在这个里面的，在启动的时候，会去一层一层的去读取 spring.factories 文件的内容。  这里我们主要来看 :   org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration 这个类皆可.</p>
<p>​     MyBatis 在 properties 中的配置文件读取 :  org.mybatis.spring.boot.autoconfigure.MybatisProperties</p>
<p>可以看到该类上是有: @ConfigurationProperties(prefix = MybatisProperties.MYBATIS_PREFIX)</p>
<p>于是我们一下子就多了二个关注点, 这里我们可以采用之前的  笨方法，  当你对整合流程执行不是很熟悉的话，可以在这二个关注点的重写方法上都打算断点，看下其执行顺序是怎么执行的.    弄清楚了执行流程,就可以跟着流程来一步一步的分析. 从我们打上 debug 开始，往下的执行流程就是一步一步来的，那么就跟着我们debug  的方法来一步一步的分析.</p>
<p>org.mybatis.spring.annotation.MapperScannerRegistrar#registerBeanDefinitions() —&gt;     org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration#MybatisAutoConfiguration  —&gt;  org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration#afterPropertiesSet  —-&gt;    org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration#sqlSessionFactory  —&gt;   org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration#sqlSessionTemplate() —-&gt;</p>
<p><strong>org.mybatis.spring.annotation.MapperScannerRegistrar#registerBeanDefinitions() 方法</strong> :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * &#123;@inheritDoc&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Override</span><br><span class="line">public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123;</span><br><span class="line">&#x2F;***</span><br><span class="line">*  这里是获取出了注解里面属性的值. </span><br><span class="line">*&#x2F;   </span><br><span class="line">  AnnotationAttributes mapperScanAttrs &#x3D; </span><br><span class="line">  AnnotationAttributes.fromMap(importingClassMetadata.getAnnotationAttributes(MapperScan.class.getName()));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 能获取到有注解,不是null,就会走到下面的代码中来.    </span><br><span class="line">  if (mapperScanAttrs !&#x3D; null) &#123;</span><br><span class="line">    registerBeanDefinitions(importingClassMetadata, mapperScanAttrs, registry,</span><br><span class="line">        generateBaseBeanName(importingClassMetadata, 0));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* </span><br><span class="line">*&#x2F;</span><br><span class="line">  void registerBeanDefinitions(AnnotationMetadata annoMeta, AnnotationAttributes annoAttrs,</span><br><span class="line">      BeanDefinitionRegistry registry, String beanName) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 利用 BeanDefinitionBuilder 构造者,传入了一个 MapperScannerConfigurer.class</span><br><span class="line">&#x2F;&#x2F; 这里的 builder里面是有一个 bd 的,里面的beanClass就是 MapperScannerConfigurer      </span><br><span class="line">    BeanDefinitionBuilder builder &#x3D; BeanDefinitionBuilder.genericBeanDefinition(MapperScannerConfigurer.class);</span><br><span class="line">    builder.addPropertyValue(&quot;processPropertyPlaceHolders&quot;, true);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这里获取 @MapperScan 注解的属性, 如果属性是有值的话,就会设置到 builder 中来. </span><br><span class="line">    Class&lt;? extends Annotation&gt; annotationClass &#x3D; annoAttrs.getClass(&quot;annotationClass&quot;);</span><br><span class="line">    if (!Annotation.class.equals(annotationClass)) &#123;</span><br><span class="line">      builder.addPropertyValue(&quot;annotationClass&quot;, annotationClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; markerInterface &#x3D; annoAttrs.getClass(&quot;markerInterface&quot;);</span><br><span class="line">    if (!Class.class.equals(markerInterface)) &#123;</span><br><span class="line">      builder.addPropertyValue(&quot;markerInterface&quot;, markerInterface);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends BeanNameGenerator&gt; generatorClass &#x3D; annoAttrs.getClass(&quot;nameGenerator&quot;);</span><br><span class="line">    if (!BeanNameGenerator.class.equals(generatorClass)) &#123;</span><br><span class="line">      builder.addPropertyValue(&quot;nameGenerator&quot;, BeanUtils.instantiateClass(generatorClass));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends MapperFactoryBean&gt; mapperFactoryBeanClass &#x3D; annoAttrs.getClass(&quot;factoryBean&quot;);</span><br><span class="line">    if (!MapperFactoryBean.class.equals(mapperFactoryBeanClass)) &#123;</span><br><span class="line">      builder.addPropertyValue(&quot;mapperFactoryBeanClass&quot;, mapperFactoryBeanClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String sqlSessionTemplateRef &#x3D; annoAttrs.getString(&quot;sqlSessionTemplateRef&quot;);</span><br><span class="line">    if (StringUtils.hasText(sqlSessionTemplateRef)) &#123;</span><br><span class="line">      builder.addPropertyValue(&quot;sqlSessionTemplateBeanName&quot;, annoAttrs.getString(&quot;sqlSessionTemplateRef&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String sqlSessionFactoryRef &#x3D; annoAttrs.getString(&quot;sqlSessionFactoryRef&quot;);</span><br><span class="line">    if (StringUtils.hasText(sqlSessionFactoryRef)) &#123;</span><br><span class="line">      builder.addPropertyValue(&quot;sqlSessionFactoryBeanName&quot;, annoAttrs.getString(&quot;sqlSessionFactoryRef&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 下面是根据 value&#x2F;basePackages&#x2F;basePackageClasses 来获取包的信息,</span><br><span class="line">&#x2F;&#x2F; 这里也就说, 我们可以跟着这三个属性来配置包信息.      </span><br><span class="line">    List&lt;String&gt; basePackages &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    basePackages.addAll(</span><br><span class="line">        Arrays.stream(annoAttrs.getStringArray(&quot;value&quot;)).filter(StringUtils::hasText).collect(Collectors.toList()));</span><br><span class="line"></span><br><span class="line">    basePackages.addAll(Arrays.stream(annoAttrs.getStringArray(&quot;basePackages&quot;)).filter(StringUtils::hasText)</span><br><span class="line">        .collect(Collectors.toList()));</span><br><span class="line"></span><br><span class="line">    basePackages.addAll(Arrays.stream(annoAttrs.getClassArray(&quot;basePackageClasses&quot;)).map(ClassUtils::getPackageName)</span><br><span class="line">        .collect(Collectors.toList()));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果没有获取到包的信息,那就根据注解所在的路径来获取默认的路径.      </span><br><span class="line">    if (basePackages.isEmpty()) &#123;</span><br><span class="line">      basePackages.add(getDefaultBasePackage(annoMeta));</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F; 如果有lazyInitialization属性的值,就设置到 builder 中来. </span><br><span class="line">    String lazyInitialization &#x3D; annoAttrs.getString(&quot;lazyInitialization&quot;);</span><br><span class="line">    if (StringUtils.hasText(lazyInitialization)) &#123;</span><br><span class="line">      builder.addPropertyValue(&quot;lazyInitialization&quot;, lazyInitialization);</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F; 添加包的属性</span><br><span class="line">    builder.addPropertyValue(&quot;basePackage&quot;, StringUtils.collectionToCommaDelimitedString(basePackages));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;  getBeanDefinition() 在返回 bd 之前，会走一个 validate 方法.</span><br><span class="line">&#x2F;&#x2F; org.springframework.beans.factory.support.DefaultListableBeanFactory#registerBeanDefinition</span><br><span class="line">&#x2F;&#x2F; 走这个方法来将 bd 给注入到 Spring 容器中来.</span><br><span class="line">&#x2F;&#x2F; 这里注入进去的 beanName 的值是 :  com.iyang.mybatis.springboot.hello.MybatisSpringBootHelloApplication#MapperScannerRegistrar#0</span><br><span class="line">&#x2F;&#x2F; 注入进去的 bd 的 beanClass : class org.mybatis.spring.mapper.MapperScannerConfigurer </span><br><span class="line">    registry.registerBeanDefinition(beanName, builder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>这里可以总结下 registerBeanDefinitions 方法，该方法就是将 @MapperScan  的注解属性的值给到  : BeanDefinitionBuilder builder, 该builder  里面有bd,bd的beanClass是MapperScannerConfigurer，最后将MapperScannerConfigurer注入到 Spring 容器中来.</strong></p>
<hr>
<p><strong>MyBatisAutoConfiguration()  有参构造函数</strong></p>
<p>这里我们在 MybatisAutoConfiguration 构造函数上打上断点, 可以根据 断点来分析，走完👆面的方法，然后我们点击走到下一个断点来，就会走到 这个 有参构造函数.</p>
<p>如果好奇的话，可以跟踪debug 的堆栈信息，是怎么走到这步来的. 走到这个方法来 : finishBeanFactoryInitialization(beanFactory) 这是最初的入口.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public MybatisAutoConfiguration(MybatisProperties properties, ObjectProvider&lt;Interceptor[]&gt; interceptorsProvider,</span><br><span class="line">    ObjectProvider&lt;TypeHandler[]&gt; typeHandlersProvider, ObjectProvider&lt;LanguageDriver[]&gt; languageDriversProvider,</span><br><span class="line">    ResourceLoader resourceLoader, ObjectProvider&lt;DatabaseIdProvider&gt; databaseIdProvider,</span><br><span class="line">    ObjectProvider&lt;List&lt;ConfigurationCustomizer&gt;&gt; configurationCustomizersProvider) &#123;</span><br><span class="line">&#x2F;&#x2F; 这里都是赋值    </span><br><span class="line">  this.properties &#x3D; properties;</span><br><span class="line">  this.interceptors &#x3D; interceptorsProvider.getIfAvailable();</span><br><span class="line">  this.typeHandlers &#x3D; typeHandlersProvider.getIfAvailable();</span><br><span class="line">  this.languageDrivers &#x3D; languageDriversProvider.getIfAvailable();</span><br><span class="line">  this.resourceLoader &#x3D; resourceLoader;</span><br><span class="line">  this.databaseIdProvider &#x3D; databaseIdProvider.getIfAvailable();</span><br><span class="line">  this.configurationCustomizers &#x3D; configurationCustomizersProvider.getIfAvailable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration#afterPropertiesSet()方法</strong></p>
<p>这里可以看到是对配置文件是否存在进行检验.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void afterPropertiesSet() &#123;</span><br><span class="line">  checkConfigFileExists();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 检验配置文件是否存在</span><br><span class="line">  private void checkConfigFileExists() &#123;</span><br><span class="line">    if (this.properties.isCheckConfigLocation() &amp;&amp; StringUtils.hasText(this.properties.getConfigLocation())) &#123;</span><br><span class="line">      Resource resource &#x3D; this.resourceLoader.getResource(this.properties.getConfigLocation());</span><br><span class="line">      Assert.state(resource.exists(),</span><br><span class="line">          &quot;Cannot find config location: &quot; + resource + &quot; (please add config file or check your Mybatis configuration)&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration#sqlSessionFactory 方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 这里说下 @ConditionalOnMissingBean 的作用,当bean不存在的时候，则实例化这个bean.</span><br><span class="line">&#x2F;&#x2F; 这里会传入 dataSource 进来.</span><br><span class="line">@Bean</span><br><span class="line">@ConditionalOnMissingBean</span><br><span class="line">public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception &#123;</span><br><span class="line">&#x2F;&#x2F; 创建 sqlSessionBean 对象.    </span><br><span class="line">  SqlSessionFactoryBean factory &#x3D; new SqlSessionFactoryBean();</span><br><span class="line">&#x2F;&#x2F; 设置 dataSource &amp; SpringBootVFS.class      </span><br><span class="line">  factory.setDataSource(dataSource);</span><br><span class="line">  factory.setVfs(SpringBootVFS.class);</span><br><span class="line">&#x2F;&#x2F; 获取到 MyBatis 的配置文件属性,如果有的话,就会设置到 configLocation属性来.    </span><br><span class="line">  if (StringUtils.hasText(this.properties.getConfigLocation())) &#123;</span><br><span class="line">    factory.setConfigLocation(this.resourceLoader.getResource(this.properties.getConfigLocation()));</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F; 这里从 properties 中获取 configuration,没有值就会是null.    </span><br><span class="line">  applyConfiguration(factory);</span><br><span class="line">  if (this.properties.getConfigurationProperties() !&#x3D; null) &#123;</span><br><span class="line">    factory.setConfigurationProperties(this.properties.getConfigurationProperties());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果有插件,就会设置插件.    </span><br><span class="line">  if (!ObjectUtils.isEmpty(this.interceptors)) &#123;</span><br><span class="line">    factory.setPlugins(this.interceptors);</span><br><span class="line">  &#125;</span><br><span class="line">  if (this.databaseIdProvider !&#x3D; null) &#123;</span><br><span class="line">    factory.setDatabaseIdProvider(this.databaseIdProvider);</span><br><span class="line">  &#125;</span><br><span class="line">&#x2F;&#x2F; 包的名别设置    </span><br><span class="line">  if (StringUtils.hasLength(this.properties.getTypeAliasesPackage())) &#123;</span><br><span class="line">    factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage());</span><br><span class="line">  &#125;</span><br><span class="line">  if (this.properties.getTypeAliasesSuperType() !&#x3D; null) &#123;</span><br><span class="line">    factory.setTypeAliasesSuperType(this.properties.getTypeAliasesSuperType());</span><br><span class="line">  &#125;</span><br><span class="line">  if (StringUtils.hasLength(this.properties.getTypeHandlersPackage())) &#123;</span><br><span class="line">    factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage());</span><br><span class="line">  &#125;</span><br><span class="line">  if (!ObjectUtils.isEmpty(this.typeHandlers)) &#123;</span><br><span class="line">    factory.setTypeHandlers(this.typeHandlers);</span><br><span class="line">  &#125;</span><br><span class="line">  if (!ObjectUtils.isEmpty(this.properties.resolveMapperLocations())) &#123;</span><br><span class="line">    factory.setMapperLocations(this.properties.resolveMapperLocations());</span><br><span class="line">  &#125;</span><br><span class="line">&#x2F;&#x2F; 这里都是配置属性的设置.    </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取 propert 字段属性的名字.    </span><br><span class="line">  Set&lt;String&gt; factoryPropertyNames &#x3D; Stream</span><br><span class="line">      .of(new BeanWrapperImpl(SqlSessionFactoryBean.class).getPropertyDescriptors()).map(PropertyDescriptor::getName)</span><br><span class="line">      .collect(Collectors.toSet());</span><br><span class="line">  Class&lt;? extends LanguageDriver&gt; defaultLanguageDriver &#x3D; this.properties.getDefaultScriptingLanguageDriver();</span><br><span class="line">  if (factoryPropertyNames.contains(&quot;scriptingLanguageDrivers&quot;) &amp;&amp; !ObjectUtils.isEmpty(this.languageDrivers)) &#123;</span><br><span class="line">    &#x2F;&#x2F; Need to mybatis-spring 2.0.2+</span><br><span class="line">    factory.setScriptingLanguageDrivers(this.languageDrivers);</span><br><span class="line">    if (defaultLanguageDriver &#x3D;&#x3D; null &amp;&amp; this.languageDrivers.length &#x3D;&#x3D; 1) &#123;</span><br><span class="line">      defaultLanguageDriver &#x3D; this.languageDrivers[0].getClass();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#x2F;&#x2F; 设置默认的脚本语言解析器. 这里没有,设置的是默认的null.    </span><br><span class="line">  if (factoryPropertyNames.contains(&quot;defaultScriptingLanguageDriver&quot;)) &#123;</span><br><span class="line">    &#x2F;&#x2F; Need to mybatis-spring 2.0.2+</span><br><span class="line">    factory.setDefaultScriptingLanguageDriver(defaultLanguageDriver);</span><br><span class="line">  &#125;</span><br><span class="line">&#x2F;&#x2F; org.mybatis.spring.SqlSessionFactoryBean#getObject,这里走到了 SqlSessionBean.</span><br><span class="line">&#x2F;&#x2F; 这个SqlSessionFactoryBean是在有之前 mybatis和Spring 整合分析有提过到的,可以参考getObject方法: https:&#x2F;&#x2F;github.com&#x2F;baoyang23&#x2F;mybtatis-analysis&#x2F;tree&#x2F;master&#x2F;mybatis-spring-hello    </span><br><span class="line">&#x2F;&#x2F; 这里会走 org.mybatis.spring.SqlSessionFactoryBean#getObject 的 afterPropertiesSet 方法来创建一个 SqlSessionFactory , 这里返回的 SqlSessionFactory 就注入到 Spring 容器中来.    </span><br><span class="line">  return factory.getObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以这个方法 ： 先是new了一个SqlSessionFactoryBean对象，如果你仔细看的话，你会发现这个对象在之前 mybatis-spring 整合的时候，我们通过 xml 配置文件配置进来的，并且同时通过标签给赋值了datasource等信息，  而这里是通过代码，if等判断，来对 SqlSessionFactoryBean 的属性进行set值的. 最后也是创建出一个  SqlSessionFactory 给注入到 Spring 容器中来.</strong></p>
<hr>
<p><strong>org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration#sqlSessionTemplate 方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">@ConditionalOnMissingBean</span><br><span class="line">public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) &#123;</span><br><span class="line">&#x2F;&#x2F; 这里根据 executorType 是否有值来判断要走的构造函数方法.    </span><br><span class="line">  ExecutorType executorType &#x3D; this.properties.getExecutorType();</span><br><span class="line">  if (executorType !&#x3D; null) &#123;</span><br><span class="line">    return new SqlSessionTemplate(sqlSessionFactory, executorType);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">&#x2F;&#x2F; 这里默认的获取是 SIMPLE 这个 ExecutorType.      </span><br><span class="line">    return new SqlSessionTemplate(sqlSessionFactory);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; org.mybatis.spring.SqlSessionTemplate#SqlSessionTemplate(org.apache.ibatis.session.SqlSessionFactory, org.apache.ibatis.session.ExecutorType, org.springframework.dao.support.PersistenceExceptionTranslator),最后可以跟进到这个方法中来.</span><br><span class="line"></span><br><span class="line">  public SqlSessionTemplate(SqlSessionFactory sqlSessionFactory, ExecutorType executorType,</span><br><span class="line">      PersistenceExceptionTranslator exceptionTranslator) &#123;</span><br><span class="line">&#x2F;&#x2F; 对sqlSessionFactory 和 executorType 进行校验</span><br><span class="line">    notNull(sqlSessionFactory, &quot;Property &#39;sqlSessionFactory&#39; is required&quot;);</span><br><span class="line">    notNull(executorType, &quot;Property &#39;executorType&#39; is required&quot;);</span><br><span class="line"></span><br><span class="line">    this.sqlSessionFactory &#x3D; sqlSessionFactory;</span><br><span class="line">    this.executorType &#x3D; executorType;</span><br><span class="line">    this.exceptionTranslator &#x3D; exceptionTranslator;</span><br><span class="line">&#x2F;&#x2F; 这里通过 JDK 的代码来生成了一个 sqlSessionProxy 代理的对象.      </span><br><span class="line">    this.sqlSessionProxy &#x3D; (SqlSession) newProxyInstance(SqlSessionFactory.class.getClassLoader(),</span><br><span class="line">        new Class[] &#123; SqlSession.class &#125;, new SqlSessionInterceptor());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>该方法是将 SqlSessionTemplate 给注入到 Spring 容器中啦.</p>
<h4 id="-2"><a href="#-2" class="headerlink" title=""></a></h4><h4 id="疑惑点"><a href="#疑惑点" class="headerlink" title="疑惑点"></a>疑惑点</h4><p>​     大家有没有疑惑我们定义的 mapper 接口 好像从这个流程分析下来，并没有提到 ，那么是在上面时候被注入到 Spring 容器中来的呢？</p>
<p>​     registerBeanDefinitions()  这个方法 , 注入了MapperScannerConfigurer 到  Spring 容器中来了，可以回顾下之前 mybatis 整合 Spring 的时候，我们是通过 xml 配置了这个对象注入到 spring  容器中来的。 那么注入进来的,回调到  org.mybatis.spring.mapper.MapperScannerConfigurer#postProcessBeanDefinitionRegistry 这个方法的时候，就会将扫描并且将我们的mapper接口文件，给注入到 Spring 容器中来的.  然后扫描的包，是根据@MapperScan 解析注解的时候，是有对扫描的包进行解析的.</p>
<h4 id="-3"><a href="#-3" class="headerlink" title=""></a></h4><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​      其实 SpringBoot 整合 MyBatis , 我们从二个切入点来分析是怎么整合进来的.<br> ​      一是 @MapperScan 注解中的 @Import(MapperScannerRegistrar.class) 将  MapperScannerRegistrar 给导入到 Spring 容器中来, 然后MapperSacnnerRegistrar 来讲  org.mybatis.spring.mapper.MapperScannerConfigurer 给注入到 Spring中来，替换了我们之前用 Spring 整合 Mybatis 的时候，通过xml配置文件整合进来.</p>
<p>​     二是利用 SpringBoot 提供的 spring-boot-autoconfigure +  spring.factories() 来 配置自动注入, 这里注入了 MybatisAutoConfiguration 配置类. 然后注入进来的 MyBatis 配置类做了什么事情呢？  可以看到这个类中是有做:   注入了 SqlSessionFactory.  SqlSessionFactory 又是怎么注入进来的呢？ 可以看到  org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration#sqlSessionFactory 方法是有先创建一个 org.mybatis.spring.SqlSessionFactoryBean 的， 看到  SqlSessionFactoryBean 这个对象，我们就不难想起 Spring + Mybatis 里面的 beans.xml  是将该对象注入到 Spring 容器中来. 这里是直接new的，然后将一些配置属性并满足条件,给set到  SqlSessionFactoryBean  中来，最后调用   org.mybatis.spring.SqlSessionFactoryBean#getObject 方法来获取  SqlSessionFactory.</p>
<p>spring.factories 文件内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;\</span><br><span class="line">org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration,\</span><br><span class="line">org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration</span><br></pre></td></tr></table></figure>



<p>最后从写的案例里面看, MyBatis 整合 SpringBoot 其实都是在 mybatis —&gt; MyBatis + Spring  等一步一步推导上来的，所以这里不难理解，好的技术都是在有需要和时间的沉淀下一步一步成长起来的.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.lwfby.cn/2020/12/27/mybatis/mybatis-spring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YangL">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/timg.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YangL">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/12/27/mybatis/mybatis-spring/" itemprop="url">mybatis-spring</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-12-27T22:10:39+08:00">
                2020-12-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MyBatis/" itemprop="url" rel="index">
                    <span itemprop="name">MyBatis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3.7k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  16
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="题记"><a href="#题记" class="headerlink" title="题记"></a>题记</h4><p>​    MyBatis 与 Spring 整合操作.   在我们入门学习 SSM  等东西的时候，就发现了任何东西，最后都是逃不过与Spring整合起来的道路.   然后这里看完 MyBatis 整合完 Spring  之后，那么之后一些其他的第三方，比如axon/redis/apollo/shiro 等这些东西，如果要整合 Spring  的时候，是不是也是相似的整合方式呢？</p>
<p>​    这个需要我们看完 MyBatis 与 Spring 之后，探究其整合的操作.</p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h4><p>​     分几个步骤，操作一把即可,带你回到哪个  SM 时代，不过这回是没有了 tomcat 的.</p>
<p>​     先放上一个完成的整合地址 :    <a href="https://github.com/baoyang23/mybtatis-analysis/tree/master/mybatis-spring-hello" target="_blank" rel="noopener">https://github.com/baoyang23/mybtatis-analysis/tree/master/mybatis-spring-hello</a>    如果不要看下面流程的,一步跳过即可.</p>
<ol>
<li>先创建一个 maven 项目，引入依赖.  依赖参考地址 :    <a href="https://github.com/baoyang23/mybtatis-analysis/blob/master/mybatis-spring-hello/pom.xml" target="_blank" rel="noopener">https://github.com/baoyang23/mybtatis-analysis/blob/master/mybatis-spring-hello/pom.xml</a></li>
<li>db配置 : <a href="https://github.com/baoyang23/mybtatis-analysis/blob/master/mybatis-spring-hello/src/main/resources/db.properties" target="_blank" rel="noopener">https://github.com/baoyang23/mybtatis-analysis/blob/master/mybatis-spring-hello/src/main/resources/db.properties</a></li>
<li>MyBatis配置:  <a href="https://github.com/baoyang23/mybtatis-analysis/tree/master/mybatis-spring-hello/src/main/resources/mybatis" target="_blank" rel="noopener">https://github.com/baoyang23/mybtatis-analysis/tree/master/mybatis-spring-hello/src/main/resources/mybatis</a></li>
<li>Spring 配置:  <a href="https://github.com/baoyang23/mybtatis-analysis/blob/master/mybatis-spring-hello/src/main/resources/spring-beans.xml" target="_blank" rel="noopener">https://github.com/baoyang23/mybtatis-analysis/blob/master/mybatis-spring-hello/src/main/resources/spring-beans.xml</a></li>
<li>最后,来份我们熟悉的 <a href="https://github.com/baoyang23/mybtatis-analysis/tree/master/mybatis-spring-hello/src/main/resources/sql" target="_blank" rel="noopener">https://github.com/baoyang23/mybtatis-analysis/tree/master/mybatis-spring-hello/src/main/resources/sql</a>  mapper.xml 文件.</li>
<li>不忘记再来一份代码 :   <a href="https://github.com/baoyang23/mybtatis-analysis/tree/master/mybatis-spring-hello/src" target="_blank" rel="noopener">https://github.com/baoyang23/mybtatis-analysis/tree/master/mybatis-spring-hello/src</a>     这些直接跑测试类即可.</li>
</ol>
<p>跟着这上面的几个步骤，就可以搭建完一个项目. 然后喊上我们的 永哥， 打上传说中的 debug , 疯狂的调试看每步干了什么事.</p>
<p>这个的时候，可以跑下测试类，是ok的.</p>
<h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>​       这里我们首先想到的是我们引入的依赖,是不是有个 mybatis-spring 的依赖. 从这个依赖，可以很明显的看出来，就是通过这个依赖，将 MyBatis 和 Spring 整合起来的。</p>
<p>​       然后再想想，我们除了这个依赖的话，还再哪里有使用到一些 Spring 和 MyBatis 的东西呢？  然后看到  spring-beans.xml 这个xml配置, 可以看到 org.mybatis.spring.SqlSessionFactoryBean  给注入到 bean 里面来了.org.mybatis.spring.mapper.MapperScannerConfigurer也是给注入到  bean 里面来了. 并且二者都有通过来进行属性设置值操作.</p>
<p>​        那么,我们就基于这二个类的源码开始阅读.</p>
<p>​    <strong>SqlSessionFactoryBean (org.mybatis.spring.SqlSessionFactoryBean)</strong></p>
<p>这里 SqlSessionFactoryBean 是实现了很多接口,这些接口都是Spring的.</p>
<p>FactoryBean 工厂bean,点进去可以看到,其有方法getObject()/getObjectType等方法获取bean的,然后加上泛型,也就是这里获取的 getObject就是泛型.</p>
<p>InitializingBean:  afterPropertiesSet 初始化 bean 的时候，会调用该方法.</p>
<p>ApplicationEvent:   Spring的事件传播机制，就是使用的这种方式.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**  可以看到这个类实现了 Spring 这个多接口,那么就有个问题,实现了这么多接口的方法,到底是哪个方法先执行的呢？ 如果你对Spring源码很熟悉的话,是有可能清楚的,但是还是会有点绕的. </span><br><span class="line">这里我们给 getObject&#x2F;afterPropertiesSet&#x2F;onApplicationEvent这三个方法打上断点来进行debug,</span><br><span class="line">debug每走的一步,就是执行的先后顺序。如果不是特别熟悉源码的执行顺序,这种笨方法其实也是可以的.</span><br><span class="line">*</span><br><span class="line">* 所以这里debug的执行顺序是 : afterPropertiesSet --&gt; getObject  ---&gt; onApplicationEvent</span><br><span class="line">* 于是我们就跟着这个顺序来阅读.</span><br><span class="line">* 注意在调用这些方法之前,&lt;property&gt;标签的值都是已经赋值进来了的,是通过反射走的set 方法进来的.</span><br><span class="line">*&#x2F;</span><br><span class="line">public class SqlSessionFactoryBean</span><br><span class="line">    implements FactoryBean&lt;SqlSessionFactory&gt;, InitializingBean, ApplicationListener&lt;ApplicationEvent&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 实现FactoryBean 方法,这里是实现了该接口的三个方法. 其实这里的 isSingle是可以不用实现的</span><br><span class="line">&#x2F;&#x2F; 因为接口是用 default 来修饰的.</span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 该方法是判断并且再次确认 SqlSessionFactory是不是有了. 如果没有的话,就会调用afterProperties来初始化.</span><br><span class="line">   * &#123;@inheritDoc&#125;</span><br><span class="line">   *&#x2F;</span><br><span class="line">  @Override</span><br><span class="line">  public SqlSessionFactory getObject() throws Exception &#123;</span><br><span class="line">    if (this.sqlSessionFactory &#x3D;&#x3D; null) &#123;</span><br><span class="line">      afterPropertiesSet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return this.sqlSessionFactory;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public Class&lt;? extends SqlSessionFactory&gt; getObjectType() &#123;</span><br><span class="line">    return this.sqlSessionFactory &#x3D;&#x3D; null ? SqlSessionFactory.class : this.sqlSessionFactory.getClass();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public boolean isSingleton() &#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; InitializingBean 实现的方法</span><br><span class="line">  @Override</span><br><span class="line">  public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line">&#x2F;&#x2F; 先对 dataSource&#x2F;sqlSessionFactoryBuilder进行非null的判断.</span><br><span class="line">    notNull(dataSource, &quot;Property &#39;dataSource&#39; is required&quot;);</span><br><span class="line">    notNull(sqlSessionFactoryBuilder, &quot;Property &#39;sqlSessionFactoryBuilder&#39; is required&quot;);</span><br><span class="line">    state((configuration &#x3D;&#x3D; null &amp;&amp; configLocation &#x3D;&#x3D; null) || !(configuration !&#x3D; null &amp;&amp; configLocation !&#x3D; null),</span><br><span class="line">        &quot;Property &#39;configuration&#39; and &#39;configLocation&#39; can not specified with together&quot;);</span><br><span class="line">&#x2F;&#x2F; 这里构建出 一个 sqlSessionFactory工厂来,想想我们最初再看单个MyBatis项目的时候,是不是也有一个获取SqlSessionFactroy的方法,然后从sqlSessionFactory会话中获取出SqlSession来.</span><br><span class="line">    this.sqlSessionFactory &#x3D; buildSqlSessionFactory();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ApplicationListener实现方法</span><br><span class="line">  &#x2F;**</span><br><span class="line">   * failFast 时ture 并且传过来的 event是 ContextRefreshedEvent的话,就会进来.</span><br><span class="line">   *  这里目前都是调用get方法,没有很仔细看出其作用.</span><br><span class="line">   * &#123;@inheritDoc&#125;</span><br><span class="line">   *&#x2F;</span><br><span class="line">  @Override</span><br><span class="line">  public void onApplicationEvent(ApplicationEvent event) &#123;</span><br><span class="line">    if (failFast &amp;&amp; event instanceof ContextRefreshedEvent) &#123;</span><br><span class="line">      &#x2F;&#x2F; fail-fast -&gt; check all statements are completed</span><br><span class="line">      this.sqlSessionFactory.getConfiguration().getMappedStatementNames();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>org.mybatis.spring.SqlSessionFactoryBean#buildSqlSessionFactory</strong></p>
<p>该方法需要单独拿出来说下,因为内容还是比较多的.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Build a &#123;@code SqlSessionFactory&#125; instance.</span><br><span class="line"> *</span><br><span class="line"> * The default implementation uses the standard MyBatis &#123;@code XMLConfigBuilder&#125; API to build a</span><br><span class="line"> * &#123;@code SqlSessionFactory&#125; instance based on a Reader. Since 1.3.0, it can be specified a &#123;@link Configuration&#125;</span><br><span class="line"> * instance directly(without config file).</span><br><span class="line"> *</span><br><span class="line"> * @return SqlSessionFactory</span><br><span class="line"> * @throws Exception</span><br><span class="line"> *           if configuration is failed</span><br><span class="line"> *&#x2F;</span><br><span class="line">protected SqlSessionFactory buildSqlSessionFactory() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">  final Configuration targetConfiguration;</span><br><span class="line"></span><br><span class="line">  XMLConfigBuilder xmlConfigBuilder &#x3D; null;</span><br><span class="line">    </span><br><span class="line"> &#x2F;&#x2F; 这里分为configuration&#x2F; configLocation &#x2F; 非前二者(可以理解为默认的).</span><br><span class="line"> &#x2F;&#x2F; 三种处理方式.   </span><br><span class="line">  if (this.configuration !&#x3D; null) &#123;</span><br><span class="line">    targetConfiguration &#x3D; this.configuration;</span><br><span class="line">    if (targetConfiguration.getVariables() &#x3D;&#x3D; null) &#123;</span><br><span class="line">      targetConfiguration.setVariables(this.configurationProperties);</span><br><span class="line">    &#125; else if (this.configurationProperties !&#x3D; null) &#123;</span><br><span class="line">      targetConfiguration.getVariables().putAll(this.configurationProperties);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else if (this.configLocation !&#x3D; null) &#123;</span><br><span class="line">&#x2F;&#x2F; 这里就是我们配置的情况 </span><br><span class="line">&#x2F;&#x2F; org.apache.ibatis.builder.xml.XMLConfigBuilder#XMLConfigBuilder(java.io.InputStream, java.lang.String, java.util.Properties),可以看到这个熟悉的操作,也就是我们单个解析 MyBatis的时候有进行分析过的.      </span><br><span class="line">    xmlConfigBuilder &#x3D; new XMLConfigBuilder(this.configLocation.getInputStream(), null, this.configurationProperties);</span><br><span class="line">&#x2F;&#x2F; 获取出 configuration 配置信息.      </span><br><span class="line">    targetConfiguration &#x3D; xmlConfigBuilder.getConfiguration();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    LOGGER.debug(</span><br><span class="line">        () -&gt; &quot;Property &#39;configuration&#39; or &#39;configLocation&#39; not specified, using default MyBatis Configuration&quot;);</span><br><span class="line">    targetConfiguration &#x3D; new Configuration();</span><br><span class="line">    Optional.ofNullable(this.configurationProperties).ifPresent(targetConfiguration::setVariables);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这里采用 Optional,如果objectFactory不是null的话,就会调用targetConfiguration的 setObjectFactory方法.下面这二个是同理.</span><br><span class="line">  Optional.ofNullable(this.objectFactory).ifPresent(targetConfiguration::setObjectFactory);</span><br><span class="line">  Optional.ofNullable(this.objectWrapperFactory).ifPresent(targetConfiguration::setObjectWrapperFactory);</span><br><span class="line">  Optional.ofNullable(this.vfs).ifPresent(targetConfiguration::setVfsImpl);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这里如果有配置typeAliasesPackage这个参数的话,就会对该包下进行扫描,进行一系列的过滤,</span><br><span class="line">&#x2F;&#x2F; 如果都满足条件的话,targetConfiguration.getTypeAliasRegistry()::registerAlias就会注册到这里. </span><br><span class="line">  if (hasLength(this.typeAliasesPackage)) &#123;</span><br><span class="line">    scanClasses(this.typeAliasesPackage, this.typeAliasesSuperType).stream()</span><br><span class="line">        .filter(clazz -&gt; !clazz.isAnonymousClass()).filter(clazz -&gt; !clazz.isInterface())</span><br><span class="line">        .filter(clazz -&gt; !clazz.isMemberClass()).forEach(targetConfiguration.getTypeAliasRegistry()::registerAlias);</span><br><span class="line">  &#125;</span><br><span class="line">&#x2F;&#x2F; 是否有typeAliases这个参数,如果有的话,也是可以看到是注册到上面哪一步的里面来.</span><br><span class="line">  if (!isEmpty(this.typeAliases)) &#123;</span><br><span class="line">    Stream.of(this.typeAliases).forEach(typeAlias -&gt; &#123;</span><br><span class="line">      targetConfiguration.getTypeAliasRegistry().registerAlias(typeAlias);</span><br><span class="line">      LOGGER.debug(() -&gt; &quot;Registered type alias: &#39;&quot; + typeAlias + &quot;&#39;&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;判断是否有插件,如果有插件的话,也会添加到configuration中来.    </span><br><span class="line">  if (!isEmpty(this.plugins)) &#123;</span><br><span class="line">    Stream.of(this.plugins).forEach(plugin -&gt; &#123;</span><br><span class="line">      targetConfiguration.addInterceptor(plugin);</span><br><span class="line">      LOGGER.debug(() -&gt; &quot;Registered plugin: &#39;&quot; + plugin + &quot;&#39;&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (hasLength(this.typeHandlersPackage)) &#123;</span><br><span class="line">    scanClasses(this.typeHandlersPackage, TypeHandler.class).stream().filter(clazz -&gt; !clazz.isAnonymousClass())</span><br><span class="line">        .filter(clazz -&gt; !clazz.isInterface()).filter(clazz -&gt; !Modifier.isAbstract(clazz.getModifiers()))</span><br><span class="line">        .forEach(targetConfiguration.getTypeHandlerRegistry()::register);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (!isEmpty(this.typeHandlers)) &#123;</span><br><span class="line">    Stream.of(this.typeHandlers).forEach(typeHandler -&gt; &#123;</span><br><span class="line">      targetConfiguration.getTypeHandlerRegistry().register(typeHandler);</span><br><span class="line">      LOGGER.debug(() -&gt; &quot;Registered type handler: &#39;&quot; + typeHandler + &quot;&#39;&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  targetConfiguration.setDefaultEnumTypeHandler(defaultEnumTypeHandler);</span><br><span class="line"></span><br><span class="line">  if (!isEmpty(this.scriptingLanguageDrivers)) &#123;</span><br><span class="line">    Stream.of(this.scriptingLanguageDrivers).forEach(languageDriver -&gt; &#123;</span><br><span class="line">      targetConfiguration.getLanguageRegistry().register(languageDriver);</span><br><span class="line">      LOGGER.debug(() -&gt; &quot;Registered scripting language driver: &#39;&quot; + languageDriver + &quot;&#39;&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  Optional.ofNullable(this.defaultScriptingLanguageDriver)</span><br><span class="line">      .ifPresent(targetConfiguration::setDefaultScriptingLanguage);</span><br><span class="line"></span><br><span class="line">  if (this.databaseIdProvider !&#x3D; null) &#123;&#x2F;&#x2F; fix #64 set databaseId before parse mapper xmls</span><br><span class="line">    try &#123;</span><br><span class="line">      targetConfiguration.setDatabaseId(this.databaseIdProvider.getDatabaseId(this.dataSource));</span><br><span class="line">    &#125; catch (SQLException e) &#123;</span><br><span class="line">      throw new NestedIOException(&quot;Failed getting a databaseId&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Optional.ofNullable(this.cache).ifPresent(targetConfiguration::addCache);</span><br><span class="line">&#x2F;&#x2F; 这这之前,都是对一些配置信息的读取,如果有的话,就会进行相应的赋值之类的操作.</span><br><span class="line">    </span><br><span class="line">  if (xmlConfigBuilder !&#x3D; null) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">&#x2F;&#x2F; 最后这里的 parse 解析方法,是和单个 Mybatis的解读是一样的.        </span><br><span class="line">      xmlConfigBuilder.parse();</span><br><span class="line">      LOGGER.debug(() -&gt; &quot;Parsed configuration file: &#39;&quot; + this.configLocation + &quot;&#39;&quot;);</span><br><span class="line">    &#125; catch (Exception ex) &#123;</span><br><span class="line">      throw new NestedIOException(&quot;Failed to parse config resource: &quot; + this.configLocation, ex);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;这里可以看事务工厂,是使用了mybatis-spring包下的.</span><br><span class="line">  targetConfiguration.setEnvironment(new Environment(this.environment,</span><br><span class="line">      this.transactionFactory &#x3D;&#x3D; null ? new SpringManagedTransactionFactory() : this.transactionFactory,</span><br><span class="line">      this.dataSource));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这里是处理 mapper.xml 文件的配置,如果在这里是有配置的话,那么也是会被解析到的.    </span><br><span class="line">  if (this.mapperLocations !&#x3D; null) &#123;</span><br><span class="line">    if (this.mapperLocations.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">      LOGGER.warn(() -&gt; &quot;Property &#39;mapperLocations&#39; was specified but matching resources are not found.&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      for (Resource mapperLocation : this.mapperLocations) &#123;</span><br><span class="line">        if (mapperLocation &#x3D;&#x3D; null) &#123;</span><br><span class="line">          continue;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">          XMLMapperBuilder xmlMapperBuilder &#x3D; new XMLMapperBuilder(mapperLocation.getInputStream(),</span><br><span class="line">              targetConfiguration, mapperLocation.toString(), targetConfiguration.getSqlFragments());</span><br><span class="line">          xmlMapperBuilder.parse();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">          throw new NestedIOException(&quot;Failed to parse mapping resource: &#39;&quot; + mapperLocation + &quot;&#39;&quot;, e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">          ErrorContext.instance().reset();</span><br><span class="line">        &#125;</span><br><span class="line">        LOGGER.debug(() -&gt; &quot;Parsed mapper file: &#39;&quot; + mapperLocation + &quot;&#39;&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    LOGGER.debug(() -&gt; &quot;Property &#39;mapperLocations&#39; was not specified.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#x2F;&#x2F;org.apache.ibatis.session.defaults.DefaultSqlSessionFactory,最后到这里也是new了一个mybatis包下的默认SqlSessionFactory类.</span><br><span class="line">  return this.sqlSessionFactoryBuilder.build(targetConfiguration);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到该方法给人感觉, 先是判断一些配置信息是不是有值，如果是有值的话，就会进行相应的处理。最后调用我们在看单个 mybatis 的 parse 解析方法,最后new了一个默认的sqlSessionFactory工厂类出来.</p>
<p><strong>MapperScannerConfigurer(org.mybatis.spring.mapper.MapperScannerConfigurer)</strong></p>
<p>接着看,spring-beans.xml 里面的第二个配置.</p>
<p>可以看到该类，也是实现了 spring 的很多接口.</p>
<p>BeanDefinitionRegistryPostProcessor :  注册BeanDefinition到Spring容器中来.</p>
<p>ApplicationContextAware :  获取 ApplicationContext</p>
<p>BeanNameAware :   设置 beanName名字.</p>
<p>这里也可以按照上面的笨方法，一次对重写的方法打上断点. 然后开启我们的debug来看看方法的执行顺序.</p>
<p>其执行顺序 :   setBeanName   —&gt;  setApplicationContext —&gt;  afterPropertiesSet  —&gt;  postProcessBeanDefinitionRegistry ,  跟着这四个方法执行的顺序来看.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class MapperScannerConfigurer</span><br><span class="line">    implements BeanDefinitionRegistryPostProcessor, InitializingBean, ApplicationContextAware, BeanNameAware &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>赋值给 beanName 值.   org.mybatis.spring.mapper.MapperScannerConfigurer#0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void setBeanName(String name) &#123;</span><br><span class="line">  this.beanName &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 然后这里是给到 ApplicationContext. 这也就说这个类现在有了 ApplicationContext,可以根据context提供的api来进行相应的操作.</span><br><span class="line">  @Override</span><br><span class="line">  public void setApplicationContext(ApplicationContext applicationContext) &#123;</span><br><span class="line">    this.applicationContext &#x3D; applicationContext;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 检验配置包的值不能为null.</span><br><span class="line">  @Override</span><br><span class="line">  public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line">    notNull(this.basePackage, &quot;Property &#39;basePackage&#39; is required&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * &#123;@inheritDoc&#125;</span><br><span class="line">   * 可以感受到这个方法, 在拿到了BeanDefinitionRegistry的情况下,往里面注册bd.</span><br><span class="line">   * @since 1.0.2</span><br><span class="line">   *&#x2F;</span><br><span class="line">  @Override</span><br><span class="line">  public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) &#123;</span><br><span class="line">    if (this.processPropertyPlaceHolders) &#123;</span><br><span class="line">      processPropertyPlaceHolders();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这段是创建了一个 ClassPathMapperScanner 对象,然后往里面set属性.      </span><br><span class="line">    ClassPathMapperScanner scanner &#x3D; new ClassPathMapperScanner(registry);</span><br><span class="line">    scanner.setAddToConfig(this.addToConfig);</span><br><span class="line">    scanner.setAnnotationClass(this.annotationClass);</span><br><span class="line">    scanner.setMarkerInterface(this.markerInterface);</span><br><span class="line">    scanner.setSqlSessionFactory(this.sqlSessionFactory);</span><br><span class="line">    scanner.setSqlSessionTemplate(this.sqlSessionTemplate);</span><br><span class="line">    scanner.setSqlSessionFactoryBeanName(this.sqlSessionFactoryBeanName);</span><br><span class="line">    scanner.setSqlSessionTemplateBeanName(this.sqlSessionTemplateBeanName);</span><br><span class="line">    scanner.setResourceLoader(this.applicationContext);</span><br><span class="line">    scanner.setBeanNameGenerator(this.nameGenerator);</span><br><span class="line">    scanner.setMapperFactoryBeanClass(this.mapperFactoryBeanClass);</span><br><span class="line">      </span><br><span class="line">    if (StringUtils.hasText(lazyInitialization)) &#123;</span><br><span class="line">      scanner.setLazyInitialization(Boolean.valueOf(lazyInitialization));</span><br><span class="line">    &#125;</span><br><span class="line">    if (StringUtils.hasText(defaultScope)) &#123;</span><br><span class="line">      scanner.setDefaultScope(defaultScope);</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#x2F;&#x2F; 对register里的信息进行过滤      </span><br><span class="line">    scanner.registerFilters();</span><br><span class="line">&#x2F;&#x2F; org.springframework.context.annotation.ClassPathBeanDefinitionScanner#scan</span><br><span class="line">&#x2F;&#x2F; 这里主要看扫描的方法. 根据,来切割我们写的 basePackage 信息.扫描类的信息,最后还是借用了 org.springframework.context.annotation.ClassPathBeanDefinitionScanner#doScan 来进行扫描的. &#x2F;&#x2F;  doScan(basePackages) 是对 xml 进行扫描的.</span><br><span class="line">&#x2F;&#x2F; AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry); 是对注解进行扫描的.</span><br><span class="line">&#x2F;&#x2F; 最后返回注册到 Spring 容器中的 bean 个数</span><br><span class="line">&#x2F;&#x2F; 所以如果我们配置了下面的标签,那么在这里都会被扫描到并且注册到Spring容器中.</span><br><span class="line">&#x2F;&#x2F;     &lt;bean class&#x3D;&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;</span><br><span class="line">&#x2F;&#x2F;        &lt;property name&#x3D;&quot;basePackage&quot; value&#x3D;&quot;com.iyang.sm.mapper&quot; &gt;&lt;&#x2F;property&gt;</span><br><span class="line">&#x2F;&#x2F;    &lt;&#x2F;bean&gt;</span><br><span class="line">&#x2F;&#x2F; 这里需要注意的是:  org.mybatis.spring.mapper.ClassPathMapperScanner#processBeanDefinitions</span><br><span class="line">&#x2F;&#x2F;   definition.setBeanClass(this.mapperFactoryBeanClass);  这里的这行代码,是给bd的beanClass给换成了 MapperFactoryBean.class , </span><br><span class="line">&#x2F;&#x2F;  definition.getConstructorArgumentValues().addGenericArgumentValue(beanClassName);     &#x2F;&#x2F; 这句代码,将 beanClassName 给到 db之后, 然后就才用 beanClassName来new一个 MapperFactoryBean 对象来, 所以这里并不是使用无参构造函数.</span><br><span class="line">&#x2F;&#x2F; 也许会问,怎么证实没有走无参数构造函数呢 ? 而是去走的 set 方法呢 ? </span><br><span class="line">&#x2F;&#x2F; 再不能动源码的情况下, 面对这种情况情况最好的办法就是, 在无参构造函数上打上断点.</span><br><span class="line">&#x2F;&#x2F; 如果没走到断点上,那就说明不是走的无参构造函数来初始化的.      </span><br><span class="line">    scanner.scan(</span><br><span class="line">        StringUtils.tokenizeToStringArray(this.basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>所以到这里, 可以看到 MyBatis 与 Spring 整合的过程就已经完成了.</p>
<p>我们这里是主要对 SqlSessionFactoryBean 和 MapperScannerConfigurer 来进行分析的,  可以很明显的感觉到,我们是配置好这二个bean后,就可以使用了.  着重看第二个,   org.mybatis.spring.mapper.MapperScannerConfigurer 这个bean,就是做了如何将 MyBatis 的 mapper接口文件给加载到 Spring 中来的.   <strong>那么这里我在想, 如果有天我自己开发出一个好用的框架来,要与 Spring 进行整合的话,是不是也这样整合就可以了？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置sqlSessionFactory，SqlSessionFactoryBean是用来产生sqlSessionFactory的 --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;sqlSessionFactory&quot; class&#x3D;&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;</span><br><span class="line">    &lt;!-- 加载mybatis的全局配置文件，放在classpath下的mybatis文件夹中了 --&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;configLocation&quot; value&#x3D;&quot;mybatis&#x2F;SqlMapConfig.xml&quot; &#x2F;&gt;</span><br><span class="line">    &lt;!-- 加载数据源，使用上面配置好的数据源 --&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--  配置扫描 MyBatis 接口的包 --&gt;</span><br><span class="line">&lt;bean class&#x3D;&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;basePackage&quot; value&#x3D;&quot;com.iyang.sm.mapper&quot; &gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<h4 id="-2"><a href="#-2" class="headerlink" title=""></a></h4><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​    可以看到  MyBatis 与 Spring 整合后,  对于解析 MyBatis 的 mapper  配置文件等，都是走的之前单个 mybatis 的逻辑, 是没有什么变化的.   主要的是将 , SqlSessionFactory 和  Mapper.class(接口类) 给注入到 Spring 容器中.然后接口的话, 是怎么使用的代理类来进行实例化完后, 将对象给注入到  Spring 容器中的呢 ？ 这里看  org.mybatis.spring.mapper.MapperScannerConfigurer  做的事情就明白了.</p>
<p>​    不过在看 mybatis 与 Spring 整合的时候, 还是建议要有对  BeanDefinitionRegistryPostProcessor  /  InitializingBean /   ApplicationContextAware  /  BeanNameAware 有一定的了接.  就是有了了解后, 你就会很明显的感受到，  mybatis 为什么是实现这个接口，实现这个接口并且重写这个方法，在后面是什么时候被调用的. 意思也就是，你至少得明白点 Spring  对外提供的一些扩展点，才能很好的理解这些东西.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.lwfby.cn/2020/12/27/mybatis/mybatis-local-cache/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YangL">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/timg.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YangL">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/12/27/mybatis/mybatis-local-cache/" itemprop="url">mybatis-local-cache</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-12-27T22:10:14+08:00">
                2020-12-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MyBatis/" itemprop="url" rel="index">
                    <span itemprop="name">MyBatis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3.1k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  14
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="题记"><a href="#题记" class="headerlink" title="题记"></a>题记</h4><p>​    缓存这个知识点在许多地方都有的，利用到好的话，对系统的很多地方查询是有很大的提升的.  可以看到,MyBatis 也是有  cache 的，那MyBatis 是怎么利用这个缓存的呢？ 在  INSERT/UPDATE/DELETE/SELECT中,是不是只有SELECT的时候用到了缓存，如果是  INSERT/UPDATE/DELETE 是否会对缓存有影响？</p>
<p>​    可以看结果来分析，然后跟进源码来仔细分析.</p>
<p>​    MyBatis 是分为 一级缓存 和 二级缓存的. 那么，我们就先从一级缓存开始.</p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h4><p>​     案例代码 :</p>
<p>​     这里我们是打印的查询sql的语句，再第二次再查询的时候，是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">InputStream mybatisInputStream &#x3D; Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line"></span><br><span class="line">SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(mybatisInputStream);</span><br><span class="line">SqlSession session &#x3D; sqlSessionFactory.openSession();</span><br><span class="line">BlogMapper blogMapper &#x3D; session.getMapper(BlogMapper.class);</span><br><span class="line">TbBlog tbBlog &#x3D; blogMapper.selectBlog(1);</span><br><span class="line">System.out.println(blogMapper.selectBlog(1));</span><br><span class="line">System.out.println(tbBlog);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 结果可以看到,第二次并没有再打印出 sql 语句来.</span><br><span class="line">&#x3D;&#x3D;&gt;  Preparing: select * from tb_blog where id &#x3D; ? </span><br><span class="line">&#x3D;&#x3D;&gt; Parameters: 1(Integer)</span><br><span class="line">&lt;&#x3D;&#x3D;    Columns: id, name</span><br><span class="line">&lt;&#x3D;&#x3D;        Row: 1, 6565</span><br><span class="line">&lt;&#x3D;&#x3D;      Total: 1</span><br><span class="line">TbBlog&#123;id&#x3D;1, name&#x3D;&#39;6565&#39;&#125;</span><br><span class="line">TbBlog&#123;id&#x3D;1, name&#x3D;&#39;6565&#39;&#125;</span><br></pre></td></tr></table></figure>



<p>案例二 :  我们再第二次查询之前 加入 一个add 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">InputStream mybatisInputStream &#x3D; Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line"></span><br><span class="line">SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(mybatisInputStream);</span><br><span class="line">SqlSession session &#x3D; sqlSessionFactory.openSession();</span><br><span class="line">BlogMapper blogMapper &#x3D; session.getMapper(BlogMapper.class);</span><br><span class="line">TbBlog tbBlog &#x3D; blogMapper.selectBlog(1);</span><br><span class="line"></span><br><span class="line">System.out.println(blogMapper.addBlog(&quot;GavinYang&quot;));</span><br><span class="line">System.out.println(blogMapper.selectBlog(1));</span><br><span class="line">System.out.println(tbBlog);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 看结果,可以看到当中间穿插一个 insert 的sql语句,那么在第二次查询的时候,就会执行sql语句.</span><br><span class="line">&#x2F;&#x2F; 那么也就说，这个时候缓存是失效了.</span><br><span class="line">&#x3D;&#x3D;&gt;  Preparing: select * from tb_blog where id &#x3D; ? </span><br><span class="line">&#x3D;&#x3D;&gt; Parameters: 1(Integer)</span><br><span class="line">&lt;&#x3D;&#x3D;    Columns: id, name</span><br><span class="line">&lt;&#x3D;&#x3D;        Row: 1, 6565</span><br><span class="line">&lt;&#x3D;&#x3D;      Total: 1</span><br><span class="line">&#x3D;&#x3D;&gt;  Preparing: insert into tb_blog (name) values(?) </span><br><span class="line">&#x3D;&#x3D;&gt; Parameters: GavinYang(String)</span><br><span class="line">&lt;&#x3D;&#x3D;    Updates: 1</span><br><span class="line">1</span><br><span class="line">&#x3D;&#x3D;&gt;  Preparing: select * from tb_blog where id &#x3D; ? </span><br><span class="line">&#x3D;&#x3D;&gt; Parameters: 1(Integer)</span><br><span class="line">&lt;&#x3D;&#x3D;    Columns: id, name</span><br><span class="line">&lt;&#x3D;&#x3D;        Row: 1, 6565</span><br><span class="line">&lt;&#x3D;&#x3D;      Total: 1</span><br><span class="line">TbBlog&#123;id&#x3D;1, name&#x3D;&#39;6565&#39;&#125;</span><br><span class="line">TbBlog&#123;id&#x3D;1, name&#x3D;&#39;6565&#39;&#125;</span><br></pre></td></tr></table></figure>



<p>案例三 :  使用二个 SqlSession  案例</p>
<p>可以很明显的看到 , 在第二次的时候还出现了脏数据.</p>
<p>这里也可以看到一级缓存是只在 SqlSession 中存在的,也就是数据库会话内部共享的.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">InputStream mybatisInputStream &#x3D; Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line">SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(mybatisInputStream);</span><br><span class="line"></span><br><span class="line">SqlSession openSession1 &#x3D; sqlSessionFactory.openSession();</span><br><span class="line">SqlSession openSession2 &#x3D; sqlSessionFactory.openSession();</span><br><span class="line">BlogMapper blogMapper1 &#x3D; openSession1.getMapper(BlogMapper.class);</span><br><span class="line">BlogMapper blogMapper2 &#x3D; openSession2.getMapper(BlogMapper.class);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;blogMapper1 读取数据 &quot; + blogMapper1.selectBlog(1));</span><br><span class="line">System.out.println(&quot;blogMapper2 读取数据&quot; + blogMapper2.selectBlog(1));</span><br><span class="line"></span><br><span class="line">System.out.println(blogMapper1.updateHashCode(&quot;PeterWong&quot;));</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;blogMapper1 读取数据 &quot; + blogMapper1.selectBlog(1));</span><br><span class="line">System.out.println(&quot;blogMapper2 读取数据&quot; + blogMapper2.selectBlog(1));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 然后我们可以看到 log 打印出来的内容</span><br><span class="line">&#x3D;&#x3D;&gt;  Preparing: select * from tb_blog where id &#x3D; ? </span><br><span class="line">&#x3D;&#x3D;&gt; Parameters: 1(Integer)</span><br><span class="line">&lt;&#x3D;&#x3D;    Columns: id, name</span><br><span class="line">&lt;&#x3D;&#x3D;        Row: 1, 6565</span><br><span class="line">&lt;&#x3D;&#x3D;      Total: 1</span><br><span class="line">blogMapper1 读取数据 TbBlog&#123;id&#x3D;1, name&#x3D;&#39;6565&#39;&#125;</span><br><span class="line">Created connection 433287555.</span><br><span class="line">Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@19d37183]</span><br><span class="line">&#x3D;&#x3D;&gt;  Preparing: select * from tb_blog where id &#x3D; ? </span><br><span class="line">&#x3D;&#x3D;&gt; Parameters: 1(Integer)</span><br><span class="line">&lt;&#x3D;&#x3D;    Columns: id, name</span><br><span class="line">&lt;&#x3D;&#x3D;        Row: 1, 6565</span><br><span class="line">&lt;&#x3D;&#x3D;      Total: 1</span><br><span class="line">blogMapper2 读取数据TbBlog&#123;id&#x3D;1, name&#x3D;&#39;6565&#39;&#125;</span><br><span class="line">&#x3D;&#x3D;&gt;  Preparing: update tb_blog set name &#x3D; ? where id &#x3D; 1; </span><br><span class="line">&#x3D;&#x3D;&gt; Parameters: PeterWong(String)</span><br><span class="line">&lt;&#x3D;&#x3D;    Updates: 1</span><br><span class="line">1</span><br><span class="line">&#x3D;&#x3D;&gt;  Preparing: select * from tb_blog where id &#x3D; ? </span><br><span class="line">&#x3D;&#x3D;&gt; Parameters: 1(Integer)</span><br><span class="line">&lt;&#x3D;&#x3D;    Columns: id, name</span><br><span class="line">&lt;&#x3D;&#x3D;        Row: 1, PeterWong</span><br><span class="line">&lt;&#x3D;&#x3D;      Total: 1</span><br><span class="line">blogMapper1 读取数据 TbBlog&#123;id&#x3D;1, name&#x3D;&#39;PeterWong&#39;&#125;</span><br><span class="line">blogMapper2 读取数据TbBlog&#123;id&#x3D;1, name&#x3D;&#39;6565&#39;&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到我们说了三面的这三种情况, 具体的执行流程可以我们可以现在 案例一里面对第二次 query 进行 debug 分析操作.    当我们debug到  org.apache.ibatis.executor.BaseExecutor#query(org.apache.ibatis.mapping.MappedStatement, java.lang.Object, org.apache.ibatis.session.RowBounds,  org.apache.ibatis.session.ResultHandler,  org.apache.ibatis.cache.CacheKey, org.apache.ibatis.mapping.BoundSql)  的时候，可以看到  org.apache.ibatis.executor.BaseExecutor#localCache 只有一个 缓存的值的 ， 根据 getObject 方法可以跟进到 org.apache.ibatis.cache.impl.PerpetualCache#cache  中来,</p>
<p>传入进来的 key 值是 :   -1896651191:1062027004:com.iyang.mybatis.mapper.BlogMapper.selectBlog:0:2147483647:select * from tb_blog where id = ?:1:development  然后从 cache 中获取出值来, 所以这里就没有走  query 的查询语句.</p>
<p>这是命中缓存的情况.</p>
<p>下面我们来看下, 在第二次 query 之前如果执行了一个 add 方法，为什么就命中不了了呢？</p>
<p>这里可以大致猜测下，在执行完 add 方法后，是不是给 cache 给清除掉了，然后再去查询的时候，就查询不到了.</p>
<p>于是我们在 add 方法上进行 debug 查看下 :</p>
<p>最后我们 debug 跟进到这里 :  org.apache.ibatis.executor.BaseExecutor#clearLocalCache 就可以发现</p>
<p>这里是有二个 clear 方法，也就是清除方法.</p>
<p>localCache.clear()   —-&gt;     org.apache.ibatis.cache.impl.PerpetualCache#clear   对应的就是这里的清楚方法，直接调用 HashMap 的clear 方法进行清除.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">localCache.clear();</span><br><span class="line">localOutputParameterCache.clear();</span><br></pre></td></tr></table></figure>

<p>所以这里可以看出在第二次调用 query 之前，如果是有 insert/update/delete 等方法的话，就会去重置这二个地方的缓存的.</p>
<p>MyBatis 的一级缓存的是跟随  SqlSession 的，这里是可以根据简单的案例效果看出来的.</p>
<p>一级缓存只是使用了一个 HashMap , 最后清除缓存的时候，也是调用 HashMap 的clear 方法</p>
<p>最后从案例三可以看出来，当多个  SqlSession 的时候，由于各自有存有各自的缓存，所以是很容易引起脏数据的, 将缓存级别设置为 Statement.</p>
<h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4><h4 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h4><p>​     可以看到一级缓存的话，是局限于 SqlSession . 如果要多个 sqlSession 之间共享缓存的话，就需要开启二级缓存.   开启的话,我们在 MyBatis 配置文件中加上:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;settings&gt;</span><br><span class="line">    &lt;setting name&#x3D;&quot;logImpl&quot; value&#x3D;&quot;STDOUT_LOGGING&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 开启二级缓存 --&gt;</span><br><span class="line">    &lt;setting name&#x3D;&quot;cacheEnabled&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;settings&gt;</span><br></pre></td></tr></table></figure>

<p>​    <strong>案例一 :  是否提交事务</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    InputStream mybatisInputStream &#x3D; Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line">    SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(mybatisInputStream);</span><br><span class="line">    SqlSession sqlSession1 &#x3D; sqlSessionFactory.openSession(true);</span><br><span class="line">    SqlSession sqlSession2 &#x3D; sqlSessionFactory.openSession(true);</span><br><span class="line"></span><br><span class="line">    BlogMapper blogMapper1 &#x3D; sqlSession1.getMapper(BlogMapper.class);</span><br><span class="line">    BlogMapper blogMapper2 &#x3D; sqlSession2.getMapper(BlogMapper.class);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;blogMapper1 获取数据&quot; + blogMapper1.selectBlog(1));</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; sqlSession1.commit();</span><br><span class="line">    </span><br><span class="line">    System.out.println(&quot;blogMapper2 获取数据&quot; + blogMapper2.selectBlog(1));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;   ----------------   true结果   -----------------------</span><br><span class="line"></span><br><span class="line">Created connection 492079624.</span><br><span class="line">&#x3D;&#x3D;&gt;  Preparing: select * from tb_blog where id &#x3D; ? </span><br><span class="line">&#x3D;&#x3D;&gt; Parameters: 1(Integer)</span><br><span class="line">&lt;&#x3D;&#x3D;    Columns: id, name</span><br><span class="line">&lt;&#x3D;&#x3D;        Row: 1, 6565</span><br><span class="line">&lt;&#x3D;&#x3D;      Total: 1</span><br><span class="line">blogMapper1 获取数据TbBlog&#123;id&#x3D;1, name&#x3D;&#39;6565&#39;&#125;</span><br><span class="line">Opening JDBC Connection</span><br><span class="line">    </span><br><span class="line">Created connection 433287555.</span><br><span class="line">&#x3D;&#x3D;&gt;  Preparing: select * from tb_blog where id &#x3D; ? </span><br><span class="line">&#x3D;&#x3D;&gt; Parameters: 1(Integer)</span><br><span class="line">&lt;&#x3D;&#x3D;    Columns: id, name</span><br><span class="line">&lt;&#x3D;&#x3D;        Row: 1, 6565</span><br><span class="line">&lt;&#x3D;&#x3D;      Total: 1</span><br><span class="line">blogMapper2 获取数据TbBlog&#123;id&#x3D;1, name&#x3D;&#39;6565&#39;&#125;    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ------------   加上commit()方法结果   ---------------</span><br><span class="line"></span><br><span class="line">Created connection 630074945.</span><br><span class="line">&#x3D;&#x3D;&gt;  Preparing: select * from tb_blog where id &#x3D; ? </span><br><span class="line">&#x3D;&#x3D;&gt; Parameters: 1(Integer)</span><br><span class="line">&lt;&#x3D;&#x3D;    Columns: id, name</span><br><span class="line">&lt;&#x3D;&#x3D;        Row: 1, 6565</span><br><span class="line">&lt;&#x3D;&#x3D;      Total: 1</span><br><span class="line">blogMapper1 获取数据TbBlog&#123;id&#x3D;1, name&#x3D;&#39;6565&#39;&#125;</span><br><span class="line">Cache Hit Ratio [com.iyang.mybatis.mapper.BlogMapper]: 0.5</span><br><span class="line">blogMapper2 获取数据TbBlog&#123;id&#x3D;1, name&#x3D;&#39;6565&#39;&#125;</span><br></pre></td></tr></table></figure>

<p>​    从这里看, 是否提交事务可以看出来，是会影响二级缓存的.</p>
<p><strong>案例二 :  中间穿插更新语句</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)  throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    InputStream mybatisInputStream &#x3D; Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line">    SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(mybatisInputStream);</span><br><span class="line">    SqlSession sqlSession1 &#x3D; sqlSessionFactory.openSession(false);</span><br><span class="line">    SqlSession sqlSession2 &#x3D; sqlSessionFactory.openSession(false);</span><br><span class="line">    SqlSession sqlSession3 &#x3D; sqlSessionFactory.openSession(false);</span><br><span class="line"></span><br><span class="line">    BlogMapper blogMapper1 &#x3D; sqlSession1.getMapper(BlogMapper.class);</span><br><span class="line">    BlogMapper blogMapper2 &#x3D; sqlSession2.getMapper(BlogMapper.class);</span><br><span class="line">    BlogMapper blogMapper3 &#x3D; sqlSession3.getMapper(BlogMapper.class);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot; blogMapper1 查询出来的数据 : &quot; + blogMapper1.selectBlog(1));</span><br><span class="line">    sqlSession1.commit();</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot; blogMapper2 查询出来的结果 : &quot; + blogMapper2.selectBlog(1));</span><br><span class="line"></span><br><span class="line">    System.out.println(blogMapper3.updateHashCode(&quot;GavinYang&quot;));</span><br><span class="line">    sqlSession3.commit();</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot; blogMapper2 查询出来的结果 : &quot; + blogMapper2.selectBlog(1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;  ------------------  打印结果 ------</span><br><span class="line"></span><br><span class="line">Created connection 630074945.</span><br><span class="line">Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@258e2e41]</span><br><span class="line">&#x3D;&#x3D;&gt;  Preparing: select * from tb_blog where id &#x3D; ? </span><br><span class="line">&#x3D;&#x3D;&gt; Parameters: 1(Integer)</span><br><span class="line">&lt;&#x3D;&#x3D;    Columns: id, name</span><br><span class="line">&lt;&#x3D;&#x3D;        Row: 1, 6565</span><br><span class="line">&lt;&#x3D;&#x3D;      Total: 1</span><br><span class="line"> blogMapper1 查询出来的数据 : TbBlog&#123;id&#x3D;1, name&#x3D;&#39;6565&#39;&#125;</span><br><span class="line">Cache Hit Ratio [com.iyang.mybatis.mapper.BlogMapper]: 0.5</span><br><span class="line"> blogMapper2 查询出来的结果 : TbBlog&#123;id&#x3D;1, name&#x3D;&#39;6565&#39;&#125;</span><br><span class="line"></span><br><span class="line">Created connection 603443293.</span><br><span class="line">Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@23f7d05d]</span><br><span class="line">&#x3D;&#x3D;&gt;  Preparing: update tb_blog set name &#x3D; ? where id &#x3D; 1; </span><br><span class="line">&#x3D;&#x3D;&gt; Parameters: GavinYang(String)</span><br><span class="line">&lt;&#x3D;&#x3D;    Updates: 1</span><br><span class="line">1</span><br><span class="line">Committing JDBC Connection [com.mysql.jdbc.JDBC4Connection@23f7d05d]</span><br><span class="line">Cache Hit Ratio [com.iyang.mybatis.mapper.BlogMapper]: 0.3333333333333333</span><br><span class="line">Opening JDBC Connection</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">Created connection 707976812.</span><br><span class="line">Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@2a32de6c]</span><br><span class="line">&#x3D;&#x3D;&gt;  Preparing: select * from tb_blog where id &#x3D; ? </span><br><span class="line">&#x3D;&#x3D;&gt; Parameters: 1(Integer)</span><br><span class="line">&lt;&#x3D;&#x3D;    Columns: id, name</span><br><span class="line">&lt;&#x3D;&#x3D;        Row: 1, GavinYang</span><br><span class="line">&lt;&#x3D;&#x3D;      Total: 1</span><br><span class="line"> blogMapper2 查询出来的结果 : TbBlog&#123;id&#x3D;1, name&#x3D;&#39;GavinYang&#39;&#125;</span><br></pre></td></tr></table></figure>

<p>这里是可以看到在更新之后并且 commit 了事务之后，后面紧跟的 sql 是去查询 数据库了的.   所以这里是可以看出来，update等操作是会去 清空对应的缓存的。</p>
<p>这里我们根据 案例一 的情况来分析，在开启了 二级缓存 的时候，是从哪里获取出来的数据的呢？</p>
<p>debug 跟进来 :     org.apache.ibatis.executor.CachingExecutor#query(org.apache.ibatis.mapping.MappedStatement, java.lang.Object, org.apache.ibatis.session.RowBounds,  org.apache.ibatis.session.ResultHandler,  org.apache.ibatis.cache.CacheKey, org.apache.ibatis.mapping.BoundSql)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span><br><span class="line">    throws SQLException &#123;</span><br><span class="line">  Cache cache &#x3D; ms.getCache();</span><br><span class="line">  if (cache !&#x3D; null) &#123;</span><br><span class="line">    flushCacheIfRequired(ms);</span><br><span class="line">    if (ms.isUseCache() &amp;&amp; resultHandler &#x3D;&#x3D; null) &#123;</span><br><span class="line">      ensureNoOutParams(ms, boundSql);</span><br><span class="line">      @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">&#x2F;&#x2F; debug 到这里，可以看到,就已经返回了我们需要的数据.        </span><br><span class="line">      List&lt;E&gt; list &#x3D; (List&lt;E&gt;) tcm.getObject(cache, key);</span><br><span class="line">      if (list &#x3D;&#x3D; null) &#123;</span><br><span class="line">        list &#x3D; delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">        tcm.putObject(cache, key, list); &#x2F;&#x2F; issue #578 and #116</span><br><span class="line">      &#125;</span><br><span class="line">      return list;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>org.apache.ibatis.executor.CachingExecutor#tcm  调用这个对象的 getObject  方法获取到了我们需要的值, 跟进来又从  org.apache.ibatis.cache.decorators.TransactionalCache 的 getObject  获取出我们的值, 最后从   org.apache.ibatis.cache.decorators.TransactionalCache#delegate 获取出值,  返回回来的.</p>
<p>org.apache.ibatis.cache.decorators.TransactionalCache#getObject</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object getObject(Object key) &#123;</span><br><span class="line">  &#x2F;&#x2F; issue #116</span><br><span class="line">&#x2F;&#x2F; 从缓存中获取出值.    </span><br><span class="line">  Object object &#x3D; delegate.getObject(key);</span><br><span class="line">  if (object &#x3D;&#x3D; null) &#123;</span><br><span class="line">&#x2F;&#x2F; 如果获取出来是null,也就是缓存中没有的话,org.apache.ibatis.cache.decorators.TransactionalCache#entriesMissedInCache 就添加到这个集合中来.      </span><br><span class="line">    entriesMissedInCache.add(key);</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; issue #146</span><br><span class="line">&#x2F;&#x2F; commit 后需要 clear 的话，就会返回 null.</span><br><span class="line">&#x2F;&#x2F; 这里想下这个变量会不会和我门案例二中的 update 操作有关系呢？</span><br><span class="line">&#x2F;&#x2F; 这里再 update后再 debug 发现,  delegate 中获取出来的是 null ,也就是确实是获取不到缓存了</span><br><span class="line">&#x2F;&#x2F; 和这个参数没关系.    </span><br><span class="line">  if (clearOnCommit) &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return object;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MyBatis 二级缓存不适应于配置文件中存在多表查询的情况. 一般我们是单表的 cache, 由于 mybatis 的二级缓存是基于  namespace 的, 多表查询语句所在的 namespace 无法感应到其他的 namespace  中的语句对多表中设计修改，就会引发脏数据.  这个时候，可以采用 cache-ref 来做处理，但是这样的话,缓存的颗粒度就变粗了.</p>
<p>执行流程 :  如果开启了二级缓存的话， MyBatis 会先走二级缓存，如果二级缓存没有的话，就会去一级缓存看看，如果都没有的话，就去查询数据库.</p>
<p>二级缓存 :  用  org.apache.ibatis.executor.CachingExecutor 装饰了   org.apache.ibatis.executor.BaseExecutor 的子类, 委托具体职责给 delegate  之前，实现了二级缓存的查询和写入功能.</p>
<h4 id="-2"><a href="#-2" class="headerlink" title=""></a></h4><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>最后看 一级缓存和二级缓存，都是利用的 HashMap 这种来做到本地缓存， 只是二级缓存的作用范围比起一级缓存的话，是要大的，并且也利用了一些 装饰者 等设计模式来设计二级缓存的.</p>
<p>如果是部署的分布式项目的话，那么还是 得切换到 redis 这种缓存来了， 本地利用 HashMap 这种缓存满足不了的.</p>
<p>文献参考地址 : <a href="https://tech.meituan.com/2018/01/19/mybatis-cache.html" target="_blank" rel="noopener">https://tech.meituan.com/2018/01/19/mybatis-cache.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.lwfby.cn/2020/12/25/mybatis/mybatis-mapper-xml-read/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YangL">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/timg.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YangL">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/12/25/mybatis/mybatis-mapper-xml-read/" itemprop="url">mybatis-mapper-xml-read</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-12-25T00:36:37+08:00">
                2020-12-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MyBatis/" itemprop="url" rel="index">
                    <span itemprop="name">MyBatis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3.1k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  15
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="题记"><a href="#题记" class="headerlink" title="题记"></a>题记</h4><p> MyBatis是如何对 Mapper 文件中的sql进行处理呢？ 虽然上篇解析 mybatis-config.xml 是有进行说明的, 但是应该拿出来单独仔细解析下. 因为这个里面涉及到动态sql, 加上mapper文件自身也有很多标签内容,然后MyBatis是怎么读取出这些内容的呢？读取出来后,又是做了怎么样的处理, 然后达到了sql那种执行效果的呢？</p>
<p> 意思也就是,Mapper + 动态sql , 内容还是有点多的, 并且也很重要, 是非常有必要拿出来单独的仔细讲解下的.</p>
<h4 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h4><p> 在之前对标签的进行解析的时候,是有对 标签进行一个初步的解析. 然后里面其实是很多内容还没填补很详细,所以特意记录下对 详细操作的. 那么，下文就开始操作吧.</p>
<p> <strong>org.apache.ibatis.builder.xml.XMLMapperBuilder#parse</strong></p>
<p>主要来看这段解析的代码 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public void parse() &#123;</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F; 利用 org.apache.ibatis.session.Configuration 的 loadedResources</span><br><span class="line">&#x2F;&#x2F; 来判断是不是已经加载过了的.    </span><br><span class="line">  if (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line">    configurationElement(parser.evalNode(&quot;&#x2F;mapper&quot;));</span><br><span class="line">&#x2F;&#x2F; 这里添加到 loadedResources 中来,也就是用来控制是不是已经解析过了的.      </span><br><span class="line">    configuration.addLoadedResource(resource);</span><br><span class="line">    bindMapperForNamespace();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这三个方法给我一种好像解析那种没有还没解析完的 ? 这个地方有待完善.    </span><br><span class="line">  parsePendingResultMaps();</span><br><span class="line">  parsePendingCacheRefs();</span><br><span class="line">  parsePendingStatements();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; configurationElement 方法,</span><br><span class="line">&#x2F;&#x2F; 可以看到这个方法中,很多标签(namespace&#x2F;parameterMa&#x2F;resultMap&#x2F;sql)</span><br><span class="line">&#x2F;&#x2F; 还有下面的select&#x2F;insert&#x2F;update&#x2F;delete</span><br><span class="line">&#x2F;&#x2F; 这些熟悉的标签</span><br><span class="line">  private void configurationElement(XNode context) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      String namespace &#x3D; context.getStringAttribute(&quot;namespace&quot;);</span><br><span class="line">      if (namespace &#x3D;&#x3D; null || namespace.equals(&quot;&quot;)) &#123;</span><br><span class="line">        throw new BuilderException(&quot;Mapper&#39;s namespace cannot be empty&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">&#x2F;&#x2F; 将 namespace 赋值进去,也就是当前正在解析的 namespace.        </span><br><span class="line">      builderAssistant.setCurrentNamespace(namespace);</span><br><span class="line">        </span><br><span class="line">&#x2F;&#x2F; 这里是对缓存标签进行解析.        </span><br><span class="line">      cacheRefElement(context.evalNode(&quot;cache-ref&quot;));</span><br><span class="line">      cacheElement(context.evalNode(&quot;cache&quot;));</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 解析 parameterMap标签        </span><br><span class="line">      parameterMapElement(context.evalNodes(&quot;&#x2F;mapper&#x2F;parameterMap&quot;));</span><br><span class="line">        </span><br><span class="line">&#x2F;&#x2F;         </span><br><span class="line">      resultMapElements(context.evalNodes(&quot;&#x2F;mapper&#x2F;resultMap&quot;));</span><br><span class="line">      sqlElement(context.evalNodes(&quot;&#x2F;mapper&#x2F;sql&quot;));</span><br><span class="line">      buildStatementFromContext(context.evalNodes(&quot;select|insert|update|delete&quot;));</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      throw new BuilderException(&quot;Error parsing Mapper XML. The XML location is &#39;&quot; + resource + &quot;&#39;. Cause: &quot; + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p> <strong>resultMapElements 方法 :</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 这里的 list 是 xml 文件中的所有 &lt;resultMap&gt; 标签文件.</span><br><span class="line">private void resultMapElements(List&lt;XNode&gt; list) &#123;</span><br><span class="line">  for (XNode resultMapNode : list) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">&#x2F;&#x2F;  有点好奇,该方法返回的 ResultMap 这边好像并没有参数,有点尴尬.</span><br><span class="line">&#x2F;&#x2F;  不过是已经存储在 org.apache.ibatis.session.Configuration#resultMaps 中.       </span><br><span class="line">      resultMapElement(resultMapNode);</span><br><span class="line">    &#125; catch (IncompleteElementException e) &#123;</span><br><span class="line">      &#x2F;&#x2F; ignore, it will be retried</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">----------</span><br><span class="line">&#x2F;&#x2F; 最后跟进到这个方法中来.</span><br><span class="line">  private ResultMap resultMapElement(XNode resultMapNode, List&lt;ResultMapping&gt; additionalResultMappings, Class&lt;?&gt; enclosingType) &#123;</span><br><span class="line">    ErrorContext.instance().activity(&quot;processing &quot; + resultMapNode.getValueBasedIdentifier());</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 获取出 type , 这里我们获取出来的 type 是 TbBlog.    </span><br><span class="line">    String type &#x3D; resultMapNode.getStringAttribute(&quot;type&quot;,</span><br><span class="line">        resultMapNode.getStringAttribute(&quot;ofType&quot;,</span><br><span class="line">            resultMapNode.getStringAttribute(&quot;resultType&quot;,</span><br><span class="line">                resultMapNode.getStringAttribute(&quot;javaType&quot;))));</span><br><span class="line">&#x2F;&#x2F; 先判断 org.apache.ibatis.type.TypeAliasRegistry#typeAliases 中有没有,</span><br><span class="line">&#x2F;&#x2F; 如果没有的话,就会自己new一个出来.    </span><br><span class="line">    Class&lt;?&gt; typeClass &#x3D; resolveClass(type);</span><br><span class="line">    if (typeClass &#x3D;&#x3D; null) &#123;</span><br><span class="line">&#x2F;&#x2F; TODO,如果没有话?        </span><br><span class="line">      typeClass &#x3D; inheritEnclosingType(resultMapNode, enclosingType);</span><br><span class="line">    &#125;</span><br><span class="line">    Discriminator discriminator &#x3D; null;</span><br><span class="line">    List&lt;ResultMapping&gt; resultMappings &#x3D; new ArrayList&lt;&gt;(additionalResultMappings);</span><br><span class="line">    </span><br><span class="line"> &#x2F;&#x2F; 获取该 &lt;resultMap&gt; 下的子标签</span><br><span class="line">&#x2F;&#x2F; 那么这里也就是获取 &lt;id&gt; 和 &lt;result&gt; 这二个.    </span><br><span class="line">    List&lt;XNode&gt; resultChildren &#x3D; resultMapNode.getChildren();</span><br><span class="line">    for (XNode resultChild : resultChildren) &#123;</span><br><span class="line">&#x2F;&#x2F; 分为 constructor &#x2F; discriminator &#x2F; 其他 这三类情况        </span><br><span class="line">      if (&quot;constructor&quot;.equals(resultChild.getName())) &#123;</span><br><span class="line">        processConstructorElement(resultChild, typeClass, resultMappings);</span><br><span class="line">      &#125; else if (&quot;discriminator&quot;.equals(resultChild.getName())) &#123;</span><br><span class="line">        discriminator &#x3D; processDiscriminatorElement(resultChild, typeClass, resultMappings);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line"> &#x2F;&#x2F; 非前二者情况.         </span><br><span class="line">        List&lt;ResultFlag&gt; flags &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        if (&quot;id&quot;.equals(resultChild.getName())) &#123;</span><br><span class="line">         &#x2F;&#x2F; 如果标签是id的话,就会给flags添加ResultFlag.ID.</span><br><span class="line">          flags.add(ResultFlag.ID);</span><br><span class="line">        &#125;</span><br><span class="line">  &#x2F;&#x2F;  将返回回来的 ResultMapping 添加进来.       </span><br><span class="line">        resultMappings.add(buildResultMappingFromContext(resultChild, typeClass, flags));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F; 这里获取的是 &lt;resultMap&gt; 标签的 id 字段.    </span><br><span class="line">    String id &#x3D; resultMapNode.getStringAttribute(&quot;id&quot;,</span><br><span class="line">            resultMapNode.getValueBasedIdentifier());</span><br><span class="line">&#x2F;&#x2F; 这里还可以使用 extends 属性, 不是看到这里, 都好奇还有这种标签.    </span><br><span class="line">    String extend &#x3D; resultMapNode.getStringAttribute(&quot;extends&quot;);</span><br><span class="line">    Boolean autoMapping &#x3D; resultMapNode.getBooleanAttribute(&quot;autoMapping&quot;);</span><br><span class="line">&#x2F;&#x2F; 这里 new 了一个 ResultMapResolver 对象.   </span><br><span class="line">    ResultMapResolver resultMapResolver &#x3D; new ResultMapResolver(builderAssistant, id, typeClass, extend, discriminator, resultMappings, autoMapping);</span><br><span class="line">    try &#123;</span><br><span class="line">&#x2F;&#x2F; 这里最后就是 new 了一个 ResultMap 对象, 该对象的 id 是 namespace + 方法ID 拼接.</span><br><span class="line">&#x2F;&#x2F; 然后将该对象给添加到  org.apache.ibatis.session.Configuration#resultMaps 中来,</span><br><span class="line">&#x2F;&#x2F; key 就是其id, 最后就是根据 local &#x2F; global 来分别进行二种情况检查.        </span><br><span class="line">      return resultMapResolver.resolve();</span><br><span class="line">    &#125; catch (IncompleteElementException  e) &#123;</span><br><span class="line">      configuration.addIncompleteResultMap(resultMapResolver);</span><br><span class="line">      throw e;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;  buildResultMappingFromContext 方法</span><br><span class="line">&#x2F;&#x2F; 该方法是对 resultMap 中的字段进行解析.</span><br><span class="line">  private ResultMapping buildResultMappingFromContext(XNode context, Class&lt;?&gt; resultType, List&lt;ResultFlag&gt; flags) &#123;</span><br><span class="line">    String property;</span><br><span class="line">    if (flags.contains(ResultFlag.CONSTRUCTOR)) &#123;</span><br><span class="line">      property &#x3D; context.getStringAttribute(&quot;name&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      property &#x3D; context.getStringAttribute(&quot;property&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    String column &#x3D; context.getStringAttribute(&quot;column&quot;);</span><br><span class="line">    String javaType &#x3D; context.getStringAttribute(&quot;javaType&quot;);</span><br><span class="line">    String jdbcType &#x3D; context.getStringAttribute(&quot;jdbcType&quot;);</span><br><span class="line">    String nestedSelect &#x3D; context.getStringAttribute(&quot;select&quot;);</span><br><span class="line">    String nestedResultMap &#x3D; context.getStringAttribute(&quot;resultMap&quot;, () -&gt;</span><br><span class="line">      processNestedResultMappings(context, Collections.emptyList(), resultType));</span><br><span class="line">    String notNullColumn &#x3D; context.getStringAttribute(&quot;notNullColumn&quot;);</span><br><span class="line">    String columnPrefix &#x3D; context.getStringAttribute(&quot;columnPrefix&quot;);</span><br><span class="line">    String typeHandler &#x3D; context.getStringAttribute(&quot;typeHandler&quot;);</span><br><span class="line">    String resultSet &#x3D; context.getStringAttribute(&quot;resultSet&quot;);</span><br><span class="line">    String foreignColumn &#x3D; context.getStringAttribute(&quot;foreignColumn&quot;);</span><br><span class="line">    boolean lazy &#x3D; &quot;lazy&quot;.equals(context.getStringAttribute(&quot;fetchType&quot;, configuration.isLazyLoadingEnabled() ? &quot;lazy&quot; : &quot;eager&quot;));</span><br><span class="line">      </span><br><span class="line">&#x2F;&#x2F; 获取 javaType , typeHandler , jdbcType 等对象.      </span><br><span class="line">    Class&lt;?&gt; javaTypeClass &#x3D; resolveClass(javaType);</span><br><span class="line">    Class&lt;? extends TypeHandler&lt;?&gt;&gt; typeHandlerClass &#x3D; resolveClass(typeHandler);</span><br><span class="line">    JdbcType jdbcTypeEnum &#x3D; resolveJdbcType(jdbcType);</span><br><span class="line">&#x2F;&#x2F; org.apache.ibatis.builder.MapperBuilderAssistant#buildResultMapping(java.lang.Class&lt;?&gt;, java.lang.String, java.lang.String, java.lang.Class&lt;?&gt;, org.apache.ibatis.type.JdbcType, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.Class&lt;? extends org.apache.ibatis.type.TypeHandler&lt;?&gt;&gt;, java.util.List&lt;org.apache.ibatis.mapping.ResultFlag&gt;, java.lang.String, java.lang.String, boolean)</span><br><span class="line">&#x2F;&#x2F; 可以看到这里传递进来的参数还是很多的.</span><br><span class="line">&#x2F;&#x2F; 最后返回 ResultMapping 对象,也就是说这么多参数&amp;buildResultMapping方法中的参数,</span><br><span class="line">&#x2F;&#x2F;都设置到该对象中来了.     </span><br><span class="line">    return builderAssistant.buildResultMapping(resultType, property, column, javaTypeClass, jdbcTypeEnum, nestedSelect, nestedResultMap, notNullColumn, columnPrefix, typeHandlerClass, flags, resultSet, foreignColumn, lazy);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>SqlElement 方法</strong></p>
<p>该方法可以很明显的感受到是对 标签进行解析的.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private void sqlElement(List&lt;XNode&gt; list) &#123;</span><br><span class="line"> &#x2F;&#x2F; configuration 获取出来 dataBaseId是null,跳过此方法  </span><br><span class="line">  if (configuration.getDatabaseId() !&#x3D; null) &#123;</span><br><span class="line">    sqlElement(list, configuration.getDatabaseId());</span><br><span class="line">  &#125;</span><br><span class="line">&#x2F;&#x2F;    </span><br><span class="line">  sqlElement(list, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 有点好奇写代码风格:  sqlElement(list,configuration.getDatabaseId());</span><br><span class="line">------------------------</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;  sqlElement 方法</span><br><span class="line">  private void sqlElement(List&lt;XNode&gt; list, String requiredDatabaseId) &#123;</span><br><span class="line">    for (XNode context : list) &#123;</span><br><span class="line">        </span><br><span class="line"> &#x2F;&#x2F; 获取 databaseId 和 id 这二个属性的值.       </span><br><span class="line">      String databaseId &#x3D; context.getStringAttribute(&quot;databaseId&quot;);</span><br><span class="line">      String id &#x3D; context.getStringAttribute(&quot;id&quot;);</span><br><span class="line"> &#x2F;&#x2F;  org.apache.ibatis.builder.MapperBuilderAssistant#applyCurrentNamespace   </span><br><span class="line"> &#x2F;&#x2F; 该方法最后返回的id的值是: namespace + id       </span><br><span class="line">      id &#x3D; builderAssistant.applyCurrentNamespace(id, false);</span><br><span class="line">&#x2F;&#x2F;sqlFragments 不包含该id就返回true,也就说该Map是确定是否已经解析过了的.         </span><br><span class="line">      if (databaseIdMatchesCurrent(id, databaseId, requiredDatabaseId)) &#123;</span><br><span class="line">&#x2F;&#x2F; 添加到 org.apache.ibatis.builder.xml.XMLMapperBuilder#sqlFragments 中来.          </span><br><span class="line">        sqlFragments.put(id, context);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p> 最后 解析后的值,是使用 namespace + id 存放在 org.apache.ibatis.builder.xml.XMLMapperBuilder#sqlFragments 的属性中的.</p>
<p><strong>buildStatementFromContext() 方法 :</strong></p>
<p> 这里是对 select / insert / update / delete 标签进行解析.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">buildStatementFromContext(context.evalNodes(&quot;select|insert|update|delete&quot;));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 可以看到 databaseId 的获取与 sql 标签是一样的操作</span><br><span class="line">private void buildStatementFromContext(List&lt;XNode&gt; list) &#123;</span><br><span class="line">  if (configuration.getDatabaseId() !&#x3D; null) &#123;</span><br><span class="line">    buildStatementFromContext(list, configuration.getDatabaseId());</span><br><span class="line">  &#125;</span><br><span class="line">  buildStatementFromContext(list, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 所以我们可以跟进到这个方法来.</span><br><span class="line">  private void buildStatementFromContext(List&lt;XNode&gt; list, String requiredDatabaseId) &#123;</span><br><span class="line">    for (XNode context : list) &#123;</span><br><span class="line">&#x2F;&#x2F; 先 new 了一个 XMLStatementBuilder 对象, 紧接着就调用该对象的 解析 方法.        </span><br><span class="line">      final XMLStatementBuilder statementParser &#x3D; new XMLStatementBuilder(configuration, builderAssistant, context, requiredDatabaseId);</span><br><span class="line">      try &#123;</span><br><span class="line">        statementParser.parseStatementNode();</span><br><span class="line">      &#125; catch (IncompleteElementException e) &#123;</span><br><span class="line">        configuration.addIncompleteStatement(statementParser);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 解析方法</span><br><span class="line">  public void parseStatementNode() &#123;</span><br><span class="line">    String id &#x3D; context.getStringAttribute(&quot;id&quot;);</span><br><span class="line">    String databaseId &#x3D; context.getStringAttribute(&quot;databaseId&quot;);</span><br><span class="line">&#x2F;&#x2F; 用 namespace + id 组合为 id</span><br><span class="line">&#x2F;&#x2F; org.apache.ibatis.session.Configuration#mappedStatements</span><br><span class="line">&#x2F;&#x2F; 接着就是判断在 mappedStatements 中是不是有该id,如果不存在就返回ture,</span><br><span class="line">&#x2F;&#x2F; 存在就返回false,这里也就会直接return出去,也就是不会往后面执行了.      </span><br><span class="line">    if (!databaseIdMatchesCurrent(id, databaseId, this.requiredDatabaseId)) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F; 获取标签名字,  select &#x2F; insert&#x2F; update &#x2F;delete.</span><br><span class="line">    String nodeName &#x3D; context.getNode().getNodeName();</span><br><span class="line">&#x2F;&#x2F; 转化为大写的 SELECT      </span><br><span class="line">    SqlCommandType sqlCommandType &#x3D; SqlCommandType.valueOf(nodeName.toUpperCase(Locale.ENGLISH));</span><br><span class="line">    boolean isSelect &#x3D; sqlCommandType &#x3D;&#x3D; SqlCommandType.SELECT;</span><br><span class="line">&#x2F;&#x2F; 是否刷新 cache,也就是select是不刷新的,那么其他的就应该是要刷新的.      </span><br><span class="line">    boolean flushCache &#x3D; context.getBooleanAttribute(&quot;flushCache&quot;, !isSelect);</span><br><span class="line">&#x2F;&#x2F; 使用使用 cache,这里应该是一级缓存，默认开启的.      </span><br><span class="line">    boolean useCache &#x3D; context.getBooleanAttribute(&quot;useCache&quot;, isSelect);</span><br><span class="line">&#x2F;&#x2F; 结果排序, 如果没有配置的话,默认就是false.      </span><br><span class="line">    boolean resultOrdered &#x3D; context.getBooleanAttribute(&quot;resultOrdered&quot;, false);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Include Fragments before parsing</span><br><span class="line">&#x2F;&#x2F; 创建了一个 XMLIncludeTransformer 对象,该对象应该是进行转化的.      </span><br><span class="line">    XMLIncludeTransformer includeParser &#x3D; new XMLIncludeTransformer(configuration, builderAssistant);</span><br><span class="line"> &#x2F;&#x2F;  TODO ? 该方法有待更新     </span><br><span class="line">    includeParser.applyIncludes(context.getNode());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取 parameterType 属性,如果有的话,也会获取出该属性对应的 Class.    </span><br><span class="line">    String parameterType &#x3D; context.getStringAttribute(&quot;parameterType&quot;);</span><br><span class="line">    Class&lt;?&gt; parameterTypeClass &#x3D; resolveClass(parameterType);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; lang : null,这里是没有设置的.      </span><br><span class="line">    String lang &#x3D; context.getStringAttribute(&quot;lang&quot;);</span><br><span class="line">    LanguageDriver langDriver &#x3D; getLanguageDriver(lang);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Parse selectKey after includes and remove them.</span><br><span class="line">&#x2F;&#x2F; 这里对是否有 selectKey 进行处理.我们这里目前没有使用 selectKey</span><br><span class="line">    processSelectKeyNodes(id, parameterTypeClass, langDriver);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Parse the SQL (pre: &lt;selectKey&gt; and &lt;include&gt; were parsed and removed)</span><br><span class="line">    KeyGenerator keyGenerator;</span><br><span class="line"> &#x2F;&#x2F; selectBlog!selectKey     </span><br><span class="line">    String keyStatementId &#x3D; id + SelectKeyGenerator.SELECT_KEY_SUFFIX;</span><br><span class="line">&#x2F;&#x2F; 这里拼接上 namespace :  com.iyang.mybatis.mapper.BlogMapper.selectBlog!selectKey      </span><br><span class="line">    keyStatementId &#x3D; builderAssistant.applyCurrentNamespace(keyStatementId, true);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这里是判断是否有 主键自动生成. 这里是查询语句,应该是没有的. </span><br><span class="line">    if (configuration.hasKeyGenerator(keyStatementId)) &#123;</span><br><span class="line">      keyGenerator &#x3D; configuration.getKeyGenerator(keyStatementId);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      keyGenerator &#x3D; context.getBooleanAttribute(&quot;useGeneratedKeys&quot;,</span><br><span class="line">          configuration.isUseGeneratedKeys() &amp;&amp; SqlCommandType.INSERT.equals(sqlCommandType))</span><br><span class="line">          ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建一个 XMLScriptBuilder 对象,使用该对象的parseScriptNode方法来解析</span><br><span class="line">&#x2F;&#x2F; org.apache.ibatis.scripting.xmltags.XMLScriptBuilder#parseScriptNode</span><br><span class="line">&#x2F;&#x2F; 获取出sql, 有个 isDynamic 参数,来判断是不是动态sql语句.</span><br><span class="line">&#x2F;&#x2F; 这里不是动态sql,最后new了一个RawSqlSource.</span><br><span class="line">&#x2F;&#x2F; org.apache.ibatis.builder.SqlSourceBuilder#parse,我们的#&#123;id&#125; 替换成 ? 就是在</span><br><span class="line">&#x2F;&#x2F; 这里进行替换的.</span><br><span class="line">&#x2F;&#x2F; 如果是动态 sql 的话,就会创建出 DynamicSqlSource 该对象来.</span><br><span class="line">&#x2F;&#x2F; 可以看到 SqlSource 下面是有 四个实现类的.</span><br><span class="line">&#x2F;&#x2F; 这里返回的 SqlSource里面有sql语句的,和返回类型的.      </span><br><span class="line">    SqlSource sqlSource &#x3D; langDriver.createSqlSource(configuration, context, parameterTypeClass);</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 获取属性.      </span><br><span class="line">    StatementType statementType &#x3D; StatementType.valueOf(context.getStringAttribute(&quot;statementType&quot;, StatementType.PREPARED.toString()));</span><br><span class="line">    Integer fetchSize &#x3D; context.getIntAttribute(&quot;fetchSize&quot;);</span><br><span class="line">    Integer timeout &#x3D; context.getIntAttribute(&quot;timeout&quot;);</span><br><span class="line">    String parameterMap &#x3D; context.getStringAttribute(&quot;parameterMap&quot;);</span><br><span class="line">&#x2F;&#x2F; 获取返回类型. 获取出来的 resultTypeClass 是 class com.iyang.mybatis.pojo.TbBlog      </span><br><span class="line">    String resultType &#x3D; context.getStringAttribute(&quot;resultType&quot;);</span><br><span class="line">    Class&lt;?&gt; resultTypeClass &#x3D; resolveClass(resultType);</span><br><span class="line">    String resultMap &#x3D; context.getStringAttribute(&quot;resultMap&quot;);      </span><br><span class="line">    String resultSetType &#x3D; context.getStringAttribute(&quot;resultSetType&quot;);</span><br><span class="line">    ResultSetType resultSetTypeEnum &#x3D; resolveResultSetType(resultSetType);</span><br><span class="line">    if (resultSetTypeEnum &#x3D;&#x3D; null) &#123;</span><br><span class="line">      resultSetTypeEnum &#x3D; configuration.getDefaultResultSetType();</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F; 获取属性的值      </span><br><span class="line">    String keyProperty &#x3D; context.getStringAttribute(&quot;keyProperty&quot;);</span><br><span class="line">    String keyColumn &#x3D; context.getStringAttribute(&quot;keyColumn&quot;);</span><br><span class="line">    String resultSets &#x3D; context.getStringAttribute(&quot;resultSets&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建一个 MappedStatement.Builder 对象出来.</span><br><span class="line">&#x2F;&#x2F; 再通过 builder 构建出一个 MappedStatement 对象来.</span><br><span class="line">&#x2F;&#x2F; 最后放入到 org.apache.ibatis.session.Configuration#mappedStatements 中来.      </span><br><span class="line">    builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType,</span><br><span class="line">        fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass,</span><br><span class="line">        resultSetTypeEnum, flushCache, useCache, resultOrdered,</span><br><span class="line">        keyGenerator, keyProperty, keyColumn, databaseId, langDriver, resultSets);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private void processSelectKeyNodes(String id, Class&lt;?&gt; parameterTypeClass, LanguageDriver langDriver) &#123;</span><br><span class="line">    List&lt;XNode&gt; selectKeyNodes &#x3D; context.evalNodes(&quot;selectKey&quot;);</span><br><span class="line">    if (configuration.getDatabaseId() !&#x3D; null) &#123;</span><br><span class="line">      parseSelectKeyNodes(id, selectKeyNodes, parameterTypeClass, langDriver, configuration.getDatabaseId());</span><br><span class="line">    &#125;</span><br><span class="line">    parseSelectKeyNodes(id, selectKeyNodes, parameterTypeClass, langDriver, null);</span><br><span class="line">    removeSelectKeyNodes(selectKeyNodes);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p> 总结下 MyBatis 解析 Mapper的xml 文件流程。 可以感受到,对于Mybatis处理Mapper,对其字段属性都是挨个解析的,还是下了很大的功夫.</p>
<p> 先是有一个集合来控制是否已经解析过了,算是一种是否解析的开关配置. 可以看到其先后的解析顺序,</p>
<p>namespace –&gt; cache-ref –&gt; cache —&gt; mapper/parameterMap —&gt; mapper/resultMap —&gt; mapper/sql —&gt; select/insert/update/detele.</p>
<p> 当解析这些标签的时候, 又会对标签里面的属性进行解析. 这里,主要看下我们平常使用到最多的标签, MyBatis 对这些标签解析了后,其后有是怎么利用的呢？可以看到目前MyBatis是存放在一些configuration等类信息里面,那么等到真正去查询sql语句的时候, MyBatis 又是怎么用上的呢？ 这里目前只讲了如何解析.</p>
<p> 解析完了，没异常，那就是解析都ok了，剩下的就是看当 MyBatis 去查询的时候, 是怎么利用上这些资源的呢？所以看接下来的更新.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.lwfby.cn/2020/12/25/mybatis/mybatis-config-xml-read/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YangL">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/timg.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YangL">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/12/25/mybatis/mybatis-config-xml-read/" itemprop="url">mybatis-config-xml-read</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-12-25T00:35:10+08:00">
                2020-12-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MyBatis/" itemprop="url" rel="index">
                    <span itemprop="name">MyBatis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  4.4k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  20
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="题记"><a href="#题记" class="headerlink" title="题记"></a>题记</h4><p> 对于配置文件的解析, 还是相对比较好理解的, 就是读取配置文件, 然后在代码需要的地方给使用到.</p>
<p> 这里,可以扩展下, Spring / SpringBoot 等是怎么读取配置文件呢 ? 并且配置文件还是有 xml / properties/yaml 等格式的 ， 其读取代码是怎么写的 ? 然后基于 阿波罗(携程开源) 的配置中心 , 其实现配置又是怎么实现的呢 ? 然后这里，看了 Mybatis 读取配置文件, 后续再出 Spring 配置文件的时候，如果二者读取配置进行对比, 你个人更倾向使用代码呢 ?</p>
<p> 所以,这里就开启读取 Mybatis 是如何解析配置文件的操作.</p>
<h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p> 这里的配置文件解读,是根据 MyBatis官网来一步一步的解析阅读. 如果有官网没有涉及到的,发现了也会在后续加上去的. 解析多行代码, 才能理解 何为优秀.</p>
<p> <strong>标签一 : properties</strong></p>
<p> org.apache.ibatis.builder.xml.XMLConfigBuilder#parseConfiguration —&gt; propertiesElement(root.evalNode(“properties”)) 方法中来.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 这里传入进来的 XNode 的值,就是我们写的 properties 标签.</span><br><span class="line">&#x2F;&#x2F; 可以看到 XNode的属性,name标签的名字,attributes就是key&#x2F;value属性</span><br><span class="line">&#x2F;&#x2F; 比如这里: key 就是 resource , value 就是 .&#x2F;db.properties.</span><br><span class="line">private void propertiesElement(XNode context) throws Exception &#123;</span><br><span class="line">  if (context !&#x3D; null) &#123;</span><br><span class="line">&#x2F;&#x2F; 这里调用的node.getChildNodes(),如果有点话,会遍历挨个解析,最后封装成为key&#x2F;value结构.      </span><br><span class="line">    Properties defaults &#x3D; context.getChildrenAsProperties();</span><br><span class="line">&#x2F;&#x2F; 获取 resource &#x2F; url 二者的值.      </span><br><span class="line">    String resource &#x3D; context.getStringAttribute(&quot;resource&quot;);</span><br><span class="line">    String url &#x3D; context.getStringAttribute(&quot;url&quot;);</span><br><span class="line">&#x2F;&#x2F; 如果二者都是null,就会抛出异常来.      </span><br><span class="line">    if (resource !&#x3D; null &amp;&amp; url !&#x3D; null) &#123;</span><br><span class="line">      throw new BuilderException(&quot;The properties element cannot specify both a URL and a resource based property file reference.  Please specify one or the other.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line"> &#x2F;&#x2F; 这里先处理resource,再处理url,也就是有可能url会覆盖掉resource的内容.</span><br><span class="line"> &#x2F;&#x2F; 二者读取的方式不一样,前者是根据 resource开始读,url是根据绝对路径开始读.</span><br><span class="line"> &#x2F;&#x2F; 最后 defaults 里面放入的全部是 key&#x2F;value 对应的键值对</span><br><span class="line"> &#x2F;&#x2F; 也就是db.properties中的 key &#x2F; value 相对应i起来.     </span><br><span class="line">    if (resource !&#x3D; null) &#123;</span><br><span class="line">      defaults.putAll(Resources.getResourceAsProperties(resource));</span><br><span class="line">    &#125; else if (url !&#x3D; null) &#123;</span><br><span class="line">      defaults.putAll(Resources.getUrlAsProperties(url));</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F; 这里看的是 xml 里面是不是直接有 porperties 配置.     </span><br><span class="line">&#x2F;&#x2F; 如果有的话,就会putAll进去.      </span><br><span class="line">    Properties vars &#x3D; configuration.getVariables();</span><br><span class="line">    if (vars !&#x3D; null) &#123;</span><br><span class="line">      defaults.putAll(vars);</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F; 最后吧 defaults,也就是properties给放入到 BaseBuilder 和 Confifuration中去.      </span><br><span class="line">    parser.setVariables(defaults);</span><br><span class="line">    configuration.setVariables(defaults);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----------------------------</span><br><span class="line">&#x2F;&#x2F;  如何让 Properties vars &#x3D; configuration.getVariables(); 有值呢 ?</span><br><span class="line">&#x2F;&#x2F;  如果只是单个的 MyBatis 项目的话, 就自己手动new一个properties对象</span><br><span class="line">&#x2F;&#x2F;  然后key输入自己要覆盖掉的key就可以了</span><br><span class="line">        Properties dbConfigProperties &#x3D; new Properties();</span><br><span class="line">        dbConfigProperties.setProperty(&quot;jdbc.password&quot;,&quot;GavinYang&quot;);</span><br><span class="line"></span><br><span class="line">        SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(mybatisInputStream,dbConfigProperties);</span><br></pre></td></tr></table></figure>

<p> <strong>标签二 : settings</strong></p>
<p> 这是 MyBatis对 settings 的操作.</p>
<p> 具体的 settings 中每项配置参考官网链接 : <a href="https://mybatis.org/mybatis-3/configuration.html#properties" target="_blank" rel="noopener">https://mybatis.org/mybatis-3/configuration.html#properties</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 解析 setting ---&gt; 转化为 key &#x2F;value</span><br><span class="line">Properties settings &#x3D; settingsAsProperties(root.evalNode(&quot;settings&quot;));</span><br><span class="line">&#x2F;&#x2F; </span><br><span class="line">loadCustomVfs(settings);</span><br><span class="line">loadCustomLogImpl(settings);</span><br></pre></td></tr></table></figure>

<p>settingsAsProperties 方法</p>
<p> 可以看到, 该方法就是进行加载,转化为key/value键值对类型, 然后对其key检验是否在</p>
<p> Configuration 中都有 set 方法.</p>
<p>Notes : 为了验证下, 我们加上一个没有的标签, 可以看到下面的异常. 所以我们看到这种异常的时候，是可以去检查下是不是名字什么有问题.</p>
<h3 id="Cause-org-apache-ibatis-builder-BuilderException-Error-parsing-SQL-Mapper-Configuration-Cause-org-apache-ibatis-builder-BuilderException-The-setting-nnnnn-is-not-known-Make-sure-you-spelled-it-correctly-case-sensitive"><a href="#Cause-org-apache-ibatis-builder-BuilderException-Error-parsing-SQL-Mapper-Configuration-Cause-org-apache-ibatis-builder-BuilderException-The-setting-nnnnn-is-not-known-Make-sure-you-spelled-it-correctly-case-sensitive" class="headerlink" title="Cause: org.apache.ibatis.builder.BuilderException: Error parsing SQL Mapper Configuration. Cause: org.apache.ibatis.builder.BuilderException: The setting nnnnn is not known. Make sure you spelled it correctly (case sensitive)."></a>Cause: org.apache.ibatis.builder.BuilderException: Error parsing SQL Mapper Configuration. Cause: org.apache.ibatis.builder.BuilderException: The setting nnnnn is not known. Make sure you spelled it correctly (case sensitive).</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private Properties settingsAsProperties(XNode context) &#123;</span><br><span class="line">  if (context &#x3D;&#x3D; null) &#123;</span><br><span class="line">    return new Properties();</span><br><span class="line">  &#125;</span><br><span class="line"> &#x2F;&#x2F; 对 settings 下的 setting 进行解析 并且 转化为 key &#x2F; value 操作.   </span><br><span class="line">  Properties props &#x3D; context.getChildrenAsProperties();</span><br><span class="line">  &#x2F;&#x2F; Check that all settings are known to the configuration class</span><br><span class="line"> &#x2F;&#x2F; 对 Configuration 进行校验, 确认上面的 props 中的key 在 Configuration</span><br><span class="line">&#x2F;&#x2F; 中是都有set 方法的,目测是后面反射需要使用到.    </span><br><span class="line">  MetaClass metaConfig &#x3D; MetaClass.forClass(Configuration.class, localReflectorFactory);</span><br><span class="line">  for (Object key : props.keySet()) &#123;</span><br><span class="line">    if (!metaConfig.hasSetter(String.valueOf(key))) &#123;</span><br><span class="line">      throw new BuilderException(&quot;The setting &quot; + key + &quot; is not known.  Make sure you spelled it correctly (case sensitive).&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return props;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>loadCustomVfs(settings) 方法</p>
<p>该方法,主要就是读取 vfsImpl 对用的value,切割下,然后用 classForName 来获取 class,</p>
<p>最后赋值到 configuration 中去. 这里算是对 vfs 的一种自定义的扩展,虽然目前还不太清楚vfs具体作用.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private void loadCustomVfs(Properties props) throws ClassNotFoundException &#123;</span><br><span class="line">  &#x2F;&#x2F; 获取 vfsImpl 的 value.  </span><br><span class="line">  String value &#x3D; props.getProperty(&quot;vfsImpl&quot;);</span><br><span class="line">  if (value !&#x3D; null) &#123;</span><br><span class="line">   &#x2F;&#x2F; 根据 , 进行切割.   </span><br><span class="line">    String[] clazzes &#x3D; value.split(&quot;,&quot;);</span><br><span class="line">    for (String clazz : clazzes) &#123;</span><br><span class="line">      if (!clazz.isEmpty()) &#123;</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        &#x2F;&#x2F; 反射,获取出 Class , 最后赋值到 configuration 中去.  </span><br><span class="line">        Class&lt;? extends VFS&gt; vfsImpl &#x3D; (Class&lt;? extends VFS&gt;)Resources.classForName(clazz);</span><br><span class="line">        configuration.setVfsImpl(vfsImpl);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>loadCustomLogImpl(settings) 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">private void loadCustomLogImpl(Properties props) &#123;</span><br><span class="line">  Class&lt;? extends Log&gt; logImpl &#x3D; resolveClass(props.getProperty(&quot;logImpl&quot;));</span><br><span class="line">  &#x2F;&#x2F; 将 log set 到 configuration 中去.  </span><br><span class="line">  configuration.setLogImpl(logImpl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-----------------------</span><br><span class="line">&#x2F;&#x2F; resolve 最后如果不是 null 的话,</span><br><span class="line">org.apache.ibatis.type.TypeAliasRegistry#resolveAlias</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F; 就会走到这里,这里可以看先是在 typeAliases(HashMap) 中判断下,如果存在就直接获取</span><br><span class="line">&#x2F;&#x2F; 如果不存在就用 Resources.ClassForName来操作</span><br><span class="line">&#x2F;&#x2F; 这里的 HashMap就类似于,记录之前是否已经加载了或者预热.</span><br><span class="line">&#x2F;&#x2F; 如果是用来做cache的话, 那就应该最后会在 return 之前继续把值给放入进去.    </span><br><span class="line">  public &lt;T&gt; Class&lt;T&gt; resolveAlias(String string) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      if (string &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; issue #748</span><br><span class="line">      String key &#x3D; string.toLowerCase(Locale.ENGLISH);</span><br><span class="line">      Class&lt;T&gt; value;</span><br><span class="line">      if (typeAliases.containsKey(key)) &#123;</span><br><span class="line">        value &#x3D; (Class&lt;T&gt;) typeAliases.get(key);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        value &#x3D; (Class&lt;T&gt;) Resources.classForName(string);</span><br><span class="line">      &#125;</span><br><span class="line">      return value;</span><br><span class="line">    &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">      throw new TypeException(&quot;Could not resolve type alias &#39;&quot; + string + &quot;&#39;.  Cause: &quot; + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">&#x2F;&#x2F; 如果我们在配置文件中没有定义的话,这里默认是null,也就是说不会set进去.    </span><br><span class="line">  public void setLogImpl(Class&lt;? extends Log&gt; logImpl) &#123;</span><br><span class="line">    if (logImpl !&#x3D; null) &#123;</span><br><span class="line">      this.logImpl &#x3D; logImpl;</span><br><span class="line">      LogFactory.useCustomLogging(this.logImpl);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>标签三 :</strong></p>
<p> 关于别名的配置.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">typeAliasesElement(root.evalNode(&quot;typeAliases&quot;));</span><br><span class="line">private void typeAliasesElement(XNode parent) &#123;</span><br><span class="line">  if (parent !&#x3D; null) &#123;</span><br><span class="line">   &#x2F;&#x2F; 对 typeAliases 下的子标签进行迭代.</span><br><span class="line">   &#x2F;&#x2F; 分为是 package 和非 package   </span><br><span class="line">    for (XNode child : parent.getChildren()) &#123;</span><br><span class="line">      if (&quot;package&quot;.equals(child.getName())) &#123;</span><br><span class="line">       &#x2F;&#x2F; 获取你输入的包   </span><br><span class="line">        String typeAliasPackage &#x3D; child.getStringAttribute(&quot;name&quot;);</span><br><span class="line">        configuration.getTypeAliasRegistry().registerAliases(typeAliasPackage);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line"> &#x2F;&#x2F; &lt;typeAlias type&#x3D;&quot;com.iyang.mybatis.pojo.TbBlog&quot; alias&#x3D;&quot;TbBlog&quot; &#x2F;&gt;</span><br><span class="line"> &#x2F;&#x2F; 这里就是对这种进行解析的         </span><br><span class="line">        String alias &#x3D; child.getStringAttribute(&quot;alias&quot;);</span><br><span class="line">        String type &#x3D; child.getStringAttribute(&quot;type&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">          Class&lt;?&gt; clazz &#x3D; Resources.classForName(type);</span><br><span class="line">   &#x2F;&#x2F; 如果没写别名,就只传入 clazz.         </span><br><span class="line">          if (alias &#x3D;&#x3D; null) &#123;</span><br><span class="line">            typeAliasRegistry.registerAlias(clazz);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">   &#x2F;&#x2F; 写了别名,就别名和clazz一起传入进来.           </span><br><span class="line">            typeAliasRegistry.registerAlias(alias, clazz);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">          throw new BuilderException(&quot;Error registering typeAlias for &#39;&quot; + alias + &quot;&#39;. Cause: &quot; + e, e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----------------</span><br><span class="line">&#x2F;&#x2F; 这里可以看到是根据 packageName 来 register进来的.    </span><br><span class="line">  public void registerAliases(String packageName, Class&lt;?&gt; superType) &#123;</span><br><span class="line">    &#x2F;&#x2F; new 一个解析器工具类</span><br><span class="line">    ResolverUtil&lt;Class&lt;?&gt;&gt; resolverUtil &#x3D; new ResolverUtil&lt;&gt;();</span><br><span class="line">    &#x2F;&#x2F; 获取包的path,然后获取该包下的文件,如果文件是.class结尾的话</span><br><span class="line">    &#x2F;&#x2F; 最后在 ResolverUtil 中matchess是有该包下的全名称.</span><br><span class="line">    resolverUtil.find(new ResolverUtil.IsA(superType), packageName);</span><br><span class="line">    &#x2F;&#x2F; 这里返回的是上一步说的 matches</span><br><span class="line">    Set&lt;Class&lt;? extends Class&lt;?&gt;&gt;&gt; typeSet &#x3D; resolverUtil.getClasses();</span><br><span class="line">    for (Class&lt;?&gt; type : typeSet) &#123;</span><br><span class="line">      &#x2F;&#x2F; Ignore inner classes and interfaces (including package-info.java)</span><br><span class="line">      &#x2F;&#x2F; Skip also inner classes. See issue #6</span><br><span class="line">      &#x2F;&#x2F; 如果不是接口,不是内部类等条件的话,就走  registerAlias 方法</span><br><span class="line">      if (!type.isAnonymousClass() &amp;&amp; !type.isInterface() &amp;&amp; !type.isMemberClass()) &#123;</span><br><span class="line"> &#x2F;&#x2F; 先获取类名字,判断该类上有没有 @Alias 注解,如果有注解的话,就用注解的值作为缩写的.</span><br><span class="line"> &#x2F;&#x2F; 最后判断是不是null,是null就会抛出异常来.最后将上面获取出来的缩写名字,转化为大写.</span><br><span class="line"> &#x2F;&#x2F; 如果此时 typeAliases 是已经有了该值的话,就会抛出异常来.否则就放入到typeAliases来</span><br><span class="line"> &#x2F;&#x2F; private final Map&lt;String, Class&lt;?&gt;&gt; typeAliases &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"> &#x2F;&#x2F; 可以看到 typeAliases 是一个HashMap,并且其存储的Key&#x2F;Value还是蛮明显的.         </span><br><span class="line">        registerAlias(type);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>标签四</strong></p>
<p> 扩展的 demo 可以参考 MyBatis官网 : <a href="https://mybatis.org/mybatis-3/configuration.html" target="_blank" rel="noopener">https://mybatis.org/mybatis-3/configuration.html</a></p>
<p> 然后看 MyBatis 是如何将插件给利用上的呢 ?</p>
<p> 首先在 mybatis-config.xml 中配置好我们自己定义的 plugin</p>
<p> 这里以我配置了二个插件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugins&gt;</span><br><span class="line">    &lt;plugin interceptor&#x3D;&quot;com.iyang.mybatis.plugins.ExamplePlugin&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;GavinYang&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;age&quot; value&#x3D;&quot;22&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;hobby&quot; value&#x3D;&quot;lwf&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;plugin&gt;</span><br><span class="line"></span><br><span class="line">    &lt;plugin interceptor&#x3D;&quot;com.iyang.mybatis.plugins.QuerySqlPlugin&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;GavinYang&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;plugin&gt;</span><br><span class="line">&lt;&#x2F;plugins&gt;</span><br></pre></td></tr></table></figure>

<p>// 处理 plugin 的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private void pluginElement(XNode parent) throws Exception &#123;</span><br><span class="line">  &#x2F;&#x2F; 这里传入进来的就是 &lt;plugins&gt;整个标签内容.  </span><br><span class="line">  if (parent !&#x3D; null) &#123;</span><br><span class="line">   &#x2F;&#x2F; 获取 &lt;plugins&gt; 下的 &lt;plugin&gt; 集合,进行迭代处理.   </span><br><span class="line">    for (XNode child : parent.getChildren()) &#123;</span><br><span class="line">     &#x2F;&#x2F; 获取插件的 全限定名字.   </span><br><span class="line">      String interceptor &#x3D; child.getStringAttribute(&quot;interceptor&quot;);</span><br><span class="line">     &#x2F;&#x2F; 获取我们定义在 plugin 下的 properties.   </span><br><span class="line">      Properties properties &#x3D; child.getChildrenAsProperties();</span><br><span class="line">&#x2F;&#x2F; resolveClass是最后注册到typeAliasRegistry来.    </span><br><span class="line">&#x2F;&#x2F; 实例化,这里就可以看到我们在定义的Plugin中,无参构造函数打印出来的内容了.        </span><br><span class="line">      Interceptor interceptorInstance &#x3D; (Interceptor) resolveClass(interceptor).getDeclaredConstructor().newInstance();</span><br><span class="line">&#x2F;&#x2F; 将 properties 赋值给  interceptorInstance</span><br><span class="line">&#x2F;&#x2F; 也就是放入到 interceptorInstance 来.        </span><br><span class="line">      interceptorInstance.setProperties(properties);</span><br><span class="line">&#x2F;&#x2F; org.apache.ibatis.plugin.InterceptorChain</span><br><span class="line">&#x2F;&#x2F; 这是是将interceptorInstance添加到InterceptorChain的interceptors中来.        </span><br><span class="line">      configuration.addInterceptor(interceptorInstance);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 可以看到 MyBatis在加载plugin的时候,是利用了反射来new出一个对象来,并且注册到 typeAliasRegistry 中来. 这里主要是解析 plugin 的配置, 后面在执行sql的时候,都是如何使用到这些 plugin 的呢 ? 肯定是有一个从InterceptorChain中获取interceptors来,然后进行处理.</p>
<p><strong>标签五 : &lt; objectFactory &gt;</strong></p>
<p>objectFactory 的处理方式是和 标签四相似的,只是最后在使用场景是有点不同的.</p>
<p>代码上的操作也是类似的.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private void objectFactoryElement(XNode context) throws Exception &#123;</span><br><span class="line">  if (context !&#x3D; null) &#123;</span><br><span class="line">    String type &#x3D; context.getStringAttribute(&quot;type&quot;);</span><br><span class="line">    Properties properties &#x3D; context.getChildrenAsProperties();</span><br><span class="line">    ObjectFactory factory &#x3D; (ObjectFactory) resolveClass(type).getDeclaredConstructor().newInstance();</span><br><span class="line">    factory.setProperties(properties);</span><br><span class="line">    configuration.setObjectFactory(factory);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>标签五 :</strong></p>
<p>该标签在 MyBatis 官网是没有demo, 我是根据代码来顺藤摸瓜写的一个.</p>
<p> 参考 : org.apache.ibatis.reflection.wrapper.DefaultObjectWrapperFactory 这个源码,来模仿写的一个.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">objectWrapperFactoryElement(root.evalNode(&quot;objectWrapperFactory&quot;));</span><br><span class="line">private void objectWrapperFactoryElement(XNode context) throws Exception &#123;</span><br><span class="line">  if (context !&#x3D; null) &#123;</span><br><span class="line">   &#x2F;&#x2F; 获取 配置文件中的type值   </span><br><span class="line">    String type &#x3D; context.getStringAttribute(&quot;type&quot;);</span><br><span class="line"> &#x2F;&#x2F; 先注册到  typeAliasRegistry 来,然后实例化这个类.</span><br><span class="line"> &#x2F;&#x2F; 我们在自己定义的类中,写一个无参构造函数,就可以看到我们打印的内容了.     </span><br><span class="line">    ObjectWrapperFactory factory &#x3D; (ObjectWrapperFactory) resolveClass(type).getDeclaredConstructor().newInstance();</span><br><span class="line">&#x2F;&#x2F; 最后赋值到 confifuration 中来.      </span><br><span class="line">    configuration.setObjectWrapperFactory(factory);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>标签六 : &lt; reflectorFactory &gt;</strong></p>
<p>处理方式和上面类似.</p>
<p>这里我们自己写一个 com.iyang.mybatis.factory.GavinReflectorFactory 来继承DefaultReflectorFactory,在无参数构造函数中打印下内容, 然后debug跟进.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private void reflectorFactoryElement(XNode context) throws Exception &#123;</span><br><span class="line">  if (context !&#x3D; null) &#123;</span><br><span class="line">    String type &#x3D; context.getStringAttribute(&quot;type&quot;);</span><br><span class="line">    ReflectorFactory factory &#x3D; (ReflectorFactory) resolveClass(type).getDeclaredConstructor().newInstance();</span><br><span class="line">    configuration.setReflectorFactory(factory);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>标签七 :</strong></p>
<p>environments 标签都是放入一些 db 的配置信息等.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&lt;environments default&#x3D;&quot;development&quot;&gt;</span><br><span class="line">    &lt;environment id&#x3D;&quot;development&quot;&gt;</span><br><span class="line">        &lt;!-- 事务 --&gt;</span><br><span class="line">        &lt;transactionManager type&#x3D;&quot;JDBC&quot;&#x2F;&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;!-- DB 连接配置 --&gt;</span><br><span class="line">        &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;$&#123;jdbc.driver&#125;&quot; &#x2F;&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;jdbc.url&#125;&quot; &#x2F;&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;username&quot; value &#x3D; &quot;$&#123;jdbc.username&#125;&quot; &#x2F;&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;jdbc.password&#125;&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;dataSource&gt;</span><br><span class="line">    &lt;&#x2F;environment&gt;</span><br><span class="line">&lt;&#x2F;environments&gt;</span><br><span class="line">private void environmentsElement(XNode context) throws Exception &#123;</span><br><span class="line">  if (context !&#x3D; null) &#123;</span><br><span class="line">    if (environment &#x3D;&#x3D; null) &#123;</span><br><span class="line">&#x2F;&#x2F; 获取 default 对应字段的值         </span><br><span class="line">      environment &#x3D; context.getStringAttribute(&quot;default&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F; 这里的 getChildren 获取的是 &lt;environments&gt; --&gt; &lt;environment&gt;下的子标签      </span><br><span class="line">    for (XNode child : context.getChildren()) &#123;</span><br><span class="line">      String id &#x3D; child.getStringAttribute(&quot;id&quot;);</span><br><span class="line">&#x2F;&#x2F; 确保 id 和  上一步的environment 的值是相同的,就会返回true.      </span><br><span class="line">      if (isSpecifiedEnvironment(id)) &#123;</span><br><span class="line">&#x2F;**</span><br><span class="line">*  获取出 transactionManager 对应的标签.</span><br><span class="line">*  然后根据 JBDC(配置文件中的值),然后从 typeAliasRegistry中获取出来，</span><br><span class="line">*  调用反射来 实例化 这个对象. </span><br><span class="line">*  最后还是可以配置 properties,会被set到txFactory中去的.</span><br><span class="line">*  但是 JdbcTransactionFactory 好像没有重写 setProperties 方法.</span><br><span class="line">*&#x2F;          </span><br><span class="line">        TransactionFactory txFactory &#x3D; transactionManagerElement(child.evalNode(&quot;transactionManager&quot;));</span><br><span class="line">&#x2F;&#x2F; 先获取  dataSource 字段</span><br><span class="line">&#x2F;**</span><br><span class="line">*  先获取type的值,然后再获取 properties的标签字段值.</span><br><span class="line">*  根据我们的配置 : org.apache.ibatis.datasource.pooled.PooledDataSourceFactory,应该会获取出这个对象.该对象其内部是有一个,org.apache.ibatis.datasource.pooled.PooledDataSource的,里面有部分默认值的.</span><br><span class="line">*最后将  properties 调用 org.apache.ibatis.datasource.unpooled.UnpooledDataSourceFactory#setProperties方法,</span><br><span class="line">最后是将 properties 里面的key&#x2F;value 都设置到 MetaObject metaDataSource &#x3D; SystemMetaObject.forObject(dataSource);来了.</span><br><span class="line">*&#x2F;</span><br><span class="line">        DataSourceFactory dsFactory &#x3D; dataSourceElement(child.evalNode(&quot;dataSource&quot;));</span><br><span class="line">&#x2F;&#x2F; 从  PooledDataSourceFactory 中获取 datasource 属性.         </span><br><span class="line">        DataSource dataSource &#x3D; dsFactory.getDataSource();</span><br><span class="line">&#x2F;&#x2F; 这里采用链式编程,也就是将id&#x2F;txFactory&#x2F;dataSource 都给set到 Environment.Builder来了.         </span><br><span class="line">        Environment.Builder environmentBuilder &#x3D; new Environment.Builder(id)</span><br><span class="line">            .transactionFactory(txFactory)</span><br><span class="line">            .dataSource(dataSource);</span><br><span class="line">  &#x2F;&#x2F;    environmentBuilder.build() 也就是new 了一个 Environment </span><br><span class="line">  &#x2F;&#x2F; 最后 赋值到 configuration 中来了.        </span><br><span class="line">        configuration.setEnvironment(environmentBuilder.build());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 解析 environments ,利用 typeAliasRegistry 中已经注册好了的信息,然后根据名字缩写(比如JDBC)这种,来获取class对象, 用 反射来 new 一波对象出来,真是美滋滋. 接着就是解析 事务/JDBC连接配置信息等, 最后将信息保存到 DataSource 中来. 反手再来一波 链式编程 来new对象出来, 最后就是一个 Environment 对象出来,给set 到 configuration 中来.</p>
<p><strong>标签八</strong></p>
<p> 到这里,可以看到对xml的解析操作. 先解析 标签 的值出来,然后根据值进行分类处理或者根据自己的需求来进行处理.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">private void typeHandlerElement(XNode parent) &#123;</span><br><span class="line">  if (parent !&#x3D; null) &#123;</span><br><span class="line">    for (XNode child : parent.getChildren()) &#123;</span><br><span class="line">      &#x2F;&#x2F; 如果子标签是 package   </span><br><span class="line">      if (&quot;package&quot;.equals(child.getName())) &#123;</span><br><span class="line">       &#x2F;&#x2F; 获取出 name 对应的值.   </span><br><span class="line">        String typeHandlerPackage &#x3D; child.getStringAttribute(&quot;name&quot;);</span><br><span class="line">      &#x2F;&#x2F; 注册到   typeHandlerRegistry 中来.  </span><br><span class="line">        typeHandlerRegistry.register(typeHandlerPackage);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line"> &#x2F;&#x2F; 这里获取出三种值来,   javaType&#x2F;jdbcType&#x2F;  handler    </span><br><span class="line">        String javaTypeName &#x3D; child.getStringAttribute(&quot;javaType&quot;);</span><br><span class="line">        String jdbcTypeName &#x3D; child.getStringAttribute(&quot;jdbcType&quot;);</span><br><span class="line">        String handlerTypeName &#x3D; child.getStringAttribute(&quot;handler&quot;);</span><br><span class="line">        Class&lt;?&gt; javaTypeClass &#x3D; resolveClass(javaTypeName);</span><br><span class="line">        JdbcType jdbcType &#x3D; resolveJdbcType(jdbcTypeName);</span><br><span class="line">        Class&lt;?&gt; typeHandlerClass &#x3D; resolveClass(handlerTypeName);</span><br><span class="line">  &#x2F;&#x2F; 分为  javaTypeClass 是不是 null 的情况       </span><br><span class="line">        if (javaTypeClass !&#x3D; null) &#123;</span><br><span class="line">         &#x2F;&#x2F; 基于 javaTypeClass 是不是 null的情况,再判断 jdbcType 是不是null  </span><br><span class="line">          if (jdbcType &#x3D;&#x3D; null) &#123;</span><br><span class="line">            typeHandlerRegistry.register(javaTypeClass, typeHandlerClass);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            typeHandlerRegistry.register(javaTypeClass, jdbcType, typeHandlerClass);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">&#x2F;&#x2F; 这是根据   handlerTypeName 注册到 typeHandlerRegistry 中来.           </span><br><span class="line">          typeHandlerRegistry.register(typeHandlerClass);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>标签九 :</strong></p>
<p> 该标签是对我们对应的对象,其sql语句存放的地址. 也就是里面放入的是于mapper接口对应的方法,查询的sql语句.</p>
<p> 接下来看下 MyBatis 是对 mappers 标签的内容进行了说明解析和处理.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mapperElement</span><span class="params">(XNode parent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">      </span><br><span class="line"> <span class="comment">// getChildren 获取的是 mappers 下的 mapper 标签</span></span><br><span class="line">    <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123;</span><br><span class="line"><span class="comment">// 如果配置的是 package.        </span></span><br><span class="line">      <span class="keyword">if</span> (<span class="string">"package"</span>.equals(child.getName())) &#123;</span><br><span class="line">        String mapperPackage = child.getStringAttribute(<span class="string">"name"</span>);</span><br><span class="line">        configuration.addMappers(mapperPackage);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 获取出    resource/url/class 这三类的值.       </span></span><br><span class="line">        String resource = child.getStringAttribute(<span class="string">"resource"</span>);</span><br><span class="line">        String url = child.getStringAttribute(<span class="string">"url"</span>);</span><br><span class="line">        String mapperClass = child.getStringAttribute(<span class="string">"class"</span>);</span><br><span class="line"> <span class="comment">// 对 resource 处理         </span></span><br><span class="line">        <span class="keyword">if</span> (resource != <span class="keyword">null</span> &amp;&amp; url == <span class="keyword">null</span> &amp;&amp; mapperClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 将 resource 赋值给 ErrorContext 中  </span></span><br><span class="line">          ErrorContext.instance().resource(resource);</span><br><span class="line">     <span class="comment">// 读取文件.       </span></span><br><span class="line">          InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line"><span class="comment">// 使用 XMLMapperBuilder 来对解析xml内容.            </span></span><br><span class="line">          XMLMapperBuilder mapperParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());</span><br><span class="line">          mapperParser.parse();</span><br><span class="line"><span class="comment">// url 处理            </span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="keyword">null</span> &amp;&amp; url != <span class="keyword">null</span> &amp;&amp; mapperClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">          ErrorContext.instance().resource(url);</span><br><span class="line">          InputStream inputStream = Resources.getUrlAsStream(url);</span><br><span class="line">          XMLMapperBuilder mapperParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments());</span><br><span class="line">          mapperParser.parse();</span><br><span class="line"><span class="comment">// mapperClass 处理            </span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="keyword">null</span> &amp;&amp; url == <span class="keyword">null</span> &amp;&amp; mapperClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">          Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass);</span><br><span class="line">          configuration.addMapper(mapperInterface);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"A mapper element may only specify a url, resource or class, but not more than one."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----------------------</span><br><span class="line"><span class="comment">// 这里我们跟进 mapperParser.parse() 方法来</span></span><br><span class="line"><span class="comment">// org.apache.ibatis.builder.xml.XMLMapperBuilder</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 判断 configuration 的 loadedResources 是否含有该值,如果不含有的话,就会去解析.  </span></span><br><span class="line">    <span class="keyword">if</span> (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line"><span class="comment">// 对mapper 标签进行解析        </span></span><br><span class="line">      configurationElement(parser.evalNode(<span class="string">"/mapper"</span>));</span><br><span class="line">      configuration.addLoadedResource(resource);</span><br><span class="line">      bindMapperForNamespace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    parsePendingResultMaps();</span><br><span class="line">    parsePendingCacheRefs();</span><br><span class="line">    parsePendingStatements();</span><br><span class="line">  &#125;    </span><br><span class="line"></span><br><span class="line">-----------------------------------</span><br><span class="line"><span class="comment">//   configurationElement 方法</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configurationElement</span><span class="params">(XNode context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="comment">// 获取 namespace       </span></span><br><span class="line">      String namespace = context.getStringAttribute(<span class="string">"namespace"</span>);</span><br><span class="line">      <span class="keyword">if</span> (namespace == <span class="keyword">null</span> || namespace.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Mapper's namespace cannot be empty"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//  MapperBuilderAssistant 将 namespace 绑定到该类的参数中来.        </span></span><br><span class="line">      builderAssistant.setCurrentNamespace(namespace);</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 这里的 cache-ref / cache 都是暂时没有配置的.     </span></span><br><span class="line">      cacheRefElement(context.evalNode(<span class="string">"cache-ref"</span>));</span><br><span class="line">      cacheElement(context.evalNode(<span class="string">"cache"</span>));</span><br><span class="line">        </span><br><span class="line"> <span class="comment">//  /mapper/parameterMap 也是暂时没有配置的  </span></span><br><span class="line">      parameterMapElement(context.evalNodes(<span class="string">"/mapper/parameterMap"</span>));</span><br><span class="line">        </span><br><span class="line"><span class="comment">// resultMap 是对对象字段的映射</span></span><br><span class="line"><span class="comment">// mapper/sql 是对一些公用的sql进行抽取</span></span><br><span class="line"><span class="comment">// 二者暂时都没有配置        </span></span><br><span class="line">      resultMapElements(context.evalNodes(<span class="string">"/mapper/resultMap"</span>));</span><br><span class="line">      sqlElement(context.evalNodes(<span class="string">"/mapper/sql"</span>));</span><br><span class="line"><span class="comment">// 获取 select / insert / update / delete 等 标签.        </span></span><br><span class="line">      buildStatementFromContext(context.evalNodes(<span class="string">"select|insert|update|delete"</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Error parsing Mapper XML. The XML location is '"</span> + resource + <span class="string">"'. Cause: "</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;    </span><br><span class="line"></span><br><span class="line"><span class="comment">// 往下跟方法</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildStatementFromContext</span><span class="params">(List&lt;XNode&gt; list, String requiredDatabaseId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (XNode context : list) &#123;</span><br><span class="line">      <span class="keyword">final</span> XMLStatementBuilder statementParser = <span class="keyword">new</span> XMLStatementBuilder(configuration, builderAssistant, context, requiredDatabaseId);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        statementParser.parseStatementNode();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IncompleteElementException e) &#123;</span><br><span class="line">        configuration.addIncompleteStatement(statementParser);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.lwfby.cn/2020/12/25/mybatis/mybatis-work-flow-read/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YangL">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/timg.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YangL">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/12/25/mybatis/mybatis-work-flow-read/" itemprop="url">mybatis-work-flow-read</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-12-25T00:14:54+08:00">
                2020-12-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MyBatis/" itemprop="url" rel="index">
                    <span itemprop="name">MyBatis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  4.5k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  20
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="MyBatis-的工程流程分析"><a href="#MyBatis-的工程流程分析" class="headerlink" title="MyBatis 的工程流程分析"></a>MyBatis 的工程流程分析</h4><p>​    MyBatis 是我们在学习Java框架，也就是学习完JavaWeb的知识后,要学习到的一个ORM的框架. 我也是学习&amp;使用过后，再次对源码进行阅读的. 所以这篇文章记录 MyBatis 的一个 work flow.</p>
<p>​    先放上项目地址 : <a href="https://github.com/baoyang23/mybtatis-analysis/tree/master/mybatis-work-flow" target="_blank" rel="noopener">https://github.com/baoyang23/mybtatis-analysis/tree/master/mybatis-work-flow</a> </p>
<p>​    有兴趣的同学,可以clone下来看看.</p>
<h4 id="案例代码"><a href="#案例代码" class="headerlink" title="案例代码"></a>案例代码</h4><p>先放上案列的代码, 然后我们可以挨个的分析.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitHelloMyBatis</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 读取配置文件.</span></span><br><span class="line">        InputStream mybatisInputStream = Resources.getResourceAsStream(<span class="string">"mybatis-config.xml"</span>);</span><br><span class="line">        <span class="comment">// 传入读取配置文件的流,使用SqlSessionFactoryBuilder来</span></span><br><span class="line">        <span class="comment">// 构建 SqlSessionFactory.</span></span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(mybatisInputStream);</span><br><span class="line">        <span class="comment">// 从 SqlSessionFactory 中获取SqlSession会话.</span></span><br><span class="line">        SqlSession session = sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从会话中获取 Mapper.</span></span><br><span class="line">        BlogMapper blogMapper = session.getMapper(BlogMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用查询方法.</span></span><br><span class="line">        TbBlog tbBlog = blogMapper.selectBlog(<span class="number">1</span>);</span><br><span class="line">        System.out.println(tbBlog);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里说下大致流程 : </p>
<ul>
<li>使用 Resources 来读取 mybatis-config.xml配置文件, 如果该文件不存在或者读取出来 InputStream 是 null 的话,程序就会抛出 IOException 的错误来.</li>
<li>读取配置没有问题,来到 new SqlSessionFactoryBuilder().build(io) 来构建出一个 SqlSessionFactory 来, 这里构建出来的 SqlSessionFactory 肯定是有已经讲配置文件给全部加载进去了的.</li>
<li>SqlSessionFactory.openSession() 从 SqlSessionFactory 中获取一次会话, 然后可以从会话中获取出接口(BlogMapper)来,这里是不是有点好奇,明明这就是一个接口,也没有实现类,怎么就可以get出一个接口对象来?获取出接口来,然后就可以调用接口中的方法, 根据id查询出数据来.</li>
</ul>
<p>可以看到,根据从官网写的一个列子,从表面来看,代码量并不是很多. 所以接下来点去源码,去跟进源码中的每个方法,到底做了些什么事情.</p>
<p><strong>读取配置文件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InputStream mybatisInputStream &#x3D; Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br></pre></td></tr></table></figure>

<p>org.apache.ibatis.io.Resources (Class).</p>
<p>可以看到MyBatis源码还写了一个 ClassLoader的包装类，通过ClassLoaderWrapper包装类来讲配置文件转化为InputSream.</p>
<p>如果返回的InputStream是null，就会抛出IOException来.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Returns a resource on the classpath as a Stream object</span><br><span class="line"> *</span><br><span class="line"> * @param loader   The classloader used to fetch the resource</span><br><span class="line"> * @param resource The resource to find</span><br><span class="line"> * @return The resource</span><br><span class="line"> * @throws java.io.IOException If the resource cannot be found or read</span><br><span class="line"> *&#x2F;</span><br><span class="line">private static ClassLoaderWrapper classLoaderWrapper &#x3D; new ClassLoaderWrapper();</span><br><span class="line"></span><br><span class="line">public static InputStream getResourceAsStream(ClassLoader loader, String resource) throws IOException &#123;</span><br><span class="line">  &#x2F;&#x2F; 利用 ClasssLoaderWrapper.  </span><br><span class="line">  InputStream in &#x3D; classLoaderWrapper.getResourceAsStream(resource, loader);</span><br><span class="line">  if (in &#x3D;&#x3D; null) &#123;</span><br><span class="line">    throw new IOException(&quot;Could not find resource &quot; + resource);</span><br><span class="line">  &#125;</span><br><span class="line">  return in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>于是我们接着看 ClassLoaderWrapper 是怎么 读取配置文件 &amp; 转化为 InputStream 流的.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 这里返回的是 ClassLoader的数组,如果对ClassLoader不是很了解的话,可以先去百度了解下.</span><br><span class="line">ClassLoader[] getClassLoaders(ClassLoader classLoader) &#123;</span><br><span class="line">  return new ClassLoader[]&#123;</span><br><span class="line">      &#x2F;&#x2F; 传递进来的 </span><br><span class="line">      classLoader,</span><br><span class="line">      &#x2F;&#x2F; 默认的 ClassLoader</span><br><span class="line">      defaultClassLoader,</span><br><span class="line">      &#x2F;&#x2F; 根据当前线程获取出来的</span><br><span class="line">      Thread.currentThread().getContextClassLoader(),</span><br><span class="line">      &#x2F;&#x2F; 根据当前 Class 获取出来的.</span><br><span class="line">      getClass().getClassLoader(),</span><br><span class="line">      &#x2F;&#x2F; 系统的ClassLoader.</span><br><span class="line">      systemClassLoader&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取到了 classLoader的数组,然后对其进行迭代.</span><br><span class="line">&#x2F;&#x2F; 也就是使用 ClassLoader的  getResourceAsStream 方法,来讲 mybatis-config.xml</span><br><span class="line">&#x2F;&#x2F; 配置文件转化为 InputStream.</span><br><span class="line">&#x2F;&#x2F; 最后如果获取到InputStream都是null的话,那么返回的也就是null了.</span><br><span class="line">&#x2F;&#x2F; 根据上面的说法,返回的如果是null的话,就会出 IOException来.</span><br><span class="line">InputStream getResourceAsStream(String resource, ClassLoader[] classLoader) &#123;</span><br><span class="line">    for (ClassLoader cl : classLoader) &#123;</span><br><span class="line">      if (null !&#x3D; cl) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; try to find the resource as passed</span><br><span class="line">        InputStream returnValue &#x3D; cl.getResourceAsStream(resource);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; now, some class loaders want this leading &quot;&#x2F;&quot;, so we&#39;ll add it and try again if we didn&#39;t find the resource</span><br><span class="line">        if (null &#x3D;&#x3D; returnValue) &#123;</span><br><span class="line">          returnValue &#x3D; cl.getResourceAsStream(&quot;&#x2F;&quot; + resource);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (null !&#x3D; returnValue) &#123;</span><br><span class="line">          return returnValue;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>至此,MyBatis读取 mybatis-config.xml 配置文件也就是解析完毕,可以看到采用了自己写的 ClassLoaderWrapper来操作的, 传递一种 ClassLoader进来,其默认的&amp;系统&amp;线程的,加一起也是有四种. 最后挨个进来迭代，满足条件的会读取文件转化为InputStream,如果都是null的话,也会返回null.</strong></p>
<hr>
<p><strong>获取SqlSessionFactory &amp; 解析配置文件</strong></p>
<p>new SqlSessionFactoryBuilder() 也是new了一个 SqlSessionFactoryBuild,个人理解 SqlSessionFactoryBuilder 就是专程用来构建出 SqlSessionFactory 来的,毕竟其后面有一个 build 方法.</p>
<p>Problem ? 这里有个问题,为什么不将 SqlSessionFactoryBuilder 的build 方法,修改为静态的 ? 如果修改为静态的话，那就不用new了,就可以直接 SqlSessionFactoryBuilder.build(mybatisInputStream);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SqlSessionFactory sqlSessionFactory &#x3D; new                     SqlSessionFactoryBuilder().build(mybatisInputStream);</span><br></pre></td></tr></table></figure>

<p> <strong>SqlSessionFactory</strong></p>
<p> 接着我们来到 SqlSessionFactory 的 build 方法.</p>
<p> 这里在 finnaly 中, 可以看到 ErrorContext 利用了 ThreadLocal , 刚好这周出了 ThreadLocal 的视频.</p>
<p> 视频地址 : <a href="https://www.bilibili.com/video/BV1Ga4y1W72w" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Ga4y1W72w</a></p>
<p> 有兴趣&amp;乐于学习&amp;分享的,可以共同进步.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    &#x2F;&#x2F; 利用传入进来的参数,new出来了一个 XMLConfigBuilder.</span><br><span class="line">    XMLConfigBuilder parser &#x3D; new XMLConfigBuilder(inputStream, environment, properties);</span><br><span class="line">    return build(parser.parse());</span><br><span class="line">  &#125; catch (Exception e) &#123;</span><br><span class="line">    throw ExceptionFactory.wrapException(&quot;Error building SqlSession.&quot;, e);</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    &#x2F;&#x2F; 这里对 ThreadLocal 中进行 remove() 操作   </span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F; 关闭流.  </span><br><span class="line">      inputStream.close();</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">      &#x2F;&#x2F; Intentionally ignore. Prefer previous error.</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>new XmlConfigBuilder() 方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">public XMLConfigBuilder(InputStream inputStream, String environment, Properties props) &#123;</span><br><span class="line">  &#x2F;&#x2F; 先new一个XMLMapperEntityResolver,再new一个XPathParser,然后就走到下面的构造函数.</span><br><span class="line">  this(new XPathParser(inputStream, true, props, new XMLMapperEntityResolver()), environment, props);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 最后还是走到这个构造方法中来.</span><br><span class="line">private XMLConfigBuilder(XPathParser parser, String environment, Properties props) &#123;</span><br><span class="line">  super(new Configuration());</span><br><span class="line">  ErrorContext.instance().resource(&quot;SQL Mapper Configuration&quot;);</span><br><span class="line">  this.configuration.setVariables(props);</span><br><span class="line">  this.parsed &#x3D; false;</span><br><span class="line">  this.environment &#x3D; environment;</span><br><span class="line">  this.parser &#x3D; parser;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----------------------------------------</span><br><span class="line">&#x2F;&#x2F; new XPathParser代码:</span><br><span class="line">    </span><br><span class="line">  public XPathParser(InputStream inputStream, boolean validation, Properties variables, EntityResolver entityResolver) &#123;</span><br><span class="line">    &#x2F;&#x2F; 普通的构造方法.</span><br><span class="line">    &#x2F;&#x2F; 对 XPathParser的validation&#x2F;entityResolver&#x2F;variables&#x2F;xpath</span><br><span class="line">    &#x2F;&#x2F; 的属性进行赋值操作.</span><br><span class="line">    commonConstructor(validation, variables, entityResolver);</span><br><span class="line">    this.document &#x3D; createDocument(new InputSource(inputStream));</span><br><span class="line">  &#125;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; createDocument 方法</span><br><span class="line">  private Document createDocument(InputSource inputSource) &#123;</span><br><span class="line">    &#x2F;&#x2F; important: this must only be called AFTER common constructor</span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F; 这里通过debug看,返回的对象是DocumentBuilderFactoryImpl</span><br><span class="line">      &#x2F;&#x2F; 也就是其实现类.  </span><br><span class="line">      DocumentBuilderFactory factory &#x3D; DocumentBuilderFactory.newInstance();</span><br><span class="line">     &#x2F;&#x2F; 对 factory 的 features(HashMap) 添加值,   </span><br><span class="line">      factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);</span><br><span class="line">     &#x2F;&#x2F; 对 factory 的 validating 进行赋值  </span><br><span class="line">      factory.setValidating(validation);</span><br><span class="line">	 &#x2F;&#x2F; 这下面都是对 factory的属性进行赋值操作.	</span><br><span class="line">      factory.setNamespaceAware(false);</span><br><span class="line">      factory.setIgnoringComments(true);</span><br><span class="line">      factory.setIgnoringElementContentWhitespace(false);</span><br><span class="line">      factory.setCoalescing(false);</span><br><span class="line">      factory.setExpandEntityReferences(true);</span><br><span class="line">		</span><br><span class="line">      &#x2F;&#x2F; 可以看到 return new DocumentBuilderImpl</span><br><span class="line">      &#x2F;&#x2F; 最后返回的也是其实现类. </span><br><span class="line">      DocumentBuilder builder &#x3D; factory.newDocumentBuilder();</span><br><span class="line">      builder.setEntityResolver(entityResolver);</span><br><span class="line">      &#x2F;&#x2F; 设置错误的handler,可以看到ErrorHandler是接口,这里是匿名实现的</span><br><span class="line">      &#x2F;&#x2F; 也就是直接new了接口,然后重写其方法.  </span><br><span class="line">      builder.setErrorHandler(new ErrorHandler() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void error(SAXParseException exception) throws SAXException &#123;</span><br><span class="line">          throw exception;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void fatalError(SAXParseException exception) throws SAXException &#123;</span><br><span class="line">          throw exception;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void warning(SAXParseException exception) throws SAXException &#123;</span><br><span class="line">          &#x2F;&#x2F; NOP</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      &#x2F;&#x2F;   DocumentBuilderImpl 的 parse 解析方法</span><br><span class="line">      return builder.parse(inputSource);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      throw new BuilderException(&quot;Error creating document instance.  Cause: &quot; + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">-------------</span><br><span class="line">&#x2F;&#x2F;   builder.parse(inputSource)</span><br><span class="line"></span><br><span class="line">    public Document parse(InputSource is) throws SAXException, IOException &#123;</span><br><span class="line">        if (is &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(</span><br><span class="line">                DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN,</span><br><span class="line">                &quot;jaxp-null-input-source&quot;, null));</span><br><span class="line">        &#125;</span><br><span class="line">    &#x2F;&#x2F; fSchemaValidator 是 null ,跳过.</span><br><span class="line">        if (fSchemaValidator !&#x3D; null) &#123;</span><br><span class="line">            if (fSchemaValidationManager !&#x3D; null) &#123;</span><br><span class="line">                fSchemaValidationManager.reset();</span><br><span class="line">                fUnparsedEntityHandler.reset();</span><br><span class="line">            &#125;</span><br><span class="line">            resetSchemaValidator();</span><br><span class="line">        &#125;</span><br><span class="line">  &#x2F;&#x2F; 使用 xml 的相关类对 is 进行解析  </span><br><span class="line">        domParser.parse(is);</span><br><span class="line"> &#x2F;&#x2F;  ?   </span><br><span class="line">        Document doc &#x3D; domParser.getDocument();</span><br><span class="line"> &#x2F;&#x2F; ? 这些解析 Document 的地方.....   </span><br><span class="line">        domParser.dropDocumentReferences();</span><br><span class="line">        return doc;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------------</span><br><span class="line">&#x2F;&#x2F; 最后看到 this 构造函数.</span><br><span class="line"></span><br><span class="line">  private XMLConfigBuilder(XPathParser parser, String environment, Properties props) &#123;</span><br><span class="line">    &#x2F;** new Configuration() 中,TypeAliasRegistry typeAliasRegistry中的 typeAliases,</span><br><span class="line">    *   在初始化这个对象的时候,就默认设置了一些别名配置.</span><br><span class="line">    *   初始化的时候,还有对 LanguageDriverRegistry 的 LANGUAGE_DRIVER_MAP 赋值.</span><br><span class="line">    *  父类 :  BaseBuilder抽象类.</span><br><span class="line">    *  然后调用super方法,将configuration赋值父类的configuration</span><br><span class="line">    *  同时将 configuration的typeAliasRegistry和typeHandlerRegistry也赋值</span><br><span class="line">    *  给当前的这个对象.</span><br><span class="line">    *   </span><br><span class="line">    *&#x2F;</span><br><span class="line">    super(new Configuration());</span><br><span class="line">    &#x2F;&#x2F; instance() 方法是往 ThreadLocal里面去set了一个ErrorContext</span><br><span class="line">    &#x2F;&#x2F; 最后会在finnaly中进行remove掉.</span><br><span class="line">    ErrorContext.instance().resource(&quot;SQL Mapper Configuration&quot;);</span><br><span class="line">    &#x2F;&#x2F; 将 props 赋值到 configuration 的 variable 参数.</span><br><span class="line">    this.configuration.setVariables(props);</span><br><span class="line">    &#x2F;&#x2F; 表示还没有被解析</span><br><span class="line">    this.parsed &#x3D; false;</span><br><span class="line">    this.environment &#x3D; environment;</span><br><span class="line">    this.parser &#x3D; parser;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>到这里,就可以看到 this构造方法以及其之前还有new对象的方法,都已经走完了. 这上面的方法,基本都是再为后面的解析xml文件做准备, 并且还有一些初始化数据的赋值操作.</p>
<p><strong>Note</strong> : 注意这里的 BaseBuilder是抽象类,其实现类是有好几个的. 这种写法,其实是将子类的一些common的方法,写入到 BaseBuilder父类中,然后不同的方法,需要子类自己去重写这个方法实现自己的业务逻辑. 当然一些参数也是可以放在抽象类中.</p>
<p><strong>build(parser.parse())</strong> : 解析代码.</p>
<p> parser.parse() 方法 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public Configuration parse() &#123;</span><br><span class="line">  &#x2F;&#x2F; 用 parsed 来控制是否解析过,如果已经解析过了,那就抛出异常.  </span><br><span class="line">  if (parsed) &#123;</span><br><span class="line">    throw new BuilderException(&quot;Each XMLConfigBuilder can only be used once.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  parsed &#x3D; true;</span><br><span class="line">  &#x2F;&#x2F;   </span><br><span class="line">  parseConfiguration(parser.evalNode(&quot;&#x2F;configuration&quot;));</span><br><span class="line">  return configuration;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------------------------------</span><br><span class="line">&#x2F;&#x2F; parseConfiguration</span><br><span class="line">&#x2F;&#x2F; 这里 debug 可以看到 root 是 configuration 的配置文件信息.   </span><br><span class="line">&#x2F;&#x2F; 这里可以初步看到实对 我们的配置文件mybatis-config.xml进行解析,并且加载到 configuration中.</span><br><span class="line">&#x2F;&#x2F; 后面我们跟着官网文档一步一步的阅读,会有专门对解析配置的源码进行分析.    </span><br><span class="line">  private void parseConfiguration(XNode root) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F;issue #117 read properties first</span><br><span class="line">      &#x2F;&#x2F;   </span><br><span class="line">      propertiesElement(root.evalNode(&quot;properties&quot;));</span><br><span class="line">      Properties settings &#x3D; settingsAsProperties(root.evalNode(&quot;settings&quot;));</span><br><span class="line">      loadCustomVfs(settings);</span><br><span class="line">      loadCustomLogImpl(settings);</span><br><span class="line">      typeAliasesElement(root.evalNode(&quot;typeAliases&quot;));</span><br><span class="line">      pluginElement(root.evalNode(&quot;plugins&quot;));</span><br><span class="line">      objectFactoryElement(root.evalNode(&quot;objectFactory&quot;));</span><br><span class="line">      objectWrapperFactoryElement(root.evalNode(&quot;objectWrapperFactory&quot;));</span><br><span class="line">      reflectorFactoryElement(root.evalNode(&quot;reflectorFactory&quot;));</span><br><span class="line">      settingsElement(settings);</span><br><span class="line">      &#x2F;&#x2F; read it after objectFactory and objectWrapperFactory issue #631</span><br><span class="line">      environmentsElement(root.evalNode(&quot;environments&quot;));</span><br><span class="line">      databaseIdProviderElement(root.evalNode(&quot;databaseIdProvider&quot;));</span><br><span class="line">      typeHandlerElement(root.evalNode(&quot;typeHandlers&quot;));</span><br><span class="line">      mapperElement(root.evalNode(&quot;mappers&quot;));</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      throw new BuilderException(&quot;Error parsing SQL Mapper Configuration. Cause: &quot; + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>build(parser.parse()) 方法</strong></p>
<p>这里是对 parser.parse() 调用玩返回的 Configuration 传入到新创建的 DefaultSqlSessionFactory 对象中.</p>
<p>也就是说,我们拿到的 SqlSessionFactory 是 DefaultSqlSessionFactory.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public SqlSessionFactory build(Configuration config) &#123;</span><br><span class="line">  return new DefaultSqlSessionFactory(config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>获取 SqlSession</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">SqlSession session &#x3D; sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; org.apache.ibatis.session.defaults.DefaultSqlSessionFactory#openSessionFromDataSource</span><br><span class="line">&#x2F;&#x2F; 看到这个方法,直接跟进到这个方法来.</span><br><span class="line"></span><br><span class="line">  private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) &#123;</span><br><span class="line">    Transaction tx &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">        </span><br><span class="line">&#x2F;&#x2F; 从 configuration中获取出environment来,这里的 getEnvironment对应的是</span><br><span class="line">&#x2F;&#x2F; 标签的 &lt;environment&gt;  里面的内容</span><br><span class="line">&#x2F;&#x2F; org.apache.ibatis.mapping.Environment</span><br><span class="line">&#x2F;&#x2F; 可以看到这个对象,id对应mybatis-config.xml中的environment id</span><br><span class="line">&#x2F;&#x2F; datasource 对应  environment &gt; dataSource 字段.</span><br><span class="line">      final Environment environment &#x3D; configuration.getEnvironment();</span><br><span class="line">&#x2F;&#x2F; 根据    environment 来获取 TransactionFactory,也就是MyBatis的事务工厂.</span><br><span class="line">&#x2F;&#x2F; debug 是可以看到  environment 中是有一个JdbcTransactionFactory的,</span><br><span class="line">&#x2F;&#x2F; 如果没用的话,就会自己new一个 ManagedTransactionFactory 来.        </span><br><span class="line">      final TransactionFactory transactionFactory &#x3D; getTransactionFactoryFromEnvironment(environment);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在 JdbcTransactionFactory 中new出了一个 JdbcTransaction</span><br><span class="line">&#x2F;&#x2F; 也就是new了一个JDBC事务.</span><br><span class="line">&#x2F;&#x2F; org.apache.ibatis.transaction.jdbc.JdbcTransaction,</span><br><span class="line">&#x2F;&#x2F; 可以看到 JdbcTransaction 中有commit &#x2F; rollback的方法,</span><br><span class="line">&#x2F;&#x2F; 也就是说这个地方就是对事务进行操作的地方        </span><br><span class="line">      tx &#x3D; transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">&#x2F;&#x2F; 这里是获取是执行器,</span><br><span class="line">&#x2F;&#x2F; 具体代码: org.apache.ibatis.session.Configuration#newExecutor(org.apache.ibatis.transaction.Transaction, org.apache.ibatis.session.ExecutorType)</span><br><span class="line">&#x2F;&#x2F; 这里有 SIMPLE, REUSE, BATCH ,CachingExecutor 还可以在 plugin 中自己定义.</span><br><span class="line">&#x2F;&#x2F;executor &#x3D; (Executor) interceptorChain.pluginAll(executor); 从这行代码可以看到,</span><br><span class="line">&#x2F;&#x2F; 其实还是可以自己扩展的.        </span><br><span class="line">&#x2F;&#x2F;org.apache.ibatis.plugin.InterceptorChain        </span><br><span class="line">      final Executor executor &#x3D; configuration.newExecutor(tx, execType);</span><br><span class="line">&#x2F;&#x2F; 最后 new 出了一个默认的 SqlSession 会话.</span><br><span class="line">&#x2F;&#x2F; 该会话中存有 configuration &#x2F; executor 等核心东西.        </span><br><span class="line">      return new DefaultSqlSession(configuration, executor, autoCommit);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      closeTransaction(tx); &#x2F;&#x2F; may have fetched a connection so lets call close()</span><br><span class="line">      throw ExceptionFactory.wrapException(&quot;Error opening session.  Cause: &quot; + e, e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">&#x2F;&#x2F; 最后还是不忘记对使用过的ThreadLocal 进行remove 操作.        </span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>至此, 可以看到 MyBatis 从SqlSessionFactory中获取出来SqlSession会话, 也可以理解为几个步骤.</p>
<p>首先获取事务工厂, 然后再从事务工厂中获取一个事务来, JdbcTransaction 有兴趣的同学可以看下这个类,里面也是封装了写 commit / rollback等方法. 再接着获取出 执行器(Executor),这里从代码哪里看,执行器还是有几种类型的,也执行自定义. 最后new了一个 DefaultSqlSession 回去.</p>
<p><strong>session.getMapper(BlogMapper.class);</strong></p>
<p>接着看,上一步返回的session,是怎么获取到我们写的Mapper接口文件(Mapper这种文件,在解析配置文件的时候,其实就已经解析到MyBatis的configuration里面去了).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) &#123;</span><br><span class="line"> &#x2F;&#x2F; knownMappers  中 key 是我们定义接口的Class,value是MapperProxyFactory,</span><br><span class="line">&#x2F;&#x2F; MapperProxyFactory中的mapperInterface中存放了我们的接口class    </span><br><span class="line">  final MapperProxyFactory&lt;T&gt; mapperProxyFactory &#x3D; (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F; 如果获取出来的是null,那么MyBatis就认为你传入进来的接口是不存在的,就会抛出异常来.    </span><br><span class="line">  if (mapperProxyFactory &#x3D;&#x3D; null) &#123;</span><br><span class="line">    throw new BindingException(&quot;Type &quot; + type + &quot; is not known to the MapperRegistry.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  try &#123;</span><br><span class="line">&#x2F;&#x2F; 满足条件的话,调用newInstance方法,从方法名字上看,是创建一个instance的实例.      </span><br><span class="line">    return mapperProxyFactory.newInstance(sqlSession);</span><br><span class="line">  &#125; catch (Exception e) &#123;</span><br><span class="line">    throw new BindingException(&quot;Error getting mapper instance. Cause: &quot; + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line">&#x2F;&#x2F; mapperProxyFactory.newInstance(sqlSession) 代码</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">  public T newInstance(SqlSession sqlSession) &#123;</span><br><span class="line">    &#x2F;&#x2F; new 了一个 MapperProxy对象.</span><br><span class="line">    final MapperProxy&lt;T&gt; mapperProxy &#x3D; new MapperProxy&lt;&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">    return newInstance(mapperProxy);</span><br><span class="line">  &#125;    </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 最后可以看到使用 Proxy.newProxyInstance方法来创建的一个对象.</span><br><span class="line">  @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">  protected T newInstance(MapperProxy&lt;T&gt; mapperProxy) &#123;</span><br><span class="line">    return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-------</span><br><span class="line">&#x2F;&#x2F; 如果你是debug模式的话,那么你可以看到BlogMapper的对象地址池在 debug 中显示的值.</span><br><span class="line">&#x2F;&#x2F; org.apache.ibatis.binding.MapperProxy@ef9296d    </span><br><span class="line">BlogMapper blogMapper &#x3D; session.getMapper(BlogMapper.class);</span><br></pre></td></tr></table></figure>

<p>从SqlSession 中获取 BlogMapper我们写的mapper流程, 先从 knownMappers 中根据key获取出来之前加载配置已经加载完毕的信息,如果没用的话,就会抛出没有的异常. 最后使用 Proxy.newProxyIntsance来生成的一个类似接口实现类的代码,不同的是, 在 new MapperProxy 的时候,就已经将接下来需要的信息全部传入进去.</p>
<p><strong>blogMapper.selectBlog(1) 方法</strong></p>
<p>竟然 BlogMapper是通过Proxy.newInstance获取出来的,那它是怎么查询的数据库? 又是怎么将字段给映射到 Object一一对应的呢 ?</p>
<p> debug会走到 MapperProxy的invoke方法来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    if (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">      return method.invoke(this, args);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return cachedInvoker(method).invoke(proxy, method, args, sqlSession);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; catch (Throwable t) &#123;</span><br><span class="line">    throw ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------------</span><br><span class="line">&#x2F;&#x2F; 通过 invoke 方法, 走 mapperMethod的execute方法,来到了这里.</span><br><span class="line">&#x2F;&#x2F; switch 有 INSERT&#x2F;UPDATE&#x2F;DELETE&#x2F;SELECT&#x2F;FLUSH,如果这几种没有匹配到的话,就会抛出异常来.    </span><br><span class="line">  public Object execute(SqlSession sqlSession, Object[] args) &#123;</span><br><span class="line">    Object result;</span><br><span class="line">    switch (command.getType()) &#123;</span><br><span class="line">            </span><br><span class="line">&#x2F;&#x2F; 不难看到 INSERT&#x2F;UPDATE&#x2F;DELETE都是先调用 convertArgsToSqlCommandParam 方法,</span><br><span class="line">&#x2F;&#x2F; 也就是先将参数转化为sql,然后将执行的结果 赋值 给 result 参数.            </span><br><span class="line">      case INSERT: &#123;</span><br><span class="line">        Object param &#x3D; method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result &#x3D; rowCountResult(sqlSession.insert(command.getName(), param));</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">      case UPDATE: &#123;</span><br><span class="line">        Object param &#x3D; method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result &#x3D; rowCountResult(sqlSession.update(command.getName(), param));</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">      case DELETE: &#123;</span><br><span class="line">        Object param &#x3D; method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result &#x3D; rowCountResult(sqlSession.delete(command.getName(), param));</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">&#x2F;&#x2F; 如果是 select 语句,可以根据返回值来分类,如果是void&amp;&amp;method.hasResultHandler,就会返回null</span><br><span class="line">&#x2F;&#x2F; 多个 &#x2F; Map类型  &#x2F;    Cursor 类型   &#x2F;  最后查询一个        </span><br><span class="line">      case SELECT:</span><br><span class="line">        if (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;</span><br><span class="line">          executeWithResultHandler(sqlSession, args);</span><br><span class="line">          result &#x3D; null;</span><br><span class="line">        &#125; else if (method.returnsMany()) &#123;</span><br><span class="line">          result &#x3D; executeForMany(sqlSession, args);</span><br><span class="line">        &#125; else if (method.returnsMap()) &#123;</span><br><span class="line">          result &#x3D; executeForMap(sqlSession, args);</span><br><span class="line">        &#125; else if (method.returnsCursor()) &#123;</span><br><span class="line">          result &#x3D; executeForCursor(sqlSession, args);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          Object param &#x3D; method.convertArgsToSqlCommandParam(args);</span><br><span class="line">          result &#x3D; sqlSession.selectOne(command.getName(), param);</span><br><span class="line">          if (method.returnsOptional()</span><br><span class="line">              &amp;&amp; (result &#x3D;&#x3D; null || !method.getReturnType().equals(result.getClass()))) &#123;</span><br><span class="line">            result &#x3D; Optional.ofNullable(result);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line"> &#x2F;&#x2F; 刷新会话.           </span><br><span class="line">      case FLUSH:</span><br><span class="line">        result &#x3D; sqlSession.flushStatements();</span><br><span class="line">        break;</span><br><span class="line">      default:</span><br><span class="line">        throw new BindingException(&quot;Unknown execution method for: &quot; + command.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F; 如果result 是 null, 方法返回的修饰符是private并且 返回值不是void的话,就会抛出异常.    </span><br><span class="line">    if (result &#x3D;&#x3D; null &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123;</span><br><span class="line">      throw new BindingException(&quot;Mapper method &#39;&quot; + command.getName()</span><br><span class="line">          + &quot; attempted to return null from a method with a primitive return type (&quot; + method.getReturnType() + &quot;).&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看到,先是对 INSERT / UPDATE / DELETE / SELECT 进行分类处理, 然后对再分别根据不同的类型进行处理. 都是先有转化为sql,然后将执行结果赋值给result.</p>
<p>至于里面详细的查询执行sql,还有动态sql,每次会话缓存等,后面看到详细的情况再一一说明. 这里只是对MyBatis的基本工作进行了一个梳理. 然后后面再根据基础梳理,再来挨个击碎他们.</p>
<p>至此, MyBatis的入门分析流程是结束的. 理解起来,应该还不是那么难.</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>根据 com.iyang.mybatis.InitHelloMyBatis , 也就是入门的demo来梳理下流程.</p>
<ol>
<li>读取配置文件,也就是将配置文件读取,转化为inptStream流.</li>
<li>利用 SqlSessionFactoryBuilder 来 解析流, 起内部又利用 BaseBuilder(其又很多实现类,这里用的XMLConfigBuilder)也解析xml配置文件. Configuration configuration 该类中是保存着xml配置文件的很多信息. 然后 DefaultSqlSessionFactory 中有configuration字段,也就是属性.</li>
<li>然后从 DefaultSqlSessionFactory 中获取 SqlSession来, 并且也会是否开启事务(参考:org.apache.ibatis.transaction.jdbc.JdbcTransaction)类,然后获取 Executor,Executor也是有几种种类的,也可以自己自定义,最后返回一个 DefaultSqlSession 来.</li>
<li>然后从 SqlSession 中获取我们的接口Mapper, 最后也是利用 Proxy.newProxyInstance 来生成的接口,也就是代理(这里打印出地址池或者debug看地址池,就会很明显的看到是代理对象).</li>
<li>最后走查询的方法, 也就是走到了 MapperProxy 来. 可以看到MapperProxy里面是有sqlSession的,而SqlSession是有 Executor/configuration/autoCommit等信息的, 有了sqlSession,就剩下执行sql和映射sql查询出来的结果来了(这里是 mapperMethod.execute(sqlSession, args) —&gt; org.apache.ibatis.binding.MapperMethod#execute 走到这里来了,这里之后就会分类进行处理,然后映射sql语句).</li>
<li>至此,一个 MyBatis 的 HelloWorld分析流程是完毕的.</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.lwfby.cn/2020/11/29/life/%E7%88%AC%E5%B1%B1&%E8%BF%90%E5%8A%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YangL">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/timg.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YangL">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/11/29/life/%E7%88%AC%E5%B1%B1&%E8%BF%90%E5%8A%A8/" itemprop="url">爬山&运动</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-11-29T23:25:59+08:00">
                2020-11-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%94%9F%E6%B4%BB%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index">
                    <span itemprop="name">生活记录</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  716
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  2
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="爬山"><a href="#爬山" class="headerlink" title="爬山"></a>爬山</h4><p>​    距离上次爬上大梧桐，应该是过去了一年了. 说来也是好奇,这次爬上大梧桐的道路和去年爬上大梧桐的上山之道不一样,所以我也可以很装B的说句 :  <strong>完成一样的任务或者做一样东西的时候,方式有很多种,你可以尝试很多种,找到最合适自己的(hhhhhh).</strong></p>
<blockquote>
<p>​     由于现在地铁开通了,可以直接坐地铁到梧桐山的入口,相比于之前只能坐地铁转公交，现在有了地铁,是真的方便很多呀.</p>
<p>​       路线  :   小梧桐上 —&gt; 大梧桐 — &gt; 小梧桐下.</p>
<p>​       用时  :    9:30多开始, 然后四点下.  中间还有各种休息时间等.</p>
<p>​        </p>
<p>​       总结 :   总体阔别一年再上大梧桐,内心多多少少还是有点波动的,毕竟去年一起爬上去的人,都没再约了.所以这次爬上去,是我和我表姐(职业爬山？). hhhhh. </p>
<p>​                    爬小梧桐的时候,休息到比较少,所以在爬的时候,也难免会出现衣服上都是汉的. 这也是我不晓得大约过了多久之后,再出现这种都是汉的感觉. 然后再上大梧桐的时候,这种感觉就没有这么强烈了吧.</p>
<p>​                    好汉坡还是哪个好汉坡,给人看上去第一眼的感觉就好难.其实上过一次的话,我感觉都还好. 因为你爬完好汉坡之后,其实后面还是有一小段距离的.</p>
<p>​                   最后到了山顶,人还是蛮多的. 应该来这儿打卡的人会比较居多吧.</p>
</blockquote>
<h4 id="运动"><a href="#运动" class="headerlink" title="运动"></a>运动</h4><p>​     谈到运动,就想到我从小其实也不是喜欢运动的人, 反倒是一个喜欢吃喝,能不走的路就绝不会走. 说到运动,感觉也是一种机缘巧合的情况下,导致我这次疯狂的跑步什么的呀.</p>
<p>​       </p>
<blockquote>
<p> 运动不仅仅是跑步,但是先通过坚持跑步来锻炼自己的意志力吧.  要自己可以坚持下去,在有限的时间内,一直坚持下去,最好不要做到半途而废,这样不太好.</p>
<p>希望: 能通过跑步来锻炼出自己的韧性.  后期时间就了,能添加更多的其他运动操作.</p>
<p>感受:   跑步的时候,带上耳机,尽量控制均匀呼吸,然后你就会发现,你跑到越久,到后面的呼吸可能会比较难控制什么的,要经常跑,到后面就会慢慢控制好.  跑到中途的时候,其实自己的脑子就已经放空了很多东西. 这种放空脑子的感受,还是蛮舒服的. </p>
<p><strong>跑完记得拉伸下/跑完记得拉伸下/跑完记得拉伸下</strong></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.lwfby.cn/2020/11/25/life/%E4%B9%B0%E8%8F%9C&%E8%B7%91%E6%AD%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YangL">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/timg.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YangL">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/11/25/life/%E4%B9%B0%E8%8F%9C&%E8%B7%91%E6%AD%A5/" itemprop="url">买菜&跑步</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-11-25T23:25:59+08:00">
                2020-11-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%94%9F%E6%B4%BB%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index">
                    <span itemprop="name">生活记录</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  683
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  2
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="买菜"><a href="#买菜" class="headerlink" title="买菜"></a>买菜</h3><blockquote>
<p>说来也是好笑，由于今年疫情的原因，导致一个不会做饭的我，到现在也可以做出饭来了,也是奇奇怪怪的.</p>
<p>这里记录前不久,我在买菜的时候,看见一哥们在买鸡蛋的时候(这里可以买包装好了的,也可以买自己拿的,也就是一个一个的那种), 然后我看见那哥们买一个一个的,每个都拿起来摇一下,我就好奇了，他说:  <strong>摇一下,没用那种很散或者液体的流动的话,这个鸡蛋就可以放到久点.</strong></p>
</blockquote>
<h3 id="跑步"><a href="#跑步" class="headerlink" title="跑步"></a>跑步</h3><blockquote>
<p>2020-11-25 : 这是我坚持跑步的第十天，从之前的路程来看,我从第一天的2千米过渡到了 2到4这三天的三千多米，在过渡到5到7这三天的4千多米, 再到8到10这三天的5千多米.</p>
<p>从这几天跑5千米的过程来看,在过渡到第三千米的时候，是比较难坚持下去的,但是你咬咬牙，想到一些让自己很愤怒或者很去期待的事情,再就是把握好呼吸的节奏,其余的就交给自己的腿力啦.</p>
<p>跑完后,一定要拉伸下. 最初几天拉伸的时候,肯定会比较痛,我只说: 慢慢坚持下来.</p>
</blockquote>
<h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><blockquote>
<p>这段时间,因为一些事情或者个人原因,我总是很消极,具体原因也没有好说的.</p>
<p>于是,现在写这个,虽然我没有完全从那种很悲伤的情况中走出来,但是至少我不会像之前,真的是,每天都受那种情况所影响,所难受.</p>
<p>从我现在,下班回来就去跑步,然后做饭(第二天带去公司吃),然后做一组Keep，完完全全的充实了自己大晚上的时候.</p>
<p>如果晚上没时间，我还立下了那么多目标呢？</p>
<p>比如:  每周 录一个 源码的视频(手动狗头,虽然现在自己都不怎么明白hhhhh).</p>
<p>​           坚持Coding/坚持学习新技术/坚持去了解底层</p>
<p>​           坚持跑步/坚持做饭</p>
<p>​           坚持摄影(虽然现在拍出来的都是废片)</p>
<p>​           学习英语(规划)</p>
<p>​           学普通话标准.</p>
<p>​           每月看一本文学书籍(<strong>不是技术书籍,不是技术书籍,不是技术书籍</strong>.).</p>
<p>想之后:    学会游泳(等我瘦下去,一定要学花式).</p>
<p>​                 照片的后期处理</p>
<p>​                视频的剪辑和去杂音(hhhh,这个应该现在就要学习的.).</p>
</blockquote>
<p>最后,望看到这篇文章的人啊,我们一起加油,一起去期待下一个更好的自我.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/timg.jpg"
                alt="YangL" />
            
              <p class="site-author-name" itemprop="name">YangL</p>
              <p class="site-description motion-element" itemprop="description">I kown today that i am i</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/baoyang23" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="1411091515@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2019 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">YangL</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">81.6k</span>
  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




<div class="powered-by">
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <i class="fa fa-user-md"></i>
    <span id="busuanzi_container_site_uv">
        本站访客数:<span id="busuanzi_value_site_uv"></span>
    </span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_pv">
        本站访问量<span id="busuanzi_value_site_pv"></span>
    </span>
</div>

<script>
      var now = new Date(); 
      function createtime() { 
          var grt= new Date("03/12/2019 12:00:00");//此处修改你的建站时间或者网站上线时间 
          now.setTime(now.getTime()+250); 
          days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
          hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
          if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
          mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
          seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
          snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
          document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 "; 
          document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
      } 
  setInterval("createtime()",250);
  </script>

        







        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'manual') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":70,"height":120},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
